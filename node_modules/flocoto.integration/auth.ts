import e from "express";
import {AuthSession, PublicInfo} from "./integration";
import {AuthRole} from "./data";

declare module "express-session" {
    interface SessionData {
        flocotoDefaults?: {
            [session:string]:flocoto_auth.AuthDefaults
        }
    }
}


namespace flocoto_auth {

    export type HasSession = AuthSession & AuthSessionCurrent & {
        public: PublicInfo
    };

    interface AuthCurrentSets {
        readonly cargo_uid?:string
        readonly espaco_uid?:string
        readonly trabalha_uid?:string
    }

    export type AuthDefaults = {
        [ role in keyof AuthRole ]?: AuthRole[role] }

    export type AuthSessionSets = {
        [ props in keyof AuthSession ]?: AuthSession[ props ]
    }
    export interface AuthCurrent {
        readonly __auth_uid: string,
        readonly __user_auth: string,
        readonly __branch_auth:string,
        readonly __espaco_auth?:string
        readonly __cargo_auth?:string
        readonly __trabalha_auth?:string
    }

    export interface AuthSessionCurrent {
        current():AuthCurrent & {
            into<T>( into:T ):T &AuthCurrent
        },
        sets( sets:AuthDefaults ):AuthCurrent
        unsets( ):void
        update( sets:AuthSessionSets ):AuthSession & AuthSessionCurrent,
        snapshot():SnapshotSession
    }

    export type SnapshotSession = AuthSession & {
        public: PublicInfo
        current:AuthCurrent
    }

    export function hasSession( req:e.Request, session?: "default"|string|e.Response, res?: e.Response|string|"default"):HasSession{
        if( !session ) session = "default";
        let _res:e.Response;
        let _session:string;

        if( typeof session === "string" ) _session = session;
        else if( typeof res === "string" ) _session = res;
        else _session = "default";

        if( !!res && typeof res === "object" ) _res = res;
        else if( !!session && typeof session === "object" ) _res = session;


        let noSession  = ( message:string ) => {
            console.log( `[kitres]`, message );
            if( !!_res ){
                _res.status( 401 ).json({
                    result: false,
                    message: "Access dined!",
                    category: "Client error",
                    description: "The request has not been applied because it lacks valid authentication credentials for the target resource.",
                    location: "https://httpstatuscodes.org/401/",
                    status_code: 401,
                    title: "Unauthorized"
                })
            }
            return null;
        }
        if( !req.session ) return noSession( `!req.session`);
        if( !req.session.flocotoAuth ) return noSession( `!req.session.flocotoAuth`);
        if( !req.session.flocotoAuth[ _session ] ) return noSession( `!req.session.flocotoAuth[ ${ _session} ]`);
        if( !req.session.flocotoAuth[ _session ].userInfo ) return noSession( `!req.session.flocotoAuth[ ${ _session} ].userInfo`);
        if( !req.session.flocotoAuth[ _session ].userInfo.user_uid ) return noSession( `!req.session.flocotoAuth[ ${ _session} ].userInfo.user_uid`);

        if( !req.session.flocotoAuth[ _session ].branchInfo ) return noSession( `!req.session.flocotoAuth[ ${ _session} ].branchInfo`);
        if( !req.session.flocotoAuth[ _session ].branchInfo.branch_uid ) return noSession( `!req.session.flocotoAuth[ ${ _session} ].branchInfo.branch_uid`);

        if( !req.session.flocotoAuth[ _session ].grantsInfo ) return noSession( `!req.session.flocotoAuth[ ${ _session} ].grantsInfo`);
        if( !req.session.flocotoAuth[ _session ].rolesInfo ) return noSession( `!req.session.flocotoAuth[ ${ _session} ].rolesInfo`);



        function into<T>( into: T ): T & flocoto_auth.AuthCurrent {
            let {into:_into,... props} = current();
            return Object.assign( into, props );
        }


        function current():AuthCurrent & {
            into<T>( into:T ):T &AuthCurrent
        } {
            if( !req.session.flocotoDefaults ) req.session.flocotoDefaults = {};
            if( !req.session.flocotoDefaults[ _session ] ) req.session.flocotoDefaults[ _session ] = {};
            let useSession= req.session.flocotoAuth[ _session ];
            let useDefaults= req.session.flocotoDefaults[ _session ];
            return {
                __auth_uid: useSession.auth.auth_uid,
                __user_auth: useSession.userInfo.user_uid,
                __branch_auth: useSession.branchInfo.branch_uid,
                __espaco_auth: useDefaults?.espaco_uid,
                __cargo_auth: useDefaults?.cargo_uid,
                __trabalha_auth: useDefaults?.trabalha_uid,
                into
            }
        }

        function sets( sets: flocoto_auth.AuthDefaults): AuthCurrent {
            sets = sets || {};
            if( !req.session.flocotoDefaults )  req.session.flocotoDefaults = {};
            if( !req.session.flocotoDefaults[ _session ] ) req.session.flocotoDefaults[ _session ] = { };
            req.session.flocotoDefaults[ _session ] = {
                ... req.session.flocotoDefaults[ _session ],
                ... sets
            }
            return current();
        }

        function unsets (){
            //@ts-ignore
            delete req.session["flocotoPublic"];
            delete req.session.flocoto;
            delete req.session.flocotoDefaults;
            delete req.session.flocotoShare;
            delete req.session.flocotoAuth;
        }

        function snapshot ():SnapshotSession{
            return Object.assign({
                ...req.session.flocotoAuth[ _session ],
                public: req.session.flocotoPublic,
                current: current()
            });
        }


        function update( sets:AuthSessionSets ):AuthSession & AuthSessionCurrent{
            if( !req.session.flocotoAuth ) req.session.flocotoAuth = { };
            if( !req.session.flocotoAuth[ _session ] ) req.session.flocotoAuth[ _session ] = { } as any;
            if( !req.session.flocotoAuth[ _session ].auth ) req.session.flocotoAuth[ _session ].auth = { } as any;
            if( !req.session.flocotoAuth[ _session ].userInfo ) req.session.flocotoAuth[ _session ].userInfo = { } as any;
            if( !req.session.flocotoAuth[ _session ].branchInfo ) req.session.flocotoAuth[ _session ].branchInfo = { } as any;


            Object.assign( req.session.flocotoAuth[ _session ].auth, sets?.auth || {});
            Object.assign( req.session.flocotoAuth[ _session ].userInfo, sets?.userInfo || {});
            Object.assign( req.session.flocotoAuth[ _session ].branchInfo, sets?.branchInfo || {});
            req.session.flocotoAuth[ _session ].rolesInfo = sets?.rolesInfo || req.session.flocotoAuth[ _session ].rolesInfo || [];
            req.session.flocotoAuth[ _session ].grantsInfo = sets?.grantsInfo || req.session.flocotoAuth[ _session ].grantsInfo || [];
            return hasSession( req, _session, _res );
        }

        return Object.assign( req.session.flocotoAuth[ _session ], {
            public: req.session.flocotoPublic,
            current,
            sets,
            update,
            unsets,
            snapshot
        });
    }
}


export  = flocoto_auth;