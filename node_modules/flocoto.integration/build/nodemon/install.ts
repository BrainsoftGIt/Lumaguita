require( "source-map-support").install()
import {spawn} from "child_process";
import Path from "path";
import yargs from "yargs";
import {hideBin} from "yargs/helpers";
import manifest from "../../package.json";

const argv = yargs( hideBin(process.argv))
    .option("installOn", {
        type: "string",
        array: true
    }).parse();

let installOn:string[] = argv["installOn"] ||[];

export  function extensionIntegrationInstall( location:string  ) {

    let packLocation = Path.join(__dirname, /*language=file-reference*/ "../..");

    console.log("location:     ", location);
    console.log("packLocation: ", packLocation);

    let _process: ((promise: Promise<any>) => Promise<any>)[] = [];

    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let pack = spawn("npm", ["pack", packLocation], {
                    cwd: location,
                    shell: "cmd",
                    env: process.env
                });
                pack.stdout.pipe(process.stdout);
                pack.stderr.pipe(process.stderr);
                pack.on("exit", code => resolve(code));
            })
        });
    });

    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let install = spawn("npm", ["install", `.\\${manifest.name}-${manifest.version}.tgz`], {
                    shell: "cmd",
                    cwd: location,
                    env: process.env
                });
                install.stdout.pipe(process.stdout);
                install.stderr.pipe(process.stderr);
                install.on("exit", (code, signal) => resolve(code));
            })
        });
    });


    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let add = spawn("git", ["add", "./", "-f"], {
                    cwd: Path.join(location, "node_modules", manifest.name),
                });
                add.stdout.pipe(process.stdout);
                add.stderr.pipe(process.stderr);
                add.on("exit", (code, signal) => resolve(code));
            });
        })
    })

    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let add = spawn("git", ["commit", "./", "-m", `New changes of ${manifest.name} in version ${manifest.version}`], {
                    cwd: Path.join(location, "node_modules", manifest.name),
                });
                add.stdout.pipe(process.stdout);
                add.stderr.pipe(process.stderr);
                add.on("exit", (code, signal) => resolve(code));
            });
        })
    });


    let _next = Promise.resolve(0);
    _process.forEach(value => {
        _next = value(_next);
    });

    return _next;
}

if( require.main.filename === __filename ){
    Object.entries( manifest.installOnLocation ).forEach( ([key, local ]) => {
        if (key.startsWith("//") || key.startsWith("--")) return;
        if (installOn.length > 0 && !installOn.includes(key)) return;

        let location = Path.join(__dirname, /*language=file-reference*/ `../../../../../`, local);
        extensionIntegrationInstall( location  ).then( value => {

        }).catch( reason => {
            console.error( reason );
        })
    });
}



