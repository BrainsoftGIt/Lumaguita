"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extensionIntegrationInstall = void 0;
require("source-map-support").install();
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
const package_json_1 = __importDefault(require("../../package.json"));
const argv = (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
    .option("installOn", {
    type: "string",
    array: true
}).parse();
let installOn = argv["installOn"] || [];
function extensionIntegrationInstall(location) {
    let packLocation = path_1.default.join(__dirname, /*language=file-reference*/ "../..");
    console.log("location:     ", location);
    console.log("packLocation: ", packLocation);
    let _process = [];
    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let pack = (0, child_process_1.spawn)("npm", ["pack", packLocation], {
                    cwd: location,
                    shell: "cmd",
                    env: process.env
                });
                pack.stdout.pipe(process.stdout);
                pack.stderr.pipe(process.stderr);
                pack.on("exit", code => resolve(code));
            });
        });
    });
    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let install = (0, child_process_1.spawn)("npm", ["install", `.\\${package_json_1.default.name}-${package_json_1.default.version}.tgz`], {
                    shell: "cmd",
                    cwd: location,
                    env: process.env
                });
                install.stdout.pipe(process.stdout);
                install.stderr.pipe(process.stderr);
                install.on("exit", (code, signal) => resolve(code));
            });
        });
    });
    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let add = (0, child_process_1.spawn)("git", ["add", "./", "-f"], {
                    cwd: path_1.default.join(location, "node_modules", package_json_1.default.name),
                });
                add.stdout.pipe(process.stdout);
                add.stderr.pipe(process.stderr);
                add.on("exit", (code, signal) => resolve(code));
            });
        });
    });
    _process.push(promise => {
        return new Promise(resolve => {
            promise.then(value => {
                let add = (0, child_process_1.spawn)("git", ["commit", "./", "-m", `New changes of ${package_json_1.default.name} in version ${package_json_1.default.version}`], {
                    cwd: path_1.default.join(location, "node_modules", package_json_1.default.name),
                });
                add.stdout.pipe(process.stdout);
                add.stderr.pipe(process.stderr);
                add.on("exit", (code, signal) => resolve(code));
            });
        });
    });
    let _next = Promise.resolve(0);
    _process.forEach(value => {
        _next = value(_next);
    });
    return _next;
}
exports.extensionIntegrationInstall = extensionIntegrationInstall;
if (require.main.filename === __filename) {
    Object.entries(package_json_1.default.installOnLocation).forEach(([key, local]) => {
        if (key.startsWith("//") || key.startsWith("--"))
            return;
        if (installOn.length > 0 && !installOn.includes(key))
            return;
        let location = path_1.default.join(__dirname, /*language=file-reference*/ `../../../../../`, local);
        extensionIntegrationInstall(location).then(value => {
        }).catch(reason => {
            console.error(reason);
        });
    });
}
//# sourceMappingURL=install.js.map