/// <reference types="node" />
/// <reference types="cookie-parser" />
import { AuthBranch, AuthGrants, AuthInfo, AuthRole, AuthUserInfo, Viewport } from "./data";
import e from "express";
import { AxiosProxyConfig, AxiosRequestConfig, AxiosResponse } from "axios";
import { Cookie } from "express-session";
import { IncomingHttpHeaders } from "http";
import { Resource } from "./res";
import { Socket } from "socket.io-client";
import { DisconnectDescription } from "socket.io-client/build/esm-debug/socket";
import selects from "./selects";
import selects_res from "./selects.resolver";
import { BaseEventEmitter, CallableFunctionOnly, db, RevisionCore, RevisionPatch } from "kitres";
import { RequiredRegistryOptions } from "kitres/src/core/database/revision";
declare namespace __integration {
    export interface FlocotoApplication {
        name: string;
        host: string;
        port: number;
        protocol: "http" | "https";
        viewports: Viewport[];
    }
    export enum IntegrateEvents {
        INTEGRATE_CONNECT = "IntegrateEvents.INTEGRATE_CONNECT",
        INTEGRATE_READY = "IntegrateEvents.INTEGRATE_READY"
    }
    export interface ReadyOptions {
        application: string;
        readyCheck: string;
    }
    export type PublicInfo = {
        readonly cookie?: Cookie;
        readonly viewport?: string;
        readonly useSession?: string;
        readonly flocoto?: string;
        readonly headers?: IncomingHttpHeaders;
        readonly cookieId?: string;
        readonly sessionID?: string;
        readonly flocotoApps?: FlocotoApplication[];
    };
    export type AuthOptions = {
        identifier: string;
        user: string;
        method: string;
        secret: string;
        viewport: string;
        grants: number[];
        grantsCheck: "all" | "any" | "none";
        mode: string;
        extras?: any;
    };
    export interface AuthSession {
        auth: AuthInfo;
        userInfo: AuthUserInfo;
        branchInfo: AuthBranch;
        grantsInfo: AuthGrants[];
        rolesInfo: AuthRole[];
        extras?: any;
    }
    export type ConnectAuthOptions = {
        viewport: string;
        session: string;
    };
    export type ConnectAuthReturn = {
        redirect?: string;
        shareForAll?: {
            [props: string]: any;
        };
        shareForSession?: {
            [session: string]: {
                [props: string]: any;
            };
        };
    };
    export type ConnectAuthResponse = ConnectAuthReturn & {
        reject?: boolean;
    };
    export type ConnectOptions = {};
    export type ConnectResponse = {
        shareForAll?: {
            [props: string]: any;
        };
        shareForSession?: {
            [session: string]: {
                [props: string]: any;
            };
        };
        unShare?: string[];
    };
    export function onInternalResponse<T>(response: AxiosResponse<T, any>, onResponse: (error?: Error, data?: T) => void): void;
    export interface IntegrationApplicationOptions {
        host?: string;
        port?: number;
        protocol?: "http" | "https";
        namespace: string;
        integrateSchema: string;
        active: boolean;
        manifestFile: string;
    }
    export type DatabaseSharedResourceRevisions = {
        query: string;
        filename: string;
        options: RequiredRegistryOptions<any>;
    };
    export type InternalIntegrationOptions = {
        responseEvent?: string;
        readyCheck?: string;
        dbResources?: DatabaseSharedResourceRevisions[];
    };
    export interface ReadyResponse {
        revisions: RevisionPatch<any>[];
    }
    interface APIQueryOptions {
        session?: string;
        axios?: AxiosRequestConfig;
    }
    export enum ApplicationLocation {
        Local = "ApplicationLocation.Local",
        Remote = "ApplicationLocation.Remote"
    }
    export type FlocotoAuthOptions = {
        ready: boolean;
        host?: string;
        application?: string;
        namespace?: string;
        locationCheck?: string;
        location: ApplicationLocation;
        protocol: "http" | "https";
        resource: string | Resource[];
        resourceSelects: {
            [p: string]: selects.SelectsResource;
        };
        resourceRecursive: boolean;
        integrateSchema?: string;
        libdomSchema?: string;
        manifestFile?: string;
        integrationVersion?: string;
        active: boolean;
        port: number;
    };
    interface IntegrationEvents {
        initialized(error?: Error, block?: RevisionPatch<any>[]): void;
        connected(): void;
        connectionError(error: Error): void;
        connectionEnd(error: Socket.DisconnectReason, description: DisconnectDescription): void;
    }
    class Integration<C extends db.CatalogOf<C>, Q extends CallableFunctionOnly<Q>> extends BaseEventEmitter<IntegrationEvents> {
        private readonly _BaseRoute;
        private readonly _InternalRoute;
        private readonly _QueryRoute;
        private readonly options;
        private readonly __on_query;
        private _agentProxy;
        private readonly _manifest;
        private internalStake;
        private queryStack;
        private readonly revision;
        private readyCheck;
        private _authOptions;
        private _ready;
        private _socket;
        private _connection_auth;
        constructor(opts: IntegrationApplicationOptions, revision: RevisionCore<any>);
        get implement(): typeof this.internalStake.on;
        get respond(): typeof this.queryStack.on;
        setAgentProxy(proxy: false | AxiosProxyConfig): void;
        private listen;
        attacheSelect(select: selects_res.SelectsResourcesManager<C>): void;
        get connection(): Socket<import("@socket.io/component-emitter").DefaultEventsMap, import("@socket.io/component-emitter").DefaultEventsMap>;
        referer(viewport: string): string;
        integrate(): e.Router;
        onQuery(url: string, ...handlers: (typeof this.__on_query[number])[]): void;
        query<T>(application: string, path: string, opts: APIQueryOptions, data?: any, resolver?: (error: Error, response: T) => void): any;
        query<T>(application: string, path: string, opts: APIQueryOptions, data?: any): Promise<{
            error: Error;
            response: T;
        }>;
        useRevision(): db.RevisionCore<any>;
        get origin(): string;
        private auth;
        connect(auth: FlocotoAuthOptions, resolve: (error?: Error, response?: ReadyResponse) => void): void;
        connect(auth: FlocotoAuthOptions): Promise<{
            error?: Error;
            response: ReadyResponse;
        }>;
        private integrateResource;
        ready(): void;
    }
    export function integration<C, Q extends CallableFunctionOnly<Q>>(opts: IntegrationApplicationOptions, revision: RevisionCore<C>): Integration<C, Q>;
    export function getSharedSessionBySession(req: e.Request, session: string): {};
    export function getSharedSessionByFlocoto(req: e.Request, application: string): {
        [session: string]: {
            [props: string]: any;
        };
    };
    export {};
}
export = __integration;
//# sourceMappingURL=integration.d.ts.map