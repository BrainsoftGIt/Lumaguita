import { db } from "kitres";
import tns from "./tns";
import cns from "./cns";
import rns from "./rns";
import fns from "./fns";
import dfns from "./dfns";
import mfns from "./mfns";
import tfns from "./tfns";
import def from "./def";
import mns from "./mns";
import ens from "./ens";
import tmns from "./tmns";
import emns from "./emns";

namespace ins {
  export type SchemasOf<T extends { [K in tns.TypeProperties]?: T[K] }> =
    | keyof fns.FunctionMap
    | keyof tns.TypeOfMaps<T>
    | keyof rns.TableMaps<T>
    | keyof rns.ViewMaps<T>
    | keyof rns.CompositeMaps<T>
    | keyof ens.EnumMaps<T>
    | keyof mns.EnumMaps<T>
    | keyof tmns.EnumMaps<T>
    | keyof emns.EnumMaps<T>
    | keyof rns.MaterializeMaps<T>;

  export type ResourcesOf<T extends { [K in tns.TypeProperties]?: T[K] }> = {
    schemas: SchemasOf<T>[];

    functionsRefs: fns.FunctionRefsMap;
    functions: fns.FunctionMap;

    functionsProps: fns.FunctionProps;
    functionsPropsRefs: fns.FunctionsPropsRefs;

    tablesRefs: rns.TableRefsMaps<T>;
    tables: rns.TableMaps<T>;

    relationsRefs: rns.RelationRefsMaps<T>;
    relations: rns.RelationMaps<T>;

    viewsRefs: rns.ViewRefsMaps<T>;
    views: rns.ViewMaps<T>;

    composites: rns.CompositeMaps<T>;
    compositesRefs: rns.CompositeRefsMaps<T>;

    enumsRefs: mns.EnumRefsMaps;
    enums: mns.EnumMaps;

    materializesRefs: rns.MaterializeRefsMaps<T>;
    materializes: rns.MaterializeMaps<T>;

    types: tns.TypeOfMaps<T>;
  };

  export type TypedSchemaOfIns<T extends { [K in tns.TypeProperties]?: T[K] }> =
    SchemasOf<T>;
  export type TypedCatalogOfIns<
    T extends { [K in tns.TypeProperties]?: T[K] },
  > = db.CatalogOf<ResourcesOf<T>>;

  export type TypedFunctionOfOfIns<
    T extends { [K in tns.TypeProperties]?: T[K] },
  > = db.FunctionOf<fns.FunctionRefsMap>;
  export type TypedTableOfIns<T extends { [K in tns.TypeProperties]?: T[K] }> =
    db.TableOf<rns.TableRefsMaps<T>>;
  export type TypedRelationOfIns<
    T extends { [K in tns.TypeProperties]?: T[K] },
  > = db.RelationOf<rns.RelationRefsMaps<T>>;
  export type TypedViewOfIns<T extends { [K in tns.TypeProperties]?: T[K] }> =
    db.ViewOf<rns.ViewRefsMaps<T>>;
  export type TypedMaterializesOfIns<
    T extends { [K in tns.TypeProperties]?: T[K] },
  > = db.MaterializesOf<rns.MaterializeRefsMaps<T>>;
  export type TypedCompositeTypeOfIns<
    T extends { [K in tns.TypeProperties]?: T[K] },
  > = db.CompositeTypeOf<rns.CompositeRefsMaps<T>>;
  export type TypedEnumOfIns<T extends { [K in tns.TypeProperties]?: T[K] }> =
    db.EnumOf<rns.EnumRefsMaps<T>>;

  export type SchemaOfIns = TypedSchemaOfIns<any>;
  export type CatalogOfIns = db.CatalogOf<ResourcesOf<any>>;

  export type FunctionOfOfIns = TypedFunctionOfOfIns<any>;
  export type TableOfIns = TypedTableOfIns<any>;
  export type RelationOfIns = TypedRelationOfIns<any>;
  export type ViewOfIns = TypedViewOfIns<any>;
  export type MaterializesOfIns = TypedMaterializesOfIns<any>;
  export type CompositeTypeOfIns = TypedCompositeTypeOfIns<any>;
  export type EnumOfIns = TypedEnumOfIns<any>;
  export type TypeProperties = "*";

  export interface TypeOfMaps<T extends { [K in TypeProperties]?: T[K] }> {}
}

export default ins;
