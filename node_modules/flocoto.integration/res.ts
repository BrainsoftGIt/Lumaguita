import Path from "path";
import fs from "fs";

namespace menu {

    export type MenuResourceOptions ={
        id: number
        name: string
        code: string
        public?: boolean
        url?:string
        icon?: string
        status?:number
        position?:number
        application?:string
        viewports?:string[]
        super?:MenuResource
    }

    export abstract class Resource {
        classname:string
        application:string
        source:string
        protected constructor(opts:any, classname:string ) {
            Object.assign( this, opts );
            this.classname = classname;
        }
        
        abstract map():{
            classname:string,
            [p:string]:any
        };
    }

    export class MenuResource extends Resource implements MenuResourceOptions {
        id: number
        name: string
        code: string
        url?: string
        icon?: string
        public?: boolean
        status?: number
        position?: number
        application: string
        viewports?: string[]
        super?: MenuResource

        constructor( opts:MenuResourceOptions ) {
            super( opts, "auth.menu" );
        }

        get level(){
            if(  this.super ) return this.super.level +1;
            return 1;
        }

        family(){
            if( !this.super ) return [ this ];
            return  [ ...this.super.family(), this ];
        }

        map() {
            return {
                classname: this.classname,
                menu_id: this.id,
                menu_menu_id: this?.super?.id,
                menu_codigo: this.code,
                menu_nivel: this.level,
                menu_icon: this.icon,
                menu_public: this.public,
                menu_nome: this.name,
                menu_link: this.url,
                menu_estado: this.status,
                menu_position: this.position,
                menu_app: this.application,
                menu_viewports: this.viewports
            }
        }
    }

    export interface ViewportResourceOptions {
        id?:string
        name?:string
        desc?:string
        from?:string
        proxypath?:string
        status:number
        visible:boolean
        session:boolean
    }

    export class ViewportResource extends Resource {
        id?:string
        name?:string
        application:string
        desc?:string
        from?:string
        proxypath?:string
        status:number
        visible:boolean
        session:boolean

        constructor( opts:ViewportResourceOptions) {
            super( opts, "auth.viewport" );
        }

        map() {
            return {
                classname: this.classname,
                viewport_identifier: this.id,
                viewport_name: this.name,
                viewport_desc: this.desc,
                viewport_application: this.application,
                viewport_from: this.from,
                viewport_proxypath: this.proxypath,
                viewport_status: this.status,
                viewport_visible: this.visible,
                viewport_session: this.session
            }
        }
    }


    export type CollectMenuItemOptions = {
        recursive?:boolean,
        application:string
    }

    export interface CollectMenuItemEvent {
        error( filename:string, error?:Error ):void
        collect( menu:Resource, filename:string ):void
        end( menu:Set<Resource> ):void
    }

    function extractMenus( _container:any, source:string ):Resource[]{
        const container = _container as Resource;
        if( !container ) return [];

        if( container.classname === "auth.menu" && typeof container["family"] === "function" ) {
            container.source = source;
            return  [ ... (container["family"]().map( menu=>{
                if( !menu.source ) menu.source = source;
                return menu;
            }))];
        }

        if( container.classname === "auth.viewport" ){
            container.source = source;
            return  [ container ];

        }

        if( Array.isArray( container ) ){
            let _menu:Resource[] = [];
            container.forEach( (element)=>{
                _menu.push( ...extractMenus( element, source ) );
            });
            return  _menu;
        }

        if( typeof container === "object" ){
            let _menu:Resource[] = [];
            Object.entries( container ).forEach( ([ key, element ]) => {
                _menu.push( ...extractMenus( element, source ) );
            })
            return _menu;
        }
        return [ ];

    }

    export function collectResources(dirname:string, opts?: CollectMenuItemOptions, collected?:( error:Error, resource:Resource[])=>void){
        let res:Resource[] = [];
        let filter = new RegExp(`((^)*.${"res.js"})$`);

        let _collected = ( error:Error, resource:Resource[])=>{
            if( error ){
                return collected(error, resource);
            }

            resource = resource.map( value => {
                let menu = value as MenuResource;
                if( menu.classname === "auth.menu" && !!menu.icon && !Path.isAbsolute( menu.icon ) ){
                    menu.icon = Path.join( Path.dirname( value.source ), menu.icon );
                }
                value.application = opts.application;
                return value.map() as any;
            });

            collected( error, resource );
        }



        fs.readdir( dirname, { recursive: opts?.recursive }, ( err, files) => {

            if( err ) {
                _collected( err, null );
                return;
            }

            for ( let i = 0; i < files.length; i++ ) {
                let filename = files[ i ] as string;
                let path = Path.join( dirname, filename );
                let state = fs.statSync( path );

                if( !state.isFile() ) continue;
                if( !filter.test( filename ) ) continue;

                try {
                    const menuContainer = require( path );
                    let resources = extractMenus( menuContainer, path );
                    resources.forEach( menuItem => {
                        res.push( menuItem );
                    })
                } catch (e) {
                    _collected( e as Error, null);
                    return;
                }
            }

            _collected( null, [...res]);

        })
    }

    export function menu ( opts:MenuResourceOptions ):MenuResource{
        if( opts instanceof MenuResource ) return opts;
        return new MenuResource( opts );
    }

    export function viewport( opts:ViewportResourceOptions ){
        if( opts instanceof ViewportResource ) return opts;
        return  new ViewportResource( opts );
    }

}


export  = menu;