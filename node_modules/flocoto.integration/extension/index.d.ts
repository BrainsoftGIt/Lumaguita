import * as ctx from "./context";
import * as man from "../manifest";
import * as opts from "./context/options";
import * as def from "./context/defaults";
import { SnapshotSession } from "../auth";
import * as install from "../build/nodemon/install";
declare namespace extension {
    export import context = ctx.extContext;
    export import manifest = man.integrationManifest;
    export import ArgsOptions = opts.ArgsOptions;
    export import EnvOptions = opts.EnvOptions;
    export import ObjectOptions = opts.ObjectOptions;
    export import DefaultEnvObjects = def.DefaultExtEnvObject;
    export import extensionIntegrationInstall = install.extensionIntegrationInstall;
    export enum PropsType {
        OPTIONS = "PropsType.OPTIONS",
        LIST = "PropsType.LIST",
        ITEMS = "PropsType.ITEMS",
        NUMBER = "PropsType.NUMBER",
        BOOLEAN = "PropsType.BOOLEAN",
        OBJECT = "PropsType.OBJECT",
        ARRAY = "PropsType.ARRAY",
        TEXT = "PropsType.TEXT",
        DATE = "PropsType.DATE",
        FILE = "PropsType.FILE"
    }
    type PropsOptions<T extends PropsType> = {
        meta?: T extends typeof PropsType["OPTIONS"] ? {
            "option": string[];
            "description"?: string;
            "mode"?: "single" | "multiple";
        } : T extends typeof PropsType["LIST"] ? {
            "route": string;
            "mode"?: "single" | "multiple";
            "description"?: string;
        } : T extends typeof PropsType["ITEMS"] ? {
            "items": string;
            "mode"?: "single" | "multiple";
            "description"?: string;
        } : T extends typeof PropsType["TEXT"] ? {
            description?: string;
            minLength?: any;
            maxLength?: any;
        } : T extends typeof PropsType["DATE"] ? {
            description?: string;
            min?: any;
            max?: any;
        } : T extends typeof PropsType["OBJECT"] ? {} : T extends typeof PropsType["BOOLEAN"] ? {} : T extends typeof PropsType["ARRAY"] ? {} : T extends typeof PropsType["FILE"] ? {
            description?: string;
            extension?: string | "pdf" | "png" | "jpg" | "jpeg" | "xml" | "svg" | "json" | "mp4" | "mp3" | "docx" | "xlsx" | "csv";
        } : never;
        required?: boolean;
    };
    type PropsDefinitions<T extends PropsType> = PropsOptions<T> & {
        type: T;
    };
    export function props<T extends PropsType>(type: T, props: PropsOptions<T>): PropsDefinitions<T>;
    export type Meta<T extends Meta<T>> = {
        name: string;
        applications: string[];
        description?: string;
        methods: {
            [M in string]: {
                props?: {
                    [G in keyof T["methods"][M]["props"]]: {
                        [P in keyof T["methods"][M]["props"][G]]: PropsDefinitions<any>;
                    };
                };
                /**
                 * Expecificar as saidas da extensões
                 */
                returns?: {
                    [p in keyof T["methods"][M]["returns"]]: PropsDefinitions<any>;
                };
            };
        };
        /**
         * Expecificar as dependencias necessaria para o processamento das extensões
         */
        dependencies?: string[];
        /**
         * True - Indica que o processo deve ser mantido mesmo depois de resolver a solicitação
         */
        keepAlive?: boolean;
        /**
         * True - Indica que deve ser iniciado junto com o sistema
         */
        onStarts?: boolean;
        /**
         * True - Indica que cada solicitação deve ter seu processo separado
         */
        isolated?: boolean;
    };
    export function meta<T extends Meta<T>>(t: T): T & Meta<T>;
    export type OptionsMeta<ExtMeta extends Meta<ExtMeta>, M extends keyof ExtMeta["methods"]> = {
        [G in keyof ExtMeta["methods"][M]["props"]]: {
            [P in keyof ExtMeta["methods"][M]["props"][G]]: ExtMeta["methods"][M]["props"][G][P];
        };
    };
    export type MetaContext<ExtMeta extends Meta<ExtMeta>, M extends keyof ExtMeta["methods"]> = {
        session: SnapshotSession;
        trigger: {
            application: string;
            method: string;
        };
        branch: {
            branch_uid: string;
            branch_name: string;
            branch_mail: string;
            branch_manager: string;
            branch_nif: string;
        };
        options: OptionsMeta<ExtMeta, M>;
    };
    export type CheckResult = {
        result: boolean;
        message?: string;
        response?: any;
    };
    export type ProcessResult<T extends Meta<T>, M extends keyof T["methods"]> = {
        result: boolean;
        message?: string;
        returns: {
            [P in keyof T["methods"][M]["returns"]]: T["methods"][M]["returns"][P]["type"] extends PropsType.TEXT ? string : T["methods"][M]["returns"][P]["type"] extends PropsType.NUMBER ? number : T["methods"][M]["returns"][P]["type"] extends PropsType.BOOLEAN ? boolean : T["methods"][M]["returns"][P]["type"] extends PropsType.DATE ? Date : T["methods"][M]["returns"][P]["type"] extends PropsType.OBJECT ? {
                [p: string]: any;
            } : T["methods"][M]["returns"][P]["type"] extends PropsType.LIST ? any[] : T["methods"][M]["returns"][P]["type"] extends PropsType.OPTIONS ? any[] : T["methods"][M]["returns"][P]["type"] extends PropsType.FILE ? {
                filename: string;
                extension: string;
                oldFileName: string;
                reference: string;
                location: string;
            } : any;
        };
    };
    export type ExtensionHandlers<T extends Meta<T>, H extends {
        [K in keyof T["methods"]]: (context: MetaContext<T, K>) => ReturnType<H[K]>;
    }> = H;
    export function extension<T extends Meta<T>, H extends {
        [M in keyof T["methods"]]: (context: MetaContext<T, M>) => ReturnType<H[M]>;
    }>(meta: T, handler: ExtensionHandlers<T, H>): ExtensionHandlers<T, H>;
    export interface ExtensionIntegration {
        extensionUnavailable(extension: string): void;
    }
    export {};
}
export = extension;
//# sourceMappingURL=index.d.ts.map