"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const kitres_1 = require("kitres");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const worker_1 = require("kitres/src/core/util/worker");
const index_1 = __importDefault(require("./index"));
process.on("uncaughtExceptionMonitor", error => {
    console.error("uncaughtExceptionMonitor");
    console.error(error);
});
process.on("uncaughtException", error => {
    console.error("uncaughtException");
    console.error(error);
});
process.on("unhandledRejection", error => {
    console.error("unhandledRejection");
    console.error(error);
});
function main(dotEnv) {
    const service = new worker_1.WorkerService();
    console.log(index_1.default.manifest.name, "starting server...");
    console.log(index_1.default.manifest.name, "Defining env");
    let hide = kitres_1.ShowEnv.hidePassword(dotEnv);
    kitres_1.ShowEnv.show(hide, require("../../server/context/folders").Folders);
    index_1.default.context.define(dotEnv);
    let extensionMain = path_1.default.join(dotEnv.extension.home, dotEnv.extension.name);
    if (!fs_1.default.existsSync(extensionMain)) {
        service.main().notify("extensionUnavailable", dotEnv.extension.name);
        return;
    }
    let extensionModule = require(extensionMain);
    Object.entries(extensionModule.Extension).forEach(([method, value]) => {
        // @ts-ignore
        service.implement(method, (args) => {
            return Promise.resolve(extensionModule.Extension[method](args));
        });
    });
}
exports.main = main;
//# sourceMappingURL=extension.js.map