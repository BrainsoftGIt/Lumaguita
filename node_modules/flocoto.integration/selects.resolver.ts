import e, {Router} from "express";
import selects, {SelectsResource} from "./selects";
import {hasSession, HasSession} from "./auth";
import axios, {AxiosResponse} from "axios";
import fs from "fs";
import ini from "ini";
import {BaseEventEmitter, db, Result} from "kitres";
import Path from "path";

namespace selects_res {

    type ResolvedSelect = {
        result: boolean,
        resolved?:selects.SelectItem[]
        message?:string,
        hint?:any
        status?:number
    }

    function transformObject( object:any, transformer:selects.Transformable):selects.SelectItem{
        return {
            value: object[ transformer.propsValue ],
            label: object[ transformer.propsLabel ],
        }
    }

    function extractItem( object:any, ...path:(string|number) []):any {
        while ( path.length ) {
            if( !object ) return null;
            object = object[ path.length ];
        }
        return object;
    }

    function extract(object:any, extractor?:selects.Extractable, transformer?:selects.Transformable):selects.SelectItem[] {
        if( !!extractor && extractor.rootPath ) object = extractItem( object, ... extractor.rootPath );
        if( Array.isArray( object ) ){
            return object.map( value => {
                let extracted = value;
                if( !!extractor && extractor.itemPath && !!value && typeof value === "object" ) extracted = extractItem( value, ...extractor.itemPath );
                return transformObject( extracted, transformer );
            });
        } else {
            return Object.entries( object ).map( ( [key, value ]) => {
                let label:string = value as any;
                if( !!extractor && extractor.itemPath && !!value && typeof value === "object" ) label = extractItem( value, ...extractor.itemPath );
                return { value: key, label: label }
            })
        }
    }

    function filter( req:e.Request, filterable:selects.Filterable, session:HasSession){
        return  new Promise<{ result:boolean, filters?:{[p:string]:any}, message?:string, hint?:any, status?:number}>( resolve => {

            let _where = {};
            let missingRequired = Object.entries( filterable.filtersBody || {} ).map( ([key, value]) => {
                if( !req.body[ key ] && value.required )  return {
                    property: key,
                    ...value
                };
            }).filter( value => !!value);

            if( missingRequired.length ){
                return resolve({
                    result: false,
                    message: `Bad request: Missing property ${ missingRequired.map( value => value.property ) }`,
                    status: 400
                });
            }

            if( filterable.filterSession.includes( "__branch_auth" ) ) _where["__branch_auth" ] = session.current().__branch_auth;
            if( filterable.filterSession.includes( "__user_auth" ) ) _where["__user_auth" ] = session.current().__user_auth;
            if( filterable.filterSession.includes( "__espaco_auth" ) ) _where["__espaco_auth" ] = session.current().__espaco_auth;

            if( filterable.filtersBody ) {
                Object.entries( filterable.filtersBody ).forEach( ( [key, value ]) => {
                    _where[ key ] = req.body
                });
            }
            Object.entries( filterable.filtersBody ||{} ).forEach( ( [key, value ]) => {
                if( req.body[ key ] ) _where[ key ] = req.body
            });

            let waitFilter = Promise.resolve( {});
            if( filterable.filters ){
                let _filter = filterable.filters;
                if( typeof _filter === "function" ) _filter = _filter( req, session );
                waitFilter = Promise.resolve( _filter );
            }

            waitFilter.then( value => {
                Object.assign( _where, value ||{} );
            }).then( value => {
                return  resolve({
                    result: true,
                    filters: _where
                })
            });
        });
    }

    const rawTransformation :{[p in selects.DocumentSource["documentType"]]:(raw:string, extractor?:selects.Extractable, transformer?:selects.Transformable)=>selects.SelectItem[]} = {
        ["text/json"]( raw:string, _extract, transform ){
            let document = JSON.parse( raw );
            return extract( document, _extract, transform  )
        }, ["text/ini"](raw:string, _extract, transform){
            let document = ini.parse( raw );
            return extract( document, _extract, transform );
        }, ["text/xml"](raw:string, extract, transform){
            return []
        }
    }

    function axiosResolver<T extends db.CatalogOf<T>>(resolver:selects.RESTRoutRes & { routeName:string}, promise:Promise<AxiosResponse>, req: e.Request, type:"API"|"REDIRECT", session:HasSession, instance:SelectsResourcesManager<T>){
        return new Promise<ResolvedSelect>( (resolve) => {
            const _filter = filter( req, resolver, session )
            promise.then( value => {
                if( value.status !== resolver.resolvedStatus ) {
                    return resolve({
                        result: false,
                        message: `Internal server error: ${type} externa retornou um status nÃ£o espareado Status = ${ value.status } Expected = ${ resolver.resolvedStatus }!`,
                    })
                }

                if( resolver.returnType === "object" && (!value.data || typeof value.data !== "object" ) ){
                    return resolve({
                        result: false,
                        message: `Internal server error: Invalid object response for ${type} named ${resolver.routeName}!`,
                    })
                } else if( [ "text/json", "text/ini", "text/xml"].includes( resolver.returnType ) &&  ( !value.data || typeof value.data !== "string") ){
                    return resolve({
                        result: false,
                        message: `Internal server error: Invalid text response for ${type} named ${resolver.routeName}!`,
                    })
                }

                let object:any;

                if( resolver.returnType === "object" ) object = value.data;
                else object = rawTransformation[ resolver.returnType ]( value.data, resolver, resolver );

                if( !object ){
                    return resolve({
                        result: false,
                        message: `Internal server error: UnResolved response raw data for ${type} named ${resolver.routeName}!`,
                    })
                }

                let resolved = extract( object, resolver, resolver );
                if( !resolved ) {
                    return resolve({
                        result: false,
                        message: `Internal server error: Unresolved extraction for ${type} named ${resolver.routeName}!`,
                        status: 500
                    })
                }

                return resolve({
                    result: true,
                    message: `success`,
                    resolved: resolved
                });

            }).catch( (error) => {
                instance.notify("error", error );
                return resolve({
                    result: false,
                    message: `Internal server error: Error ao comunicar para obter a elementos para select usando ${type} named ${resolver.routeName}!`,
                    hint: error.message
                });
            })
        })
    }


    type DynamicsResolvers<T extends db.CatalogOf<T>> = {
        [p in selects.SelectsResource["sourceType"]]: (resolver:selects.SelectsResource[`${p}Source`] & {
            routeName:string
        }, req:e.Request, session:HasSession, instance:SelectsResourcesManager<T> )=>ResolvedSelect|Promise<ResolvedSelect>
    };

    function createResolver<T extends db.CatalogOf<T>>(){
        const dynamicsResolvers:DynamicsResolvers<T> = {
            fixed( resolver, req){
                if( Array.isArray( resolver ) ) {
                    return {
                        result: true,
                        resolved: resolver
                    };
                }
                else if( typeof resolver === "object" ){
                    return {
                        result: true,
                        resolved: Object.entries( resolver.fixedSource ).map( ([key, value]) => ({
                            value: key, label: value
                        }))
                    }
                }
            }, document( resolver, req){
                if( !fs.existsSync( resolver.filename )){
                    return {
                        result: false,
                        message: `File for document resource ${resolver.resource} not found!`,
                        status: 404,
                    }
                }

                let raw = fs.readFileSync( resolver.filename ).toString();

                let resultList = rawTransformation[ resolver.documentType ]( raw, resolver, resolver );
                if( !resultList ){
                    return  {
                        result: false,
                        message: `Cannot extract or tranform value form document ${resolver.resource}: Bad configuration!`,
                        status: 500
                    }
                }

                return {
                    result: true,
                    resolved: resultList
                }

            }, database ( resolver, req, session, instance ) {
                return new Promise( resolve => {
                    filter( req, resolver, session ).then( _where => {
                        if( !_where.result ){
                            return resolve({
                                result: false,
                                message: _where.message,
                                status: _where.status,
                                hint: _where["hint"]
                            })
                        }

                        console.log( resolver )

                        let promise: Promise<{error?: Error, returns: any[], response: Result<any, any>}>;
                        if( resolver.sourceType === "relation" ){
                            promise = instance.connection( req ).relation()[ resolver.schema ] [ resolver.object ].select( "*" ).filter( _where.filters )


                        } else if( resolver.sourceType === "function" ){
                            promise = instance.connection( req ).call[ resolver.schema ][ resolver.object ]( _where.filters || {})
                        }
                        promise.then( value => {
                            if( value.error ){
                                resolve({
                                    result: false,
                                    message: `Internal server error: Erro ao obter a listagem de item para select!`,
                                    hint: value.error.message
                                })
                                instance.notify( "error", value.error );
                                return
                            }
                            let items = extract( value.returns, resolver, resolver );

                            if( !items ){
                                return resolve({
                                    result: false,
                                    message: `Internal server error: Unresolved extraction for database result named ${resolver.routeName}!`,
                                    status: 500
                                })
                            }
                            resolve({
                                result: true,
                                resolved: items
                            })
                        });

                    });
                })

            }, api( resolver, req, session, instance){
                return filter( req, resolver, session ).then( filter => {
                    let request = axios.request({
                        method: resolver.method,
                        data: filter.filters,
                        url: resolver.url,
                        proxy: resolver.proxy
                    });
                    return axiosResolver(resolver, request, req, "API", session, instance )
                        .catch( reason => {
                            instance.notify( "error", reason );
                            return { result: false, message: `Error nÃ£o esparadao`, hint: reason.message };
                        })
                }).catch( reason => {
                    instance.notify( "error", reason );
                    return { result: false, message: `Error nÃ£o esparadao`, hint: reason.message };
                })
            }, redirect ( resolver, req, session, instance ) {
                return filter( req, resolver, session ).then( filter => {
                    let request = axios.request({
                        method: req.method,
                        data: filter.filters,
                        url: req.headers.origin + req.originalUrl,
                        proxy: resolver.proxy,
                        headers: {
                            cookie: req.headers.cookie,
                        }
                    });
                    return axiosResolver(resolver, request, req, "API", session, instance).catch( reason => {
                        instance.notify( "error", reason );
                        return { result: false, message: `Error nÃ£o esparadao`, hint: reason.message };
                    })
                }).catch( reason => {
                    instance.notify( "error", reason );
                    return { result: false, message: `Error nÃ£o esparadao`, hint: reason.message };
                })
            }
        }
        return dynamicsResolvers;
    }


    interface SelectResolverEvents {
        error( error:Error ):void
    }

    export type DefineOptions = {
        [p:string]:SelectsResource
    }

    export type SelectsResourcesManagerOptions = {
        resourceFolder:string
    }
    export class SelectsResourcesManager<T extends db.CatalogOf<T>> extends BaseEventEmitter<SelectResolverEvents>{
        private readonly _resolver:e.Router;
        private _connectionFactory:(req:e.Request)=>db.OIDPrivateAccess<T>;
        private readonly _container:{[p:string]:selects.SelectsResource};
        private resourceFolder:string;
        private dynamicResolver:DynamicsResolvers<T>

        attachConnectionFactory(connectionFactory:(req:e.Request)=>db.OIDPrivateAccess<any>){
            this._connectionFactory = connectionFactory;
        }

        constructor( opts:SelectsResourcesManagerOptions ) {
            super();
            this.dynamicResolver = createResolver()
            this.resourceFolder = opts?.resourceFolder;
            this._container = {};
            this._resolver = Router();
            this._resolver.get( "/", (req, res) => {
                let session = hasSession(req, res );
                if( !session ) return;


                let selectsList = Object.entries( this._container ).map( ([ key, value ]) => ({
                    ...this._container[key],
                    url: `${ req.path }/${key}`
                }));

                return res.json({
                    result: true,
                    selects: selectsList
                })
            });

            this._resolver.use( "/:resolve", (req, res) => {
                let session = hasSession(req );
                let resolver = this._container[ req.params.resolve ];
                if( !resolver ) return res.status(404 ).json({
                    result: false,
                    message: "Resource not found!"
                });

                let requiredSession = !resolver.noSession;

                if( !session && requiredSession ) return res.status( 401 ).json({
                    result: false,
                    message: "access dined!"
                });

                if( !resolver.sourceType) return res.status( 500 ).json({
                    result: false,
                    message: `Internal server error: resolver.sourceType is not defined to select "${ req.params.resolve }"!`
                });

                if( !resolver[`${resolver.sourceType}Source`] ) return res.status( 500 ).json({
                    result: false,
                    message: `Internal server error: ${resolver.sourceType}Source not defined to sourceType === "${resolver.sourceType}" in select "${ req.params.resolve }"!`
                });

                if( resolver.sourceType === "database" ){
                    resolver.databaseSource.filterSession = resolver.databaseSource.filterSession||[];
                }

                if( !session && resolver.databaseSource.filterSession.length ) return res.status( 401 ).json({
                    result: false,
                    message: "access dined!"
                });

                Promise.resolve( this.dynamicResolver[ resolver.sourceType ]( resolver[`${resolver.sourceType}Source`] as any, req, session, this ) ).then( result => {
                    if( result.status ) res.status( result.status );
                    return res.json( result );
                });
            });
        }

        connection( req:e.Request ):db.OIDPrivateAccess<T>{
            return this._connectionFactory( req );
        }

        get containers() {
            return this._container;
        }

        get resolver() {
            return this._resolver;
        }


        define(  opts:DefineOptions){
            Object.entries( opts ).forEach( ([key, value]) => {
                this._container[ key ] = value;
                if( value.sourceType === "document" ) {
                    value.documentSource.resource = Path.relative( this.resourceFolder, value.documentSource.filename );
                }
            });
            Object.assign(this._container, opts||{} );
        }
    }
}

export =selects_res;

