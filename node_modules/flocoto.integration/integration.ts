import {AuthBranch, AuthGrants, AuthInfo, AuthRole, AuthUserInfo, Viewport} from "./data";
import e, {Router} from "express";
import axios, {AxiosProxyConfig, AxiosRequestConfig, AxiosResponse} from "axios";
import {Cookie} from "express-session";
import {IncomingHttpHeaders} from "http";
import Path from "path";
import info, {manifestInfo} from "./info"
import {collectResources, MenuResource, Resource} from "./res";
import {FlocotoManifestInfo} from "./application";
import {io, Socket} from "socket.io-client";
import {DisconnectDescription} from "socket.io-client/build/esm-debug/socket";
import selects from "./selects";
import selects_res from "./selects.resolver";
import {
    BaseEventEmitter,
    CallableFunctionOnly,
    db,
    errorUtil,
    Listener,
    RevisionCore,
    RevisionPatch
} from "kitres";
import {RequiredRegistryOptions} from "kitres/src/core/database/revision";
import {nanoid} from "nanoid";
import {integrationManifest} from "./manifest";


namespace __integration {
    export interface FlocotoApplication {
        name:string,
        host:string,
        port:number,
        protocol:"http"|"https",
        viewports:Viewport[]
    }

    export enum IntegrateEvents  {
        INTEGRATE_CONNECT= "IntegrateEvents.INTEGRATE_CONNECT",
        INTEGRATE_READY= "IntegrateEvents.INTEGRATE_READY",
    }

    export interface ReadyOptions {
        application:string
        readyCheck:string
    }


    export type PublicInfo = {
        readonly cookie?:Cookie,
        readonly viewport?:string,
        readonly useSession?:string,
        readonly flocoto?: string,
        readonly headers?: IncomingHttpHeaders
        readonly cookieId?:string,
        readonly sessionID?:string,
        readonly flocotoApps?: FlocotoApplication[],
    }

    export type AuthOptions ={
        identifier: string, //id | nif | email
        user: string, //VALUE_OF_AUTH_NAME
        method: string, //senha | pin
        secret: string,
        viewport: string,
        grants: number[],
        grantsCheck:"all"|"any"|"none"
        mode: string
        extras?:any
    }

    export interface AuthSession {
        auth: AuthInfo,
        userInfo: AuthUserInfo,
        branchInfo: AuthBranch,
        grantsInfo: AuthGrants[],
        rolesInfo: AuthRole[],
        extras?:any
    }

    export type ConnectAuthOptions = {
        viewport:string,
        session:string
    }

    export type ConnectAuthReturn = {
        redirect?:string,
        shareForAll?:{
            [props:string]:any
        },
        shareForSession?: {
            [session:string]:{
                [props:string]:any
            }
        }
    }
    export type ConnectAuthResponse = ConnectAuthReturn &{
        reject?:boolean
    }

    export type ConnectOptions = {

    }

    export type ConnectResponse = {
        shareForAll?:{
            [props:string]:any
        },
        shareForSession?: {
            [session:string]:{
                [props:string]:any
            }
        }
        unShare?:string[]
    }

    export function onInternalResponse< T >( response:AxiosResponse<T,any>, onResponse:( error?:Error, data?:T)=>void){
        if( response.data?.["error"] ) return  onResponse( errorUtil.parse( response.data?.["error"]) );
        else return onResponse( null, response.data?.["response"]);
    }


    function internalRespond< T >( res:e.Response, error?:Error, response?:any, code?:any){
        if( error ){
            return res.json({
                error: errorUtil.serialize( error )
            })
        }

        Promise.resolve( response )
            .then( response => {
                return res.json({
                    response: response
                })
            })
            .catch( reason => {
                return res.json({
                    error: errorUtil.serialize( reason )
                })
            })
    }


    export interface IntegrationApplicationOptions {
        host?:string,
        port?:number,
        protocol?:"http"|"https"
        namespace:string
        integrateSchema:string
        active:boolean
        manifestFile:string
    }

    export type DatabaseSharedResourceRevisions = {
        query: string,
        filename:string,
        options: RequiredRegistryOptions<any>
    }

    export type InternalIntegrationOptions = {
        responseEvent?:string
        readyCheck?:string
        dbResources?:DatabaseSharedResourceRevisions[]
    }

    export interface ReadyResponse {
        revisions: RevisionPatch<any>[]
    }


    interface InternalEvent {
        auth( opts:ConnectAuthOptions, newSession:AuthSession ):ConnectAuthReturn
        connected( opts:ConnectOptions ):ConnectAuthReturn
    }

    interface APIQueryOptions {
        session?:string,
        axios?:AxiosRequestConfig
    }

    export enum ApplicationLocation {
        Local="ApplicationLocation.Local",
        Remote="ApplicationLocation.Remote"
    }

    export type FlocotoAuthOptions = {
        ready:boolean
        host?:string
        application?: string
        namespace?:string
        locationCheck?:string
        location:ApplicationLocation
        protocol:"http"|"https",
        resource:string|Resource[],
        resourceSelects:{ [p: string]: selects.SelectsResource },
        resourceRecursive:boolean
        integrateSchema?:string
        libdomSchema?:string
        manifestFile?:string
        integrationVersion?:string
        active:boolean
        port:number,
    }



    interface IntegrationEvents {
        initialized( error?:Error, block?:  RevisionPatch<any>[]):void
        connected( ):void
        connectionError(error:Error ):void
        connectionEnd(error:Socket.DisconnectReason, description: DisconnectDescription ):void
    }

    class Integration<C extends db.CatalogOf<C>, Q extends CallableFunctionOnly<Q>> extends BaseEventEmitter<IntegrationEvents>{
        private readonly _BaseRoute:e.Router;
        private readonly _InternalRoute:e.Router;
        private readonly _QueryRoute:e.Router;
        private readonly options:IntegrationApplicationOptions;
        private readonly __on_query:(( queryOptions:APIQueryOptions, req:e.Request, res:e.Response, next:()=>void )=>void)[]
        private _agentProxy: false | AxiosProxyConfig;
        private readonly _manifest:FlocotoManifestInfo
        private internalStake:Listener<InternalEvent>;
        private queryStack:Listener<Q>
        private readonly revision:RevisionCore<any>;
        private readyCheck: string;
        private _authOptions: __integration.FlocotoAuthOptions;
        private _ready: boolean;

        private _socket:Socket;
        private _connection_auth:boolean;



        constructor( opts:IntegrationApplicationOptions, revision:RevisionCore<any> ) {
            super();
            this.revision = revision;
            this._BaseRoute = Router({ });
            this._InternalRoute = Router({ });
            this._QueryRoute = Router({ });
            this.internalStake = new Listener();
            this.queryStack = new Listener();

            this.listen()
            this._BaseRoute.use( "/internal", this._InternalRoute );
            this._BaseRoute.use( "/query", this._QueryRoute );
            this._agentProxy = axios.defaults.proxy;


            if( !opts || !opts?.namespace ){
                throw new Error( `Integration namespace is required!`)
            }

            if( info.isFlocotoModule ){
                opts.host = info.flocotoInfo.masterInfo.host
                opts.port = info.flocotoInfo.masterInfo.port
                opts.protocol = info.flocotoInfo.masterInfo.protocol
                opts.manifestFile = info.flocotoInfo.manifestFile
                this._manifest = info.flocotoInfo.manifest
            }

            opts.integrateSchema = opts.integrateSchema || "flocoto";

            this.options = {
                ...opts,
                host: opts.host || "127.0.0.1",
                protocol: opts.protocol || "http",
                namespace: opts.namespace || "/internal",
                integrateSchema: opts.integrateSchema || "flocoto",
            };

            if( !this._manifest ) {
                this._manifest = manifestInfo(this.options.manifestFile ).manifest;
            }
        }

        get implement():typeof this.internalStake.on {
            return (...props)=>{
                return this.internalStake.on( ...props );
            };
        }

        get respond(): typeof this.queryStack.on {
            return ( ...props) =>{
                return this.queryStack.on( ...props );
            }
        }

        setAgentProxy( proxy:false | AxiosProxyConfig ){
            this._agentProxy = proxy;
        }

        private listen(){
            this._InternalRoute.get( "/status", (req, res) => {
                res.json( "INTERNAL /status OK" );

            })

            this._InternalRoute.get( "check-status", (req, res) => {
                res.json( "INTERNAL check-status OK" );
            });

            let connect = ( req:e.Request, respond:( error?:Error, response?:ConnectAuthResponse)=>void)=>{
                let  sessionSets = req.body.sessionSets;
                let  connectOptions:ConnectOptions = req.body.connectOptions;

                Object.assign( req.session, sessionSets );
                this.internalStake.notifyStake( "connected", ( value)=>{
                    let response = value.response;
                    if( !value.iterates.length ){
                        response = {
                        }
                    }

                    req.session.save( err => {
                        if( err ) console.error( err );
                        respond( null, response )
                    });
                }, connectOptions );
            }

            let auth = ( req:e.Request, respond:( error?:Error, response?:ConnectAuthResponse )=>void )=>{
                let  sessionSets = req.body.sessionSets;
                let  authOptions:ConnectAuthOptions = req.body.authOptions;
                let  newAuthSession:AuthSession = req.body.newAuthSession;
                Object.assign( req.session, sessionSets );

                this.internalStake.notifyStake("auth",  ( value )=>{
                    let response: ConnectAuthResponse = value.response;
                    if( value.resolve === "rejected" || value.error ){
                        delete req.session.flocotoAuth[ authOptions.session ];
                        response = {
                            reject: true
                        }
                    }

                    if( !value.iterates.length ){
                        response = {

                        }
                    }

                    req.session.save( (err)=>{
                        if( err ) console.error( err );
                        respond( value.error, response );
                    });
                }, authOptions, newAuthSession )
            }

            this._InternalRoute.post("/connect", (req, res, next)=>{
                connect( req, (error, response) => {
                    internalRespond( res, error, response );
                });
            });

            this._InternalRoute.post( "/auth", ( req, res, next)=>{
                auth( req, (error, authResponse) => {
                    if( error ) return internalRespond(res, error, null, "auth:Error");
                    connect( req, (error, connectResponse) => {
                        if( error ) return internalRespond(res, error, null, "connect:error");
                        Promise.all( [ authResponse, connectResponse ])
                            .then( resolved => {
                                let [ authResponse, connectResponse ] = resolved;
                                internalRespond( res, null, {
                                    auth: authResponse,
                                    connect: connectResponse
                                })
                            }).catch( reason => {
                            internalRespond( res, reason, null, "promise.all:catch" );
                        })
                    });
                })
            })

            this._QueryRoute.use( ( req, res)=>{
                let cursor = 0;
                let options = req.body.options;
                req.body = req.body.data;

                let _next = ()=>{
                    let handler = this.__on_query[ cursor++ ];
                    if( typeof handler !== "function" && cursor === this.__on_query.length ) return null;
                    else if ( typeof handler !== "function" ) return _next();
                    handler( options, req, res, _next )
                    return  handler;
                }

                let _handler = _next();
                if( !_handler ) res.status( 404 )
                    .json( {
                        result:false,
                        message: `Query processor not found`
                    });
            });
        }

        attacheSelect( select:selects_res.SelectsResourcesManager<C> ){
            this._BaseRoute.use( "/select", select.resolver );
        }


        get connection(){
            return this._socket;
        }

        referer( viewport:string ){
            return Path.posix.join("/flocoto", this._manifest.name, viewport||"default" )

        }

        integrate(){
            return this._BaseRoute;
        }


        onQuery( url:string, ...handlers:(typeof this.__on_query[number])[]){
            this._QueryRoute.post( url, ...handlers as any )
        }

        query<T>( application:string, path:string, opts:APIQueryOptions, data?:any, resolver?:(error:Error, response:T)=>void)
        query<T>( application:string, path:string, opts:APIQueryOptions, data?:any ):Promise<{error:Error, response:T}>
        query<T>( application:string, path:string, opts:APIQueryOptions, data?:any, resolver?:(error:Error, response:T)=>void):void|Promise<{error:Error, response:T}>{
            let _resolver = ( resolve:( error:Error, response:T)=>void)=>{
                if (!opts) opts = {};
                let axiosConfigs = opts.axios;
                if( opts.axios ) delete opts.axios;
                axios.post( Path.posix.join( this.origin, "flocoto", application, opts?.session || "default", path),   {
                    options: opts,
                    data: data || {},
                }, Object.assign({
                    ...(axiosConfigs || {}),
                    proxy: this._agentProxy
                })  ).then( value => {
                    if( value.status !== 200 ) return resolve( new Error( `Invalid query status response!`), null );
                    resolve( null, value.data );
                }).catch( reason => {
                    console.error( reason );
                    resolve( reason, null );
                });
            }

            if( typeof resolver === "function" ) return _resolver( resolver );
            return new Promise( resolve => {
                _resolver( (error, response) => {
                    resolve( { error: error, response: response })
                })
            });
        }

        public useRevision() {
            return this.revision;
        }

        get origin(){
            return `${ this.options.protocol }://${ this.options.host }:${ this.options.port }`;
        }


        private auth( opts:FlocotoAuthOptions ){
            return new Promise( (resolve, reject ) => {
                let connect = ( retry:number, error?:Error )=>{
                    if( retry === 0 ) return resolve( error );

                    this._socket = io( `http://127.0.0.1:8889/flocoto`, {
                        auth: ( cb )=>{
                            return cb( opts )
                        }
                    });

                    this._socket.on( "connect", ( )=>{
                        this._connection_auth = true;
                        this.notify( "connected" );
                    });

                    this._socket.on( "connect_error", (error)=>{
                        if( error[`FLOCOTO_AUTH`] ) reject( error )
                        this.notify("connectionError", error );
                    });

                    this._socket.on( "disconnect", (reason, description) => {
                        this.notify("connectionEnd", reason, description );
                    });

                    this._socket.on( IntegrateEvents.INTEGRATE_CONNECT, ( integrateResponse) =>{
                        this.integrateResource( integrateResponse  )
                    })

                }
                connect( 15 );
            })
        }



        connect(auth:FlocotoAuthOptions, resolve:(error?:Error, response?:ReadyResponse)=>void ):void
        connect(auth:FlocotoAuthOptions ):Promise<{
            error?:Error,
            response:ReadyResponse
        }>
        connect(auth:FlocotoAuthOptions, resolve?:(error?:Error, response?:ReadyResponse)=>void ):Promise<{
            error?:Error,
            response:ReadyResponse
        }>|void{
            this._authOptions = auth;
            let resPromise = new Promise<{error?:Error, resources?:Resource[]}>( resolveResource => {
                if( !auth.resource ) return resolveResource({
                    resources:[]
                });

                if( typeof auth.resource === "object" ){
                    return resolveResource({ resources: auth.resource })
                }

                if( auth.resource ){
                    collectResources( auth.resource, { recursive: auth.resourceRecursive, application: auth.application }, (error1, resource) => {
                        if( error1 ){
                            resolveResource( { error: error1 });
                            return;
                        }

                        resolveResource({ resources: resource.map( (value, index) => {
                                let menu = value as MenuResource;
                                if( menu.classname === "auth.menu" && !!menu.icon && !Path.isAbsolute( menu.icon ) ){
                                    menu.icon = Path.join( Path.dirname( value.source ), menu.icon );
                                }
                                value.application = auth.application;
                                return value;
                            })
                        });

                    })
                }
            })

            let _init=( resolve:( error:Error, response?:ReadyResponse )=>void ) => {
                resPromise.then( value => {
                    if( value.error ){
                        return resolve( value.error );
                    }
                    auth.resource = value.resources;
                    auth.manifestFile = this.options.manifestFile;
                    auth.integrateSchema = this.options.integrateSchema;
                    auth.active = this.options.active;
                    auth.integrationVersion = integrationManifest.version;

                    this.auth( auth ).then( value1 => {
                        this.notify( "connected" );
                    }).catch( reason => {
                        resolve( reason );
                    });

                    this.once( "initialized", ( error, blocks)=>{
                        resolve( error, {
                            revisions: blocks
                        });
                    });
                })
            }

            if( typeof resolve === "function" ) return _init( resolve );
            else return new Promise( resolve1 => {
                return _init( (error, response) => {
                    resolve1( { error:error, response:response });
                });
            });
        }


        private integrateResource( opts:InternalIntegrationOptions) {
            if( !opts.dbResources.length ) return;
            this.readyCheck = opts.readyCheck;
            let revs = this.useRevision();
            opts.dbResources.forEach( (resource) => {
                revs.register( { filename: resource.filename}, resource.options, resource.query, [])
            });

            revs.setup( (error, block) => {
                this._socket.emit( opts.responseEvent, block );
                this.notify( "initialized", error, block );
                if( this._ready ) this.ready();
            });
        }
        ready(){
            this._ready = true;
            let ready:ReadyOptions = {
                application: this._authOptions.application,
                readyCheck: this.readyCheck
            }
            this._socket.emit( IntegrateEvents.INTEGRATE_READY, ready );
        }
    }



    export function integration<C, Q extends CallableFunctionOnly<Q>>( opts:IntegrationApplicationOptions, revision:RevisionCore<C>){
        return new Integration<C,Q>( opts, revision );
    }

    export function getSharedSessionBySession(req:e.Request, session:string ){
        if( !req.session.flocotoShare ) req.session.flocotoShare = {};
        let sharedSession = {};

        Object.entries( req.session.flocotoShare ).forEach(( [ flocoto, value], index) => {
            if( !req.session.flocotoShare[ flocoto ][ session ] ) return;
            Object.assign( sharedSession, req.session.flocotoShare[ flocoto ][ session ]);
        });
        return sharedSession;
    }

    export function getSharedSessionByFlocoto(req:e.Request, application:string ){
        if ( !application ) return null;
        if( !req.session.flocotoShare ) req.session.flocotoShare = {};
        if( !req.session.flocotoShare[application] ) req.session.flocotoShare[application] = {};
        return req.session.flocotoShare[application];
    }
}

export = __integration;