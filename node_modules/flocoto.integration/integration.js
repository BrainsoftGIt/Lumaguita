"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const express_1 = require("express");
const axios_1 = __importDefault(require("axios"));
const path_1 = __importDefault(require("path"));
const info_1 = __importStar(require("./info"));
const res_1 = require("./res");
const socket_io_client_1 = require("socket.io-client");
const kitres_1 = require("kitres");
const manifest_1 = require("./manifest");
var __integration;
(function (__integration) {
    let IntegrateEvents;
    (function (IntegrateEvents) {
        IntegrateEvents["INTEGRATE_CONNECT"] = "IntegrateEvents.INTEGRATE_CONNECT";
        IntegrateEvents["INTEGRATE_READY"] = "IntegrateEvents.INTEGRATE_READY";
    })(IntegrateEvents = __integration.IntegrateEvents || (__integration.IntegrateEvents = {}));
    function onInternalResponse(response, onResponse) {
        var _a, _b, _c;
        if ((_a = response.data) === null || _a === void 0 ? void 0 : _a["error"])
            return onResponse(kitres_1.errorUtil.parse((_b = response.data) === null || _b === void 0 ? void 0 : _b["error"]));
        else
            return onResponse(null, (_c = response.data) === null || _c === void 0 ? void 0 : _c["response"]);
    }
    __integration.onInternalResponse = onInternalResponse;
    function internalRespond(res, error, response, code) {
        if (error) {
            return res.json({
                error: kitres_1.errorUtil.serialize(error)
            });
        }
        Promise.resolve(response)
            .then(response => {
            return res.json({
                response: response
            });
        })
            .catch(reason => {
            return res.json({
                error: kitres_1.errorUtil.serialize(reason)
            });
        });
    }
    let ApplicationLocation;
    (function (ApplicationLocation) {
        ApplicationLocation["Local"] = "ApplicationLocation.Local";
        ApplicationLocation["Remote"] = "ApplicationLocation.Remote";
    })(ApplicationLocation = __integration.ApplicationLocation || (__integration.ApplicationLocation = {}));
    class Integration extends kitres_1.BaseEventEmitter {
        constructor(opts, revision) {
            super();
            this.revision = revision;
            this._BaseRoute = (0, express_1.Router)({});
            this._InternalRoute = (0, express_1.Router)({});
            this._QueryRoute = (0, express_1.Router)({});
            this.internalStake = new kitres_1.Listener();
            this.queryStack = new kitres_1.Listener();
            this.listen();
            this._BaseRoute.use("/internal", this._InternalRoute);
            this._BaseRoute.use("/query", this._QueryRoute);
            this._agentProxy = axios_1.default.defaults.proxy;
            if (!opts || !(opts === null || opts === void 0 ? void 0 : opts.namespace)) {
                throw new Error(`Integration namespace is required!`);
            }
            if (info_1.default.isFlocotoModule) {
                opts.host = info_1.default.flocotoInfo.masterInfo.host;
                opts.port = info_1.default.flocotoInfo.masterInfo.port;
                opts.protocol = info_1.default.flocotoInfo.masterInfo.protocol;
                opts.manifestFile = info_1.default.flocotoInfo.manifestFile;
                this._manifest = info_1.default.flocotoInfo.manifest;
            }
            opts.integrateSchema = opts.integrateSchema || "flocoto";
            this.options = Object.assign(Object.assign({}, opts), { host: opts.host || "127.0.0.1", protocol: opts.protocol || "http", namespace: opts.namespace || "/internal", integrateSchema: opts.integrateSchema || "flocoto" });
            if (!this._manifest) {
                this._manifest = (0, info_1.manifestInfo)(this.options.manifestFile).manifest;
            }
        }
        get implement() {
            return (...props) => {
                return this.internalStake.on(...props);
            };
        }
        get respond() {
            return (...props) => {
                return this.queryStack.on(...props);
            };
        }
        setAgentProxy(proxy) {
            this._agentProxy = proxy;
        }
        listen() {
            this._InternalRoute.get("/status", (req, res) => {
                res.json("INTERNAL /status OK");
            });
            this._InternalRoute.get("check-status", (req, res) => {
                res.json("INTERNAL check-status OK");
            });
            let connect = (req, respond) => {
                let sessionSets = req.body.sessionSets;
                let connectOptions = req.body.connectOptions;
                Object.assign(req.session, sessionSets);
                this.internalStake.notifyStake("connected", (value) => {
                    let response = value.response;
                    if (!value.iterates.length) {
                        response = {};
                    }
                    req.session.save(err => {
                        if (err)
                            console.error(err);
                        respond(null, response);
                    });
                }, connectOptions);
            };
            let auth = (req, respond) => {
                let sessionSets = req.body.sessionSets;
                let authOptions = req.body.authOptions;
                let newAuthSession = req.body.newAuthSession;
                Object.assign(req.session, sessionSets);
                this.internalStake.notifyStake("auth", (value) => {
                    let response = value.response;
                    if (value.resolve === "rejected" || value.error) {
                        delete req.session.flocotoAuth[authOptions.session];
                        response = {
                            reject: true
                        };
                    }
                    if (!value.iterates.length) {
                        response = {};
                    }
                    req.session.save((err) => {
                        if (err)
                            console.error(err);
                        respond(value.error, response);
                    });
                }, authOptions, newAuthSession);
            };
            this._InternalRoute.post("/connect", (req, res, next) => {
                connect(req, (error, response) => {
                    internalRespond(res, error, response);
                });
            });
            this._InternalRoute.post("/auth", (req, res, next) => {
                auth(req, (error, authResponse) => {
                    if (error)
                        return internalRespond(res, error, null, "auth:Error");
                    connect(req, (error, connectResponse) => {
                        if (error)
                            return internalRespond(res, error, null, "connect:error");
                        Promise.all([authResponse, connectResponse])
                            .then(resolved => {
                            let [authResponse, connectResponse] = resolved;
                            internalRespond(res, null, {
                                auth: authResponse,
                                connect: connectResponse
                            });
                        }).catch(reason => {
                            internalRespond(res, reason, null, "promise.all:catch");
                        });
                    });
                });
            });
            this._QueryRoute.use((req, res) => {
                let cursor = 0;
                let options = req.body.options;
                req.body = req.body.data;
                let _next = () => {
                    let handler = this.__on_query[cursor++];
                    if (typeof handler !== "function" && cursor === this.__on_query.length)
                        return null;
                    else if (typeof handler !== "function")
                        return _next();
                    handler(options, req, res, _next);
                    return handler;
                };
                let _handler = _next();
                if (!_handler)
                    res.status(404)
                        .json({
                        result: false,
                        message: `Query processor not found`
                    });
            });
        }
        attacheSelect(select) {
            this._BaseRoute.use("/select", select.resolver);
        }
        get connection() {
            return this._socket;
        }
        referer(viewport) {
            return path_1.default.posix.join("/flocoto", this._manifest.name, viewport || "default");
        }
        integrate() {
            return this._BaseRoute;
        }
        onQuery(url, ...handlers) {
            this._QueryRoute.post(url, ...handlers);
        }
        query(application, path, opts, data, resolver) {
            let _resolver = (resolve) => {
                if (!opts)
                    opts = {};
                let axiosConfigs = opts.axios;
                if (opts.axios)
                    delete opts.axios;
                axios_1.default.post(path_1.default.posix.join(this.origin, "flocoto", application, (opts === null || opts === void 0 ? void 0 : opts.session) || "default", path), {
                    options: opts,
                    data: data || {},
                }, Object.assign(Object.assign(Object.assign({}, (axiosConfigs || {})), { proxy: this._agentProxy }))).then(value => {
                    if (value.status !== 200)
                        return resolve(new Error(`Invalid query status response!`), null);
                    resolve(null, value.data);
                }).catch(reason => {
                    console.error(reason);
                    resolve(reason, null);
                });
            };
            if (typeof resolver === "function")
                return _resolver(resolver);
            return new Promise(resolve => {
                _resolver((error, response) => {
                    resolve({ error: error, response: response });
                });
            });
        }
        useRevision() {
            return this.revision;
        }
        get origin() {
            return `${this.options.protocol}://${this.options.host}:${this.options.port}`;
        }
        auth(opts) {
            return new Promise((resolve, reject) => {
                let connect = (retry, error) => {
                    if (retry === 0)
                        return resolve(error);
                    this._socket = (0, socket_io_client_1.io)(`http://127.0.0.1:8889/flocoto`, {
                        auth: (cb) => {
                            return cb(opts);
                        }
                    });
                    this._socket.on("connect", () => {
                        this._connection_auth = true;
                        this.notify("connected");
                    });
                    this._socket.on("connect_error", (error) => {
                        if (error[`FLOCOTO_AUTH`])
                            reject(error);
                        this.notify("connectionError", error);
                    });
                    this._socket.on("disconnect", (reason, description) => {
                        this.notify("connectionEnd", reason, description);
                    });
                    this._socket.on(IntegrateEvents.INTEGRATE_CONNECT, (integrateResponse) => {
                        this.integrateResource(integrateResponse);
                    });
                };
                connect(15);
            });
        }
        connect(auth, resolve) {
            this._authOptions = auth;
            let resPromise = new Promise(resolveResource => {
                if (!auth.resource)
                    return resolveResource({
                        resources: []
                    });
                if (typeof auth.resource === "object") {
                    return resolveResource({ resources: auth.resource });
                }
                if (auth.resource) {
                    (0, res_1.collectResources)(auth.resource, { recursive: auth.resourceRecursive, application: auth.application }, (error1, resource) => {
                        if (error1) {
                            resolveResource({ error: error1 });
                            return;
                        }
                        resolveResource({ resources: resource.map((value, index) => {
                                let menu = value;
                                if (menu.classname === "auth.menu" && !!menu.icon && !path_1.default.isAbsolute(menu.icon)) {
                                    menu.icon = path_1.default.join(path_1.default.dirname(value.source), menu.icon);
                                }
                                value.application = auth.application;
                                return value;
                            })
                        });
                    });
                }
            });
            let _init = (resolve) => {
                resPromise.then(value => {
                    if (value.error) {
                        return resolve(value.error);
                    }
                    auth.resource = value.resources;
                    auth.manifestFile = this.options.manifestFile;
                    auth.integrateSchema = this.options.integrateSchema;
                    auth.active = this.options.active;
                    auth.integrationVersion = manifest_1.integrationManifest.version;
                    this.auth(auth).then(value1 => {
                        this.notify("connected");
                    }).catch(reason => {
                        resolve(reason);
                    });
                    this.once("initialized", (error, blocks) => {
                        resolve(error, {
                            revisions: blocks
                        });
                    });
                });
            };
            if (typeof resolve === "function")
                return _init(resolve);
            else
                return new Promise(resolve1 => {
                    return _init((error, response) => {
                        resolve1({ error: error, response: response });
                    });
                });
        }
        integrateResource(opts) {
            if (!opts.dbResources.length)
                return;
            this.readyCheck = opts.readyCheck;
            let revs = this.useRevision();
            opts.dbResources.forEach((resource) => {
                revs.register({ filename: resource.filename }, resource.options, resource.query, []);
            });
            revs.setup((error, block) => {
                this._socket.emit(opts.responseEvent, block);
                this.notify("initialized", error, block);
                if (this._ready)
                    this.ready();
            });
        }
        ready() {
            this._ready = true;
            let ready = {
                application: this._authOptions.application,
                readyCheck: this.readyCheck
            };
            this._socket.emit(IntegrateEvents.INTEGRATE_READY, ready);
        }
    }
    function integration(opts, revision) {
        return new Integration(opts, revision);
    }
    __integration.integration = integration;
    function getSharedSessionBySession(req, session) {
        if (!req.session.flocotoShare)
            req.session.flocotoShare = {};
        let sharedSession = {};
        Object.entries(req.session.flocotoShare).forEach(([flocoto, value], index) => {
            if (!req.session.flocotoShare[flocoto][session])
                return;
            Object.assign(sharedSession, req.session.flocotoShare[flocoto][session]);
        });
        return sharedSession;
    }
    __integration.getSharedSessionBySession = getSharedSessionBySession;
    function getSharedSessionByFlocoto(req, application) {
        if (!application)
            return null;
        if (!req.session.flocotoShare)
            req.session.flocotoShare = {};
        if (!req.session.flocotoShare[application])
            req.session.flocotoShare[application] = {};
        return req.session.flocotoShare[application];
    }
    __integration.getSharedSessionByFlocoto = getSharedSessionByFlocoto;
})(__integration || (__integration = {}));
module.exports = __integration;
//# sourceMappingURL=integration.js.map