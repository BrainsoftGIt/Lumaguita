"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var flocoto_auth;
(function (flocoto_auth) {
    function hasSession(req, session, res) {
        if (!session)
            session = "default";
        let _res;
        let _session;
        if (typeof session === "string")
            _session = session;
        else if (typeof res === "string")
            _session = res;
        else
            _session = "default";
        if (!!res && typeof res === "object")
            _res = res;
        else if (!!session && typeof session === "object")
            _res = session;
        let noSession = (message) => {
            console.log(`[kitres]`, message);
            if (!!_res) {
                _res.status(401).json({
                    result: false,
                    message: "Access dined!",
                    category: "Client error",
                    description: "The request has not been applied because it lacks valid authentication credentials for the target resource.",
                    location: "https://httpstatuscodes.org/401/",
                    status_code: 401,
                    title: "Unauthorized"
                });
            }
            return null;
        };
        if (!req.session)
            return noSession(`!req.session`);
        if (!req.session.flocotoAuth)
            return noSession(`!req.session.flocotoAuth`);
        if (!req.session.flocotoAuth[_session])
            return noSession(`!req.session.flocotoAuth[ ${_session} ]`);
        if (!req.session.flocotoAuth[_session].userInfo)
            return noSession(`!req.session.flocotoAuth[ ${_session} ].userInfo`);
        if (!req.session.flocotoAuth[_session].userInfo.user_uid)
            return noSession(`!req.session.flocotoAuth[ ${_session} ].userInfo.user_uid`);
        if (!req.session.flocotoAuth[_session].branchInfo)
            return noSession(`!req.session.flocotoAuth[ ${_session} ].branchInfo`);
        if (!req.session.flocotoAuth[_session].branchInfo.branch_uid)
            return noSession(`!req.session.flocotoAuth[ ${_session} ].branchInfo.branch_uid`);
        if (!req.session.flocotoAuth[_session].grantsInfo)
            return noSession(`!req.session.flocotoAuth[ ${_session} ].grantsInfo`);
        if (!req.session.flocotoAuth[_session].rolesInfo)
            return noSession(`!req.session.flocotoAuth[ ${_session} ].rolesInfo`);
        function into(into) {
            let _a = current(), { into: _into } = _a, props = __rest(_a, ["into"]);
            return Object.assign(into, props);
        }
        function current() {
            if (!req.session.flocotoDefaults)
                req.session.flocotoDefaults = {};
            if (!req.session.flocotoDefaults[_session])
                req.session.flocotoDefaults[_session] = {};
            let useSession = req.session.flocotoAuth[_session];
            let useDefaults = req.session.flocotoDefaults[_session];
            return {
                __auth_uid: useSession.auth.auth_uid,
                __user_auth: useSession.userInfo.user_uid,
                __branch_auth: useSession.branchInfo.branch_uid,
                __espaco_auth: useDefaults === null || useDefaults === void 0 ? void 0 : useDefaults.espaco_uid,
                __cargo_auth: useDefaults === null || useDefaults === void 0 ? void 0 : useDefaults.cargo_uid,
                __trabalha_auth: useDefaults === null || useDefaults === void 0 ? void 0 : useDefaults.trabalha_uid,
                into
            };
        }
        function sets(sets) {
            sets = sets || {};
            if (!req.session.flocotoDefaults)
                req.session.flocotoDefaults = {};
            if (!req.session.flocotoDefaults[_session])
                req.session.flocotoDefaults[_session] = {};
            req.session.flocotoDefaults[_session] = Object.assign(Object.assign({}, req.session.flocotoDefaults[_session]), sets);
            return current();
        }
        function unsets() {
            //@ts-ignore
            delete req.session["flocotoPublic"];
            delete req.session.flocoto;
            delete req.session.flocotoDefaults;
            delete req.session.flocotoShare;
            delete req.session.flocotoAuth;
        }
        function snapshot() {
            return Object.assign(Object.assign(Object.assign({}, req.session.flocotoAuth[_session]), { public: req.session.flocotoPublic, current: current() }));
        }
        function update(sets) {
            if (!req.session.flocotoAuth)
                req.session.flocotoAuth = {};
            if (!req.session.flocotoAuth[_session])
                req.session.flocotoAuth[_session] = {};
            if (!req.session.flocotoAuth[_session].auth)
                req.session.flocotoAuth[_session].auth = {};
            if (!req.session.flocotoAuth[_session].userInfo)
                req.session.flocotoAuth[_session].userInfo = {};
            if (!req.session.flocotoAuth[_session].branchInfo)
                req.session.flocotoAuth[_session].branchInfo = {};
            Object.assign(req.session.flocotoAuth[_session].auth, (sets === null || sets === void 0 ? void 0 : sets.auth) || {});
            Object.assign(req.session.flocotoAuth[_session].userInfo, (sets === null || sets === void 0 ? void 0 : sets.userInfo) || {});
            Object.assign(req.session.flocotoAuth[_session].branchInfo, (sets === null || sets === void 0 ? void 0 : sets.branchInfo) || {});
            req.session.flocotoAuth[_session].rolesInfo = (sets === null || sets === void 0 ? void 0 : sets.rolesInfo) || req.session.flocotoAuth[_session].rolesInfo || [];
            req.session.flocotoAuth[_session].grantsInfo = (sets === null || sets === void 0 ? void 0 : sets.grantsInfo) || req.session.flocotoAuth[_session].grantsInfo || [];
            return hasSession(req, _session, _res);
        }
        return Object.assign(req.session.flocotoAuth[_session], {
            public: req.session.flocotoPublic,
            current,
            sets,
            update,
            unsets,
            snapshot
        });
    }
    flocoto_auth.hasSession = hasSession;
})(flocoto_auth || (flocoto_auth = {}));
module.exports = flocoto_auth;
//# sourceMappingURL=auth.js.map