"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const express_1 = require("express");
const auth_1 = require("./auth");
const axios_1 = __importDefault(require("axios"));
const fs_1 = __importDefault(require("fs"));
const ini_1 = __importDefault(require("ini"));
const kitres_1 = require("kitres");
const path_1 = __importDefault(require("path"));
var selects_res;
(function (selects_res) {
    function transformObject(object, transformer) {
        return {
            value: object[transformer.propsValue],
            label: object[transformer.propsLabel],
        };
    }
    function extractItem(object, ...path) {
        while (path.length) {
            if (!object)
                return null;
            object = object[path.length];
        }
        return object;
    }
    function extract(object, extractor, transformer) {
        if (!!extractor && extractor.rootPath)
            object = extractItem(object, ...extractor.rootPath);
        if (Array.isArray(object)) {
            return object.map(value => {
                let extracted = value;
                if (!!extractor && extractor.itemPath && !!value && typeof value === "object")
                    extracted = extractItem(value, ...extractor.itemPath);
                return transformObject(extracted, transformer);
            });
        }
        else {
            return Object.entries(object).map(([key, value]) => {
                let label = value;
                if (!!extractor && extractor.itemPath && !!value && typeof value === "object")
                    label = extractItem(value, ...extractor.itemPath);
                return { value: key, label: label };
            });
        }
    }
    function filter(req, filterable, session) {
        return new Promise(resolve => {
            let _where = {};
            let missingRequired = Object.entries(filterable.filtersBody || {}).map(([key, value]) => {
                if (!req.body[key] && value.required)
                    return Object.assign({ property: key }, value);
            }).filter(value => !!value);
            if (missingRequired.length) {
                return resolve({
                    result: false,
                    message: `Bad request: Missing property ${missingRequired.map(value => value.property)}`,
                    status: 400
                });
            }
            if (filterable.filterSession.includes("__branch_auth"))
                _where["__branch_auth"] = session.current().__branch_auth;
            if (filterable.filterSession.includes("__user_auth"))
                _where["__user_auth"] = session.current().__user_auth;
            if (filterable.filterSession.includes("__espaco_auth"))
                _where["__espaco_auth"] = session.current().__espaco_auth;
            if (filterable.filtersBody) {
                Object.entries(filterable.filtersBody).forEach(([key, value]) => {
                    _where[key] = req.body;
                });
            }
            Object.entries(filterable.filtersBody || {}).forEach(([key, value]) => {
                if (req.body[key])
                    _where[key] = req.body;
            });
            let waitFilter = Promise.resolve({});
            if (filterable.filters) {
                let _filter = filterable.filters;
                if (typeof _filter === "function")
                    _filter = _filter(req, session);
                waitFilter = Promise.resolve(_filter);
            }
            waitFilter.then(value => {
                Object.assign(_where, value || {});
            }).then(value => {
                return resolve({
                    result: true,
                    filters: _where
                });
            });
        });
    }
    const rawTransformation = {
        ["text/json"](raw, _extract, transform) {
            let document = JSON.parse(raw);
            return extract(document, _extract, transform);
        }, ["text/ini"](raw, _extract, transform) {
            let document = ini_1.default.parse(raw);
            return extract(document, _extract, transform);
        }, ["text/xml"](raw, extract, transform) {
            return [];
        }
    };
    function axiosResolver(resolver, promise, req, type, session, instance) {
        return new Promise((resolve) => {
            const _filter = filter(req, resolver, session);
            promise.then(value => {
                if (value.status !== resolver.resolvedStatus) {
                    return resolve({
                        result: false,
                        message: `Internal server error: ${type} externa retornou um status não espareado Status = ${value.status} Expected = ${resolver.resolvedStatus}!`,
                    });
                }
                if (resolver.returnType === "object" && (!value.data || typeof value.data !== "object")) {
                    return resolve({
                        result: false,
                        message: `Internal server error: Invalid object response for ${type} named ${resolver.routeName}!`,
                    });
                }
                else if (["text/json", "text/ini", "text/xml"].includes(resolver.returnType) && (!value.data || typeof value.data !== "string")) {
                    return resolve({
                        result: false,
                        message: `Internal server error: Invalid text response for ${type} named ${resolver.routeName}!`,
                    });
                }
                let object;
                if (resolver.returnType === "object")
                    object = value.data;
                else
                    object = rawTransformation[resolver.returnType](value.data, resolver, resolver);
                if (!object) {
                    return resolve({
                        result: false,
                        message: `Internal server error: UnResolved response raw data for ${type} named ${resolver.routeName}!`,
                    });
                }
                let resolved = extract(object, resolver, resolver);
                if (!resolved) {
                    return resolve({
                        result: false,
                        message: `Internal server error: Unresolved extraction for ${type} named ${resolver.routeName}!`,
                        status: 500
                    });
                }
                return resolve({
                    result: true,
                    message: `success`,
                    resolved: resolved
                });
            }).catch((error) => {
                instance.notify("error", error);
                return resolve({
                    result: false,
                    message: `Internal server error: Error ao comunicar para obter a elementos para select usando ${type} named ${resolver.routeName}!`,
                    hint: error.message
                });
            });
        });
    }
    function createResolver() {
        const dynamicsResolvers = {
            fixed(resolver, req) {
                if (Array.isArray(resolver)) {
                    return {
                        result: true,
                        resolved: resolver
                    };
                }
                else if (typeof resolver === "object") {
                    return {
                        result: true,
                        resolved: Object.entries(resolver.fixedSource).map(([key, value]) => ({
                            value: key, label: value
                        }))
                    };
                }
            }, document(resolver, req) {
                if (!fs_1.default.existsSync(resolver.filename)) {
                    return {
                        result: false,
                        message: `File for document resource ${resolver.resource} not found!`,
                        status: 404,
                    };
                }
                let raw = fs_1.default.readFileSync(resolver.filename).toString();
                let resultList = rawTransformation[resolver.documentType](raw, resolver, resolver);
                if (!resultList) {
                    return {
                        result: false,
                        message: `Cannot extract or tranform value form document ${resolver.resource}: Bad configuration!`,
                        status: 500
                    };
                }
                return {
                    result: true,
                    resolved: resultList
                };
            }, database(resolver, req, session, instance) {
                return new Promise(resolve => {
                    filter(req, resolver, session).then(_where => {
                        if (!_where.result) {
                            return resolve({
                                result: false,
                                message: _where.message,
                                status: _where.status,
                                hint: _where["hint"]
                            });
                        }
                        console.log(resolver);
                        let promise;
                        if (resolver.sourceType === "relation") {
                            promise = instance.connection(req).relation()[resolver.schema][resolver.object].select("*").filter(_where.filters);
                        }
                        else if (resolver.sourceType === "function") {
                            promise = instance.connection(req).call[resolver.schema][resolver.object](_where.filters || {});
                        }
                        promise.then(value => {
                            if (value.error) {
                                resolve({
                                    result: false,
                                    message: `Internal server error: Erro ao obter a listagem de item para select!`,
                                    hint: value.error.message
                                });
                                instance.notify("error", value.error);
                                return;
                            }
                            let items = extract(value.returns, resolver, resolver);
                            if (!items) {
                                return resolve({
                                    result: false,
                                    message: `Internal server error: Unresolved extraction for database result named ${resolver.routeName}!`,
                                    status: 500
                                });
                            }
                            resolve({
                                result: true,
                                resolved: items
                            });
                        });
                    });
                });
            }, api(resolver, req, session, instance) {
                return filter(req, resolver, session).then(filter => {
                    let request = axios_1.default.request({
                        method: resolver.method,
                        data: filter.filters,
                        url: resolver.url,
                        proxy: resolver.proxy
                    });
                    return axiosResolver(resolver, request, req, "API", session, instance)
                        .catch(reason => {
                        instance.notify("error", reason);
                        return { result: false, message: `Error não esparadao`, hint: reason.message };
                    });
                }).catch(reason => {
                    instance.notify("error", reason);
                    return { result: false, message: `Error não esparadao`, hint: reason.message };
                });
            }, redirect(resolver, req, session, instance) {
                return filter(req, resolver, session).then(filter => {
                    let request = axios_1.default.request({
                        method: req.method,
                        data: filter.filters,
                        url: req.headers.origin + req.originalUrl,
                        proxy: resolver.proxy,
                        headers: {
                            cookie: req.headers.cookie,
                        }
                    });
                    return axiosResolver(resolver, request, req, "API", session, instance).catch(reason => {
                        instance.notify("error", reason);
                        return { result: false, message: `Error não esparadao`, hint: reason.message };
                    });
                }).catch(reason => {
                    instance.notify("error", reason);
                    return { result: false, message: `Error não esparadao`, hint: reason.message };
                });
            }
        };
        return dynamicsResolvers;
    }
    class SelectsResourcesManager extends kitres_1.BaseEventEmitter {
        attachConnectionFactory(connectionFactory) {
            this._connectionFactory = connectionFactory;
        }
        constructor(opts) {
            super();
            this.dynamicResolver = createResolver();
            this.resourceFolder = opts === null || opts === void 0 ? void 0 : opts.resourceFolder;
            this._container = {};
            this._resolver = (0, express_1.Router)();
            this._resolver.get("/", (req, res) => {
                let session = (0, auth_1.hasSession)(req, res);
                if (!session)
                    return;
                let selectsList = Object.entries(this._container).map(([key, value]) => (Object.assign(Object.assign({}, this._container[key]), { url: `${req.path}/${key}` })));
                return res.json({
                    result: true,
                    selects: selectsList
                });
            });
            this._resolver.use("/:resolve", (req, res) => {
                let session = (0, auth_1.hasSession)(req);
                let resolver = this._container[req.params.resolve];
                if (!resolver)
                    return res.status(404).json({
                        result: false,
                        message: "Resource not found!"
                    });
                let requiredSession = !resolver.noSession;
                if (!session && requiredSession)
                    return res.status(401).json({
                        result: false,
                        message: "access dined!"
                    });
                if (!resolver.sourceType)
                    return res.status(500).json({
                        result: false,
                        message: `Internal server error: resolver.sourceType is not defined to select "${req.params.resolve}"!`
                    });
                if (!resolver[`${resolver.sourceType}Source`])
                    return res.status(500).json({
                        result: false,
                        message: `Internal server error: ${resolver.sourceType}Source not defined to sourceType === "${resolver.sourceType}" in select "${req.params.resolve}"!`
                    });
                if (resolver.sourceType === "database") {
                    resolver.databaseSource.filterSession = resolver.databaseSource.filterSession || [];
                }
                if (!session && resolver.databaseSource.filterSession.length)
                    return res.status(401).json({
                        result: false,
                        message: "access dined!"
                    });
                Promise.resolve(this.dynamicResolver[resolver.sourceType](resolver[`${resolver.sourceType}Source`], req, session, this)).then(result => {
                    if (result.status)
                        res.status(result.status);
                    return res.json(result);
                });
            });
        }
        connection(req) {
            return this._connectionFactory(req);
        }
        get containers() {
            return this._container;
        }
        get resolver() {
            return this._resolver;
        }
        define(opts) {
            Object.entries(opts).forEach(([key, value]) => {
                this._container[key] = value;
                if (value.sourceType === "document") {
                    value.documentSource.resource = path_1.default.relative(this.resourceFolder, value.documentSource.filename);
                }
            });
            Object.assign(this._container, opts || {});
        }
    }
    selects_res.SelectsResourcesManager = SelectsResourcesManager;
})(selects_res || (selects_res = {}));
module.exports = selects_res;
//# sourceMappingURL=selects.resolver.js.map