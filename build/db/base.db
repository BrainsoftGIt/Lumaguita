--
-- PostgreSQL database dump
--

-- Dumped from database version 15.3
-- Dumped by pg_dump version 15.3

-- Started on 2023-09-25 14:02:36

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

ALTER TABLE IF EXISTS ONLY tweeks.unit DROP CONSTRAINT IF EXISTS unit_unit_user_id_fkey;
ALTER TABLE IF EXISTS ONLY tweeks.unit DROP CONSTRAINT IF EXISTS unit_unit_espaco_auth_fkey;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS fk_venda_to_venda_docorigin;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS fk_venda_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS fk_venda_to_conta;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS fk_venda_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS fk_venda_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS fk_venda_to_artigo;
ALTER TABLE IF EXISTS ONLY tweeks.transferencia DROP CONSTRAINT IF EXISTS fk_transferencia_to_estaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.transferencia DROP CONSTRAINT IF EXISTS fk_transferencia_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.transferencia DROP CONSTRAINT IF EXISTS fk_transferencia_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS fk_transacao_to_toperacao;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS fk_transacao_to_tmovimento;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS fk_transacao_to_posto;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS fk_transacao_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS fk_transacao_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS fk_transacao_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.trabalha DROP CONSTRAINT IF EXISTS fk_trabalha_to_perfil;
ALTER TABLE IF EXISTS ONLY tweeks.trabalha DROP CONSTRAINT IF EXISTS fk_trabalha_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.trabalha DROP CONSTRAINT IF EXISTS fk_trabalha_to_colaborador_proprietario;
ALTER TABLE IF EXISTS ONLY tweeks.trabalha DROP CONSTRAINT IF EXISTS fk_trabalha_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.trabalha DROP CONSTRAINT IF EXISTS fk_trabalha_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.tipoimposto DROP CONSTRAINT IF EXISTS fk_tipoimposto_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.tipoimposto DROP CONSTRAINT IF EXISTS fk_tipoimposto_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.taxa DROP CONSTRAINT IF EXISTS fk_taxa_to_tipoimposto;
ALTER TABLE IF EXISTS ONLY tweeks.taxa DROP CONSTRAINT IF EXISTS fk_taxa_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.taxa DROP CONSTRAINT IF EXISTS fk_taxa_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.taxa DROP CONSTRAINT IF EXISTS fk_taxa_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.serie DROP CONSTRAINT IF EXISTS fk_serie_to_tserie;
ALTER TABLE IF EXISTS ONLY tweeks.serie DROP CONSTRAINT IF EXISTS fk_serie_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.serie DROP CONSTRAINT IF EXISTS fk_serie_to_autorizacao;
ALTER TABLE IF EXISTS ONLY tweeks.retalho DROP CONSTRAINT IF EXISTS fk_retalho_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.retalho DROP CONSTRAINT IF EXISTS fk_retalho_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.retalho DROP CONSTRAINT IF EXISTS fk_retalho_to_artigo_composto;
ALTER TABLE IF EXISTS ONLY tweeks.retalho DROP CONSTRAINT IF EXISTS fk_retalho_to_artigo_base;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS fk_posto_to_tposto;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS fk_posto_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS fk_posto_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS fk_posto_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.movimento DROP CONSTRAINT IF EXISTS fk_movimento_to_toperacao;
ALTER TABLE IF EXISTS ONLY tweeks.movimento DROP CONSTRAINT IF EXISTS fk_movimento_to_tmovimento;
ALTER TABLE IF EXISTS ONLY tweeks.movimento DROP CONSTRAINT IF EXISTS fk_movimento_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.movimento DROP CONSTRAINT IF EXISTS fk_movimento_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.movimento DROP CONSTRAINT IF EXISTS fk_movimento_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.link DROP CONSTRAINT IF EXISTS fk_link_to_tlink;
ALTER TABLE IF EXISTS ONLY tweeks.link DROP CONSTRAINT IF EXISTS fk_link_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.link DROP CONSTRAINT IF EXISTS fk_link_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.link DROP CONSTRAINT IF EXISTS fk_link_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.lancamento DROP CONSTRAINT IF EXISTS fk_lancamento_to_ttrasacao;
ALTER TABLE IF EXISTS ONLY tweeks.lancamento DROP CONSTRAINT IF EXISTS fk_lancamento_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.lancamento DROP CONSTRAINT IF EXISTS fk_lancamento_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.lancamento DROP CONSTRAINT IF EXISTS fk_lancamento_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.lancamento DROP CONSTRAINT IF EXISTS fk_lancamento_to_cliente;
ALTER TABLE IF EXISTS ONLY tweeks.impostovenda DROP CONSTRAINT IF EXISTS fk_impostovenda_to_venda;
ALTER TABLE IF EXISTS ONLY tweeks.impostovenda DROP CONSTRAINT IF EXISTS fk_impostovenda_to_tipovenda;
ALTER TABLE IF EXISTS ONLY tweeks.impostovenda DROP CONSTRAINT IF EXISTS fk_impostovenda_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.impostovenda DROP CONSTRAINT IF EXISTS fk_impostovenda_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.impostovenda DROP CONSTRAINT IF EXISTS fk_impostovenda_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS fk_imposto_to_tipoimposto;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS fk_imposto_to_taplicar;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS fk_imposto_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS fk_imposto_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS fk_imposto_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS fk_imposto_to_artigo;
ALTER TABLE IF EXISTS ONLY tweeks.guia DROP CONSTRAINT IF EXISTS fk_guia_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.guia DROP CONSTRAINT IF EXISTS fk_guia_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.guia DROP CONSTRAINT IF EXISTS fk_guia_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.fornecedor DROP CONSTRAINT IF EXISTS fk_fornecedor_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.fornecedor DROP CONSTRAINT IF EXISTS fk_fornecedor_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.fornecedor DROP CONSTRAINT IF EXISTS fk_fornecedor_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_toperacao;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_espaco_out;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_espaco_in;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_artigo_out;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS fk_fluxo_to_artigo_in;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS fk_espaco_to_posto_admin;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS fk_espaco_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS fk_espaco_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS fk_espaco_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.entrada DROP CONSTRAINT IF EXISTS fk_entrada_to_espaco_destito;
ALTER TABLE IF EXISTS ONLY tweeks.entrada DROP CONSTRAINT IF EXISTS fk_entrada_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.entrada DROP CONSTRAINT IF EXISTS fk_entrada_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.entrada DROP CONSTRAINT IF EXISTS fk_entrada_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.entrada DROP CONSTRAINT IF EXISTS fk_entrada_to_artigo;
ALTER TABLE IF EXISTS ONLY tweeks.ean DROP CONSTRAINT IF EXISTS fk_ean_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.ean DROP CONSTRAINT IF EXISTS fk_ean_to_artigo;
ALTER TABLE IF EXISTS ONLY tweeks.dispoe DROP CONSTRAINT IF EXISTS fk_dispoe_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.dispoe DROP CONSTRAINT IF EXISTS fk_dispoe_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.dispoe DROP CONSTRAINT IF EXISTS fk_dispoe_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.dispoe DROP CONSTRAINT IF EXISTS fk_dispoe_to_artigo_item;
ALTER TABLE IF EXISTS ONLY tweeks.dispoe DROP CONSTRAINT IF EXISTS fk_dispoe_to_artigo;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_deposito_to_serie;
ALTER TABLE IF EXISTS ONLY tweeks.custoguia DROP CONSTRAINT IF EXISTS fk_custo_to_guia;
ALTER TABLE IF EXISTS ONLY tweeks.custoguia DROP CONSTRAINT IF EXISTS fk_custo_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.custoguia DROP CONSTRAINT IF EXISTS fk_custo_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conto_to_cliente;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_serie;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_posto_fecho;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_posto;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_conta_docorigin;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS fk_conta_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.cliente DROP CONSTRAINT IF EXISTS fk_cliente_to_tdocumento;
ALTER TABLE IF EXISTS ONLY tweeks.classe DROP CONSTRAINT IF EXISTS fk_classe_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.classe DROP CONSTRAINT IF EXISTS fk_classe_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.classe DROP CONSTRAINT IF EXISTS fk_classe_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.cambio DROP CONSTRAINT IF EXISTS fk_cambio_to_currency;
ALTER TABLE IF EXISTS ONLY tweeks.caixa DROP CONSTRAINT IF EXISTS fk_caixa_to_posto;
ALTER TABLE IF EXISTS ONLY tweeks.caixa DROP CONSTRAINT IF EXISTS fk_caixa_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.caixa DROP CONSTRAINT IF EXISTS fk_caixa_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.caixa DROP CONSTRAINT IF EXISTS fk_caixa_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.autorizacao DROP CONSTRAINT IF EXISTS fk_autorizacao_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.artigo DROP CONSTRAINT IF EXISTS fk_artigo_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.artigo DROP CONSTRAINT IF EXISTS fk_artigo_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.artigo DROP CONSTRAINT IF EXISTS fk_artigo_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.artigo DROP CONSTRAINT IF EXISTS fk_artigo_to_artigo;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_amortizacao_to_tpaga;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_amortizacao_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_amortizacao_to_currency;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_amortizacao_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_amortizacao_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS fk_amortizacao_to_caixa;
ALTER TABLE IF EXISTS ONLY tweeks.aloca DROP CONSTRAINT IF EXISTS fk_aloca_to_posto;
ALTER TABLE IF EXISTS ONLY tweeks.aloca DROP CONSTRAINT IF EXISTS fk_aloca_to_espaco_destino;
ALTER TABLE IF EXISTS ONLY tweeks.aloca DROP CONSTRAINT IF EXISTS fk_aloca_to_espaco;
ALTER TABLE IF EXISTS ONLY tweeks.acerto DROP CONSTRAINT IF EXISTS fk_acerto_to_espaco_auth;
ALTER TABLE IF EXISTS ONLY tweeks.acerto DROP CONSTRAINT IF EXISTS fk_acerto_to_colaborador;
ALTER TABLE IF EXISTS ONLY tweeks.classe DROP CONSTRAINT IF EXISTS classe_classe_classe_id_fk;
ALTER TABLE IF EXISTS ONLY report.filter DROP CONSTRAINT IF EXISTS filter_filter_parametrized_uid_fkey;
ALTER TABLE IF EXISTS ONLY patch.revision DROP CONSTRAINT IF EXISTS fk_revision_to_raw;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalblocother DROP CONSTRAINT IF EXISTS fk_regionalblocother_to_regionalbloc;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalblocname DROP CONSTRAINT IF EXISTS fk_regionalblocname_to_regionalbloc;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytranslation DROP CONSTRAINT IF EXISTS fk_countrytranslation_to_language;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytranslation DROP CONSTRAINT IF EXISTS fk_countrytranslation_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytopleveldomain DROP CONSTRAINT IF EXISTS fk_countrytopleveldomain_to_domain;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytopleveldomain DROP CONSTRAINT IF EXISTS fk_countrytopleveldomain_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytimezone DROP CONSTRAINT IF EXISTS fk_countrytimezone_to_timezone;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytimezone DROP CONSTRAINT IF EXISTS fk_countrytimezone_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countryregionalbloc DROP CONSTRAINT IF EXISTS fk_countryregionalbloc_to_regionalbloc;
ALTER TABLE IF EXISTS ONLY geoinfo.countryregionalbloc DROP CONSTRAINT IF EXISTS fk_countryregionalbloc_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countrylanguage DROP CONSTRAINT IF EXISTS fk_countrylanguage_to_language;
ALTER TABLE IF EXISTS ONLY geoinfo.countrylanguage DROP CONSTRAINT IF EXISTS fk_countrylanguage_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countrycurrency DROP CONSTRAINT IF EXISTS fk_countrycurrency_to_currency;
ALTER TABLE IF EXISTS ONLY geoinfo.countrycurrency DROP CONSTRAINT IF EXISTS fk_countrycurrency_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countryborder DROP CONSTRAINT IF EXISTS fk_countryborder_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.countryborder DROP CONSTRAINT IF EXISTS fk_countryborder_to_border;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS fk_country_to_subregion;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS fk_country_to_region;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS fk_country_to_demonym;
ALTER TABLE IF EXISTS ONLY geoinfo.countrycallcode DROP CONSTRAINT IF EXISTS fk_callcode_to_country;
ALTER TABLE IF EXISTS ONLY geoinfo.altspelling DROP CONSTRAINT IF EXISTS fk_altspelling_to_country;
ALTER TABLE IF EXISTS ONLY cluster.version DROP CONSTRAINT IF EXISTS fk_version_to_cluster;
ALTER TABLE IF EXISTS ONLY cluster.auth DROP CONSTRAINT IF EXISTS fk_auth_to_cluster;
ALTER TABLE IF EXISTS ONLY auth.privilegio DROP CONSTRAINT IF EXISTS fk_privilegio_to_perfil;
ALTER TABLE IF EXISTS ONLY auth.privilegio DROP CONSTRAINT IF EXISTS fk_privilegio_to_menu;
ALTER TABLE IF EXISTS ONLY auth.privilegio DROP CONSTRAINT IF EXISTS fk_privilegio_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY auth.privilegio DROP CONSTRAINT IF EXISTS fk_privilegio_to_colaborador;
ALTER TABLE IF EXISTS ONLY auth.perfil DROP CONSTRAINT IF EXISTS fk_perfil_to_perfil;
ALTER TABLE IF EXISTS ONLY auth.perfil DROP CONSTRAINT IF EXISTS fk_perfil_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY auth.perfil DROP CONSTRAINT IF EXISTS fk_perfil_to_colaborador;
ALTER TABLE IF EXISTS ONLY auth.menu DROP CONSTRAINT IF EXISTS fk_menu_to_menu;
ALTER TABLE IF EXISTS ONLY auth.colaborador DROP CONSTRAINT IF EXISTS fk_colaborador_to_tsexo;
ALTER TABLE IF EXISTS ONLY auth.colaborador DROP CONSTRAINT IF EXISTS fk_colaborador_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY auth.colaborador DROP CONSTRAINT IF EXISTS fk_colaborador_to_colaborador;
ALTER TABLE IF EXISTS ONLY auth.autenticacao DROP CONSTRAINT IF EXISTS fk_autenticacao_to_colaborador;
ALTER TABLE IF EXISTS ONLY auth.acesso DROP CONSTRAINT IF EXISTS fk_acesso_to_menu;
ALTER TABLE IF EXISTS ONLY auth.acesso DROP CONSTRAINT IF EXISTS fk_acesso_to_colaborador_propetario;
ALTER TABLE IF EXISTS ONLY auth.acesso DROP CONSTRAINT IF EXISTS fk_acesso_to_colaborador_atualizacao;
ALTER TABLE IF EXISTS ONLY auth.acesso DROP CONSTRAINT IF EXISTS fk_acesso_to_colaborador;
DROP TRIGGER IF EXISTS tg_venda_before_check ON tweeks.venda;
DROP TRIGGER IF EXISTS tg_transacao_after_insert_adjust_posto_montante ON tweeks.transacao;
DROP TRIGGER IF EXISTS tg_fluxo_on_venda_update ON tweeks.venda;
DROP TRIGGER IF EXISTS tg_fluxo_on_venda_create ON tweeks.venda;
DROP TRIGGER IF EXISTS tg_fluxo_on_transferencia ON tweeks.transferencia;
DROP TRIGGER IF EXISTS tg_fluxo_on_retalho ON tweeks.retalho;
DROP TRIGGER IF EXISTS tg_fluxo_on_entrada ON tweeks.entrada;
DROP TRIGGER IF EXISTS tg_fluxo_on_acerto ON tweeks.acerto;
DROP TRIGGER IF EXISTS tg_conta_after_close ON tweeks.conta;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_venda_933320 ON tweeks.venda;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_transferencia_792134 ON tweeks.transferencia;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_transacao_955905 ON tweeks.transacao;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_trabalha_583304 ON tweeks.trabalha;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_tipoimposto_504064 ON tweeks.tipoimposto;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_taxa_698634 ON tweeks.taxa;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_serie_628940 ON tweeks.serie;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_retalho_993293 ON tweeks.retalho;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_posto_103596 ON tweeks.posto;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_movimento_178685 ON tweeks.movimento;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_link_698125 ON tweeks.link;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_lancamento_531885 ON tweeks.lancamento;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_impostovenda_456497 ON tweeks.impostovenda;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_imposto_311584 ON tweeks.imposto;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_guia_829296 ON tweeks.guia;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_fornecedor_355190 ON tweeks.fornecedor;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_fluxo_335984 ON tweeks.fluxo;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_entrada_898229 ON tweeks.entrada;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_ean_965869 ON tweeks.ean;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_dispoe_291390 ON tweeks.dispoe;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_deposito_927162 ON tweeks.deposito;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_custoguia_931555 ON tweeks.custoguia;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_conta_797518 ON tweeks.conta;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_cliente_313700 ON tweeks.cliente;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_classe_800703 ON tweeks.classe;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_cambio_826027 ON tweeks.cambio;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_caixa_318184 ON tweeks.caixa;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_artigo_716909 ON tweeks.artigo;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_aloca_299370 ON tweeks.aloca;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_tweeks_acerto_440580 ON tweeks.acerto;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_venda_113044 ON tweeks.venda;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_transferencia_472244 ON tweeks.transferencia;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_transacao_213897 ON tweeks.transacao;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_trabalha_490105 ON tweeks.trabalha;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_tipoimposto_816325 ON tweeks.tipoimposto;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_taxa_484021 ON tweeks.taxa;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_serie_174114 ON tweeks.serie;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_retalho_881257 ON tweeks.retalho;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_posto_770458 ON tweeks.posto;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_movimento_501528 ON tweeks.movimento;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_link_581810 ON tweeks.link;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_lancamento_151818 ON tweeks.lancamento;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_impostovenda_524654 ON tweeks.impostovenda;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_imposto_157782 ON tweeks.imposto;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_guia_487881 ON tweeks.guia;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_fornecedor_170298 ON tweeks.fornecedor;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_fluxo_818979 ON tweeks.fluxo;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_entrada_347466 ON tweeks.entrada;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_ean_784645 ON tweeks.ean;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_dispoe_585090 ON tweeks.dispoe;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_deposito_491653 ON tweeks.deposito;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_custoguia_210607 ON tweeks.custoguia;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_conta_738120 ON tweeks.conta;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_cliente_226963 ON tweeks.cliente;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_classe_872014 ON tweeks.classe;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_cambio_189868 ON tweeks.cambio;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_caixa_609494 ON tweeks.caixa;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_artigo_940916 ON tweeks.artigo;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_aloca_545021 ON tweeks.aloca;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_tweeks_acerto_687943 ON tweeks.acerto;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_tweeks_trabalha_819866 ON tweeks.trabalha;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_tweeks_espaco_329179 ON tweeks.espaco;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_tweeks_branch_637750 ON tweeks.branch;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_tweeks_trabalha_885890 ON tweeks.trabalha;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_tweeks_espaco_656816 ON tweeks.espaco;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_tweeks_branch_195577 ON tweeks.branch;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_tweeks_trabalha_4074 ON tweeks.trabalha;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_tweeks_espaco_177136 ON tweeks.espaco;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_tweeks_trabalha_7237 ON tweeks.trabalha;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_tweeks_espaco_297678 ON tweeks.espaco;
DROP TRIGGER IF EXISTS __tg_create_lancamento ON tweeks.deposito;
DROP TRIGGER IF EXISTS __tg_create_lancamento ON tweeks.conta;
DROP TRIGGER IF EXISTS __tg_before_update_classe ON tweeks.classe;
DROP TRIGGER IF EXISTS tg_report_format ON report.report;
DROP TRIGGER IF EXISTS trigger_sync_domsync ON libdom.domsync;
DROP TRIGGER IF EXISTS sync_trigger ON libdom.entryset;
DROP TRIGGER IF EXISTS tg_share_truncate ON cluster.share;
DROP TRIGGER IF EXISTS tg_share_check ON cluster.share;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_tweeks_branch_190349 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_cluster_branch_880713 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_tweeks_branch_452421 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_cluster_branch_640694 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_tweeks_branch_741787 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_cluster_branch_90929 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_tweeks_branch_248909 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_cluster_branch_78993 ON cluster.branch;
DROP TRIGGER IF EXISTS cluster_share_map ON cluster.share;
DROP TRIGGER IF EXISTS __tg_before_create_filter ON cluster.filter;
DROP TRIGGER IF EXISTS sync_branch_map_before_update_on_auth_acesso_894121 ON auth.acesso;
DROP TRIGGER IF EXISTS sync_branch_map_before_insert_on_auth_acesso_909018 ON auth.acesso;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_auth_privilegio_656203 ON auth.privilegio;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_auth_perfil_266693 ON auth.perfil;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_auth_colaborador_676820 ON auth.colaborador;
DROP TRIGGER IF EXISTS cluster_version_commit_change_update_on_auth_acesso_149765 ON auth.acesso;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_auth_privilegio_651705 ON auth.privilegio;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_auth_perfil_158915 ON auth.perfil;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_auth_colaborador_598187 ON auth.colaborador;
DROP TRIGGER IF EXISTS cluster_version_commit_change_insert_on_auth_acesso_724429 ON auth.acesso;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_auth_privilegio_7057 ON auth.privilegio;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_auth_perfil_388675 ON auth.perfil;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_auth_colaborador_456 ON auth.colaborador;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_update_on_auth_acesso_499335 ON auth.acesso;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_auth_privilegio_4414 ON auth.privilegio;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_auth_perfil_921824 ON auth.perfil;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_auth_colaborador_111 ON auth.colaborador;
DROP TRIGGER IF EXISTS cluster_version_add_change_after_insert_on_auth_acesso_680140 ON auth.acesso;
CREATE OR REPLACE VIEW report.vreport_venda AS
SELECT
    NULL::uuid AS venda_id,
    NULL::character varying AS "FATURA",
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::character varying AS "NIF",
    NULL::character varying AS "CLIENTE",
    NULL::double precision AS "$ PREÇO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::double precision AS "$ MONTANTE FINAL",
    NULL::boolean AS venda_isencao,
    NULL::text AS "ISEN.",
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::date AS "DATA",
    NULL::smallint AS tserie_id,
    NULL::character varying AS "SERIE",
    NULL::smallint AS _tgrupo_id,
    NULL::uuid AS conta_cliente_id,
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::uuid AS _branch_uid,
    NULL::uuid AS colaborador_fecho,
    NULL::uuid AS classe_id,
    NULL::uuid AS deposito_id,
    NULL::uuid AS _caixa_id,
    NULL::character varying AS "CAIXA",
    NULL::character varying AS "CÓD ARTIGO";
CREATE OR REPLACE VIEW report.vreport_notacredito AS
SELECT
    NULL::uuid AS venda_id,
    NULL::character varying AS "DOCUMENTO",
    NULL::character varying AS "JUSTIFICATIVA",
    NULL::character varying AS "DOC. ORIGEM",
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::character varying AS "NIF",
    NULL::character varying AS "CLIENTE",
    NULL::double precision AS "$ PREÇO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::double precision AS "$ MONTANTE FINAL",
    NULL::boolean AS venda_isencao,
    NULL::text AS "ISEN.",
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::date AS "DATA",
    NULL::smallint AS tserie_id,
    NULL::character varying AS "SERIE",
    NULL::smallint AS _tgrupo_id,
    NULL::uuid AS conta_cliente_id,
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::uuid AS _branch_uid,
    NULL::uuid AS colaborador_fecho,
    NULL::uuid AS classe_id,
    NULL::uuid AS deposito_id,
    NULL::uuid AS _caixa_id,
    NULL::character varying AS "CAIXA",
    NULL::character varying AS "CÓD ARTIGO";
CREATE OR REPLACE VIEW report.vreport_guiasaida AS
SELECT
    NULL::uuid AS venda_id,
    NULL::character varying AS "SERIE",
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::character varying AS "NIF",
    NULL::character varying AS "CLIENTE",
    NULL::double precision AS "$ PREÇO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::double precision AS "$ MONTANTE FINAL",
    NULL::boolean AS venda_isencao,
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::date AS "DATA",
    NULL::smallint AS _tgrupo_id,
    NULL::uuid AS conta_cliente_id,
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::uuid AS colaborador_fecho,
    NULL::uuid AS classe_id,
    NULL::character varying AS "CÓD ARTIGO",
    NULL::uuid AS _branch_uid;
CREATE OR REPLACE VIEW report.vreport_venda_artigo AS
SELECT
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::smallint AS tserie_id,
    NULL::character varying AS "SERIE",
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::character varying AS "CAIXA",
    NULL::uuid AS _caixa_id,
    NULL::character varying AS "CÓD ARTIGO",
    NULL::uuid AS _branch_uid;
DROP INDEX IF EXISTS tweeks.idx_movimento_referencia_venda_hash;
DROP INDEX IF EXISTS tweeks.idx_movimento_referencia_venda_gin;
DROP INDEX IF EXISTS tweeks.idx_movimento_referencia_entrada_hash;
DROP INDEX IF EXISTS geoinfo.idx_regionalblocother_regionalbloc_id;
DROP INDEX IF EXISTS geoinfo.idx_regionalblocname_regionalbloc_id;
DROP INDEX IF EXISTS geoinfo.idx_language_nativename;
DROP INDEX IF EXISTS geoinfo.idx_currency_name;
DROP INDEX IF EXISTS geoinfo.idx_currency_code_name;
DROP INDEX IF EXISTS geoinfo.idx_currency_code;
DROP INDEX IF EXISTS geoinfo.idx_country_subregion_id;
DROP INDEX IF EXISTS geoinfo.idx_country_region_id;
DROP INDEX IF EXISTS geoinfo.idx_country_name;
DROP INDEX IF EXISTS geoinfo.idx_country_demonym_id;
DROP INDEX IF EXISTS geoinfo.idx_country_capital;
DROP INDEX IF EXISTS geoinfo.idx_altspelling_country_id;
DROP INDEX IF EXISTS auth.idx_privilegio_perfil_id;
DROP INDEX IF EXISTS auth.idx_privilegio_colaboirador_id;
DROP INDEX IF EXISTS auth.idx_privilegio_colaboirador_atualizacao;
DROP INDEX IF EXISTS auth.idx_previlegio_menu_id;
DROP INDEX IF EXISTS auth.idx_perfil_perfil_perfil_id;
DROP INDEX IF EXISTS auth.idx_perfil_colaborador_id;
DROP INDEX IF EXISTS auth.idx_perfil_colaborador_atualizacao;
DROP INDEX IF EXISTS auth.idx_colaborador_colaborador_id;
DROP INDEX IF EXISTS auth.idx_autenticacao_colaborador_id;
DROP INDEX IF EXISTS auth.idx_agenda_colaborador_id;
DROP INDEX IF EXISTS auth.idx_acesso_menu_id;
DROP INDEX IF EXISTS auth.idx_acesso_estado;
DROP INDEX IF EXISTS auth.idx_acesso_colaborador_propetario;
DROP INDEX IF EXISTS auth."IDX_session_expire";
ALTER TABLE IF EXISTS ONLY tweeks.unit DROP CONSTRAINT IF EXISTS unit_pkey;
ALTER TABLE IF EXISTS ONLY tweeks.unit DROP CONSTRAINT IF EXISTS uk_unit_code;
ALTER TABLE IF EXISTS ONLY tweeks.tpaga DROP CONSTRAINT IF EXISTS uk_tpaga_designacao;
ALTER TABLE IF EXISTS ONLY tweeks.tmovimento DROP CONSTRAINT IF EXISTS uk_tmovimento_designacao;
ALTER TABLE IF EXISTS ONLY tweeks.tipoimposto DROP CONSTRAINT IF EXISTS uk_tipoimposto;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS uk_posto_matricula;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS uk_posto_chave;
ALTER TABLE IF EXISTS ONLY tweeks.fornecedor DROP CONSTRAINT IF EXISTS uk_fornecedor_nif;
ALTER TABLE IF EXISTS ONLY tweeks.fornecedor DROP CONSTRAINT IF EXISTS uk_fornecedor_email;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS uk_espaco_nome;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS uk_espaco_codigo;
ALTER TABLE IF EXISTS ONLY tweeks.ean DROP CONSTRAINT IF EXISTS uk_ean_code;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS uk_deposto_key;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS uk_conta_fatura;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS uk_conta_chave;
ALTER TABLE IF EXISTS ONLY tweeks.cliente DROP CONSTRAINT IF EXISTS uk_cliente_nif;
ALTER TABLE IF EXISTS ONLY tweeks.classe DROP CONSTRAINT IF EXISTS uk_classe_nome;
ALTER TABLE IF EXISTS ONLY tweeks.venda DROP CONSTRAINT IF EXISTS pk_venda_id;
ALTER TABLE IF EXISTS ONLY tweeks.tlancamento DROP CONSTRAINT IF EXISTS pk_ttransacao_id;
ALTER TABLE IF EXISTS ONLY tweeks.tserie DROP CONSTRAINT IF EXISTS pk_tserie_id;
ALTER TABLE IF EXISTS ONLY tweeks.transferencia DROP CONSTRAINT IF EXISTS pk_transferencia_id;
ALTER TABLE IF EXISTS ONLY tweeks.transacao DROP CONSTRAINT IF EXISTS pk_transacao_id;
ALTER TABLE IF EXISTS ONLY tweeks.trabalha DROP CONSTRAINT IF EXISTS pk_trabalha_id;
ALTER TABLE IF EXISTS ONLY tweeks.tposto DROP CONSTRAINT IF EXISTS pk_tposto_id;
ALTER TABLE IF EXISTS ONLY tweeks.tpaga DROP CONSTRAINT IF EXISTS pk_tpaga_id;
ALTER TABLE IF EXISTS ONLY tweeks.toperacao DROP CONSTRAINT IF EXISTS pk_toperacao_id;
ALTER TABLE IF EXISTS ONLY tweeks.tmovimento DROP CONSTRAINT IF EXISTS pk_tmovimento_id;
ALTER TABLE IF EXISTS ONLY tweeks.tlink DROP CONSTRAINT IF EXISTS pk_tlink_id;
ALTER TABLE IF EXISTS ONLY tweeks.tipoimposto DROP CONSTRAINT IF EXISTS pk_tipoimposto_id;
ALTER TABLE IF EXISTS ONLY tweeks.tgrupo DROP CONSTRAINT IF EXISTS pk_tgroupo_id;
ALTER TABLE IF EXISTS ONLY tweeks.tdocuemto DROP CONSTRAINT IF EXISTS pk_tdocumento_id;
ALTER TABLE IF EXISTS ONLY tweeks.tbranch DROP CONSTRAINT IF EXISTS pk_tbranch_id;
ALTER TABLE IF EXISTS ONLY tweeks.taxa DROP CONSTRAINT IF EXISTS pk_taxa_id;
ALTER TABLE IF EXISTS ONLY tweeks.taplicar DROP CONSTRAINT IF EXISTS pk_taplicar_id;
ALTER TABLE IF EXISTS ONLY tweeks.serie DROP CONSTRAINT IF EXISTS pk_serie_id;
ALTER TABLE IF EXISTS ONLY tweeks.retalho DROP CONSTRAINT IF EXISTS pk_retalho_id;
ALTER TABLE IF EXISTS ONLY tweeks.repcolumn DROP CONSTRAINT IF EXISTS pk_repcolumn_source;
ALTER TABLE IF EXISTS ONLY tweeks.posto DROP CONSTRAINT IF EXISTS pk_posto_id;
ALTER TABLE IF EXISTS ONLY tweeks.movimento DROP CONSTRAINT IF EXISTS pk_movimento_id;
ALTER TABLE IF EXISTS ONLY tweeks.link DROP CONSTRAINT IF EXISTS pk_link_id;
ALTER TABLE IF EXISTS ONLY tweeks.lancamento DROP CONSTRAINT IF EXISTS pk_lancamento_id;
ALTER TABLE IF EXISTS ONLY tweeks.impostovenda DROP CONSTRAINT IF EXISTS pk_impostovenda_id;
ALTER TABLE IF EXISTS ONLY tweeks.imposto DROP CONSTRAINT IF EXISTS pk_imposto_id;
ALTER TABLE IF EXISTS ONLY tweeks.guia DROP CONSTRAINT IF EXISTS pk_guia_id;
ALTER TABLE IF EXISTS ONLY tweeks.fornecedor DROP CONSTRAINT IF EXISTS pk_fornecedor_id;
ALTER TABLE IF EXISTS ONLY tweeks.fluxo DROP CONSTRAINT IF EXISTS pk_fluxo_id;
ALTER TABLE IF EXISTS ONLY tweeks.espaco DROP CONSTRAINT IF EXISTS pk_espaco_id;
ALTER TABLE IF EXISTS ONLY tweeks.entrada DROP CONSTRAINT IF EXISTS pk_entrada_id;
ALTER TABLE IF EXISTS ONLY tweeks.ean DROP CONSTRAINT IF EXISTS pk_ena_id;
ALTER TABLE IF EXISTS ONLY tweeks.dispoe DROP CONSTRAINT IF EXISTS pk_dispoe_id;
ALTER TABLE IF EXISTS ONLY tweeks.custoguia DROP CONSTRAINT IF EXISTS pk_custo_id;
ALTER TABLE IF EXISTS ONLY tweeks.conta DROP CONSTRAINT IF EXISTS pk_conta_id;
ALTER TABLE IF EXISTS ONLY tweeks.codigoimposto DROP CONSTRAINT IF EXISTS pk_codigoimposto_codigo;
ALTER TABLE IF EXISTS ONLY tweeks.cliente DROP CONSTRAINT IF EXISTS pk_cliente_id;
ALTER TABLE IF EXISTS ONLY tweeks.classe DROP CONSTRAINT IF EXISTS pk_classe_id;
ALTER TABLE IF EXISTS ONLY tweeks.chave DROP CONSTRAINT IF EXISTS pk_chave_temp;
ALTER TABLE IF EXISTS ONLY tweeks.cambio DROP CONSTRAINT IF EXISTS pk_cambio_id;
ALTER TABLE IF EXISTS ONLY tweeks.caixa DROP CONSTRAINT IF EXISTS pk_caixa_id;
ALTER TABLE IF EXISTS ONLY tweeks.branchmap DROP CONSTRAINT IF EXISTS pk_branchmap_id;
ALTER TABLE IF EXISTS ONLY tweeks.autorizacao DROP CONSTRAINT IF EXISTS pk_autorizacao_uid;
ALTER TABLE IF EXISTS ONLY tweeks.artigo DROP CONSTRAINT IF EXISTS pk_artigo_id;
ALTER TABLE IF EXISTS ONLY tweeks.deposito DROP CONSTRAINT IF EXISTS pk_amortizacao_id;
ALTER TABLE IF EXISTS ONLY tweeks.aloca DROP CONSTRAINT IF EXISTS pk_aloca_id;
ALTER TABLE IF EXISTS ONLY tweeks.acerto DROP CONSTRAINT IF EXISTS pk_acerto_id;
ALTER TABLE IF EXISTS ONLY tweeks.circular DROP CONSTRAINT IF EXISTS circular_pkey;
ALTER TABLE IF EXISTS ONLY report.vcolumn DROP CONSTRAINT IF EXISTS pk_vcolumn_source;
ALTER TABLE IF EXISTS ONLY report.var DROP CONSTRAINT IF EXISTS pk_value_key;
ALTER TABLE IF EXISTS ONLY report.talias DROP CONSTRAINT IF EXISTS pk_talias_type;
ALTER TABLE IF EXISTS ONLY report.mask DROP CONSTRAINT IF EXISTS pk_reportformats;
ALTER TABLE IF EXISTS ONLY report.report DROP CONSTRAINT IF EXISTS pk_report_source;
ALTER TABLE IF EXISTS ONLY report.agg DROP CONSTRAINT IF EXISTS pk_agg_key;
ALTER TABLE IF EXISTS ONLY report.parametrized DROP CONSTRAINT IF EXISTS parametrized_pkey;
ALTER TABLE IF EXISTS ONLY report.filter DROP CONSTRAINT IF EXISTS filter_pkey;
ALTER TABLE IF EXISTS ONLY patch.revision DROP CONSTRAINT IF EXISTS uk_ref_math;
ALTER TABLE IF EXISTS ONLY patch.raw DROP CONSTRAINT IF EXISTS pk_raw_id;
ALTER TABLE IF EXISTS ONLY map.constvalue DROP CONSTRAINT IF EXISTS pk_constvalue_name;
ALTER TABLE IF EXISTS ONLY libdom.entryset DROP CONSTRAINT IF EXISTS pk_name;
ALTER TABLE IF EXISTS ONLY libdom.domsync DROP CONSTRAINT IF EXISTS domsync_pkey;
ALTER TABLE IF EXISTS ONLY geoinfo.timezone DROP CONSTRAINT IF EXISTS uk_timezone_timezone;
ALTER TABLE IF EXISTS ONLY geoinfo.subregion DROP CONSTRAINT IF EXISTS uk_subregion_name;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalblocother DROP CONSTRAINT IF EXISTS uk_regionalblocother_otheracronym;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalbloc DROP CONSTRAINT IF EXISTS uk_regionalbloc_name;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalbloc DROP CONSTRAINT IF EXISTS uk_regionalbloc_acronym;
ALTER TABLE IF EXISTS ONLY geoinfo.region DROP CONSTRAINT IF EXISTS uk_region_name;
ALTER TABLE IF EXISTS ONLY geoinfo.language DROP CONSTRAINT IF EXISTS uk_language_name;
ALTER TABLE IF EXISTS ONLY geoinfo.language DROP CONSTRAINT IF EXISTS uk_language_iso3;
ALTER TABLE IF EXISTS ONLY geoinfo.language DROP CONSTRAINT IF EXISTS uk_language_iso2;
ALTER TABLE IF EXISTS ONLY geoinfo.domain DROP CONSTRAINT IF EXISTS uk_domain_code;
ALTER TABLE IF EXISTS ONLY geoinfo.demonym DROP CONSTRAINT IF EXISTS uk_demonym_name;
ALTER TABLE IF EXISTS ONLY geoinfo.dataset DROP CONSTRAINT IF EXISTS uk_dataset_link;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytranslation DROP CONSTRAINT IF EXISTS uk_countrytranslation_country_language;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytopleveldomain DROP CONSTRAINT IF EXISTS uk_countrytopleveldomain_country_domain;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytimezone DROP CONSTRAINT IF EXISTS uk_countrytimezone_country_timezone;
ALTER TABLE IF EXISTS ONLY geoinfo.countryregionalbloc DROP CONSTRAINT IF EXISTS uk_countryregionalbloc_country_regionalblock;
ALTER TABLE IF EXISTS ONLY geoinfo.countrylanguage DROP CONSTRAINT IF EXISTS uk_countrylanguage_country_language;
ALTER TABLE IF EXISTS ONLY geoinfo.countrycurrency DROP CONSTRAINT IF EXISTS uk_countrycurrency_country_currency;
ALTER TABLE IF EXISTS ONLY geoinfo.countryborder DROP CONSTRAINT IF EXISTS uk_countryborder_country_border;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS uk_country_numericcode;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS uk_country_nativename;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS uk_country_iso3;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS uk_country_iso2;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS uk_country_country_cioc;
ALTER TABLE IF EXISTS ONLY geoinfo.altspelling DROP CONSTRAINT IF EXISTS uk_altspelling_desc;
ALTER TABLE IF EXISTS ONLY geoinfo.timezone DROP CONSTRAINT IF EXISTS pk_timezone_id;
ALTER TABLE IF EXISTS ONLY geoinfo.subregion DROP CONSTRAINT IF EXISTS pk_subregion_id;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalblocother DROP CONSTRAINT IF EXISTS pk_regionalblocother_id;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalblocname DROP CONSTRAINT IF EXISTS pk_regionalblocname_id;
ALTER TABLE IF EXISTS ONLY geoinfo.regionalbloc DROP CONSTRAINT IF EXISTS pk_regionalbloc_id;
ALTER TABLE IF EXISTS ONLY geoinfo.region DROP CONSTRAINT IF EXISTS pk_region_id;
ALTER TABLE IF EXISTS ONLY geoinfo.language DROP CONSTRAINT IF EXISTS pk_language_id;
ALTER TABLE IF EXISTS ONLY geoinfo.domain DROP CONSTRAINT IF EXISTS pk_domain_id;
ALTER TABLE IF EXISTS ONLY geoinfo.demonym DROP CONSTRAINT IF EXISTS pk_demonym_id;
ALTER TABLE IF EXISTS ONLY geoinfo.dataset DROP CONSTRAINT IF EXISTS pk_dataset_id;
ALTER TABLE IF EXISTS ONLY geoinfo.currency DROP CONSTRAINT IF EXISTS pk_currency_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytranslation DROP CONSTRAINT IF EXISTS pk_countrytranslation_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytopleveldomain DROP CONSTRAINT IF EXISTS pk_countrytopleveldomain_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countrytimezone DROP CONSTRAINT IF EXISTS pk_countrytimezone_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countryregionalbloc DROP CONSTRAINT IF EXISTS pk_countryregionalbloc_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countrylanguage DROP CONSTRAINT IF EXISTS pk_countrylanguage_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countrycurrency DROP CONSTRAINT IF EXISTS pk_countrycurrency_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countryborder DROP CONSTRAINT IF EXISTS pk_countryborder_id;
ALTER TABLE IF EXISTS ONLY geoinfo.country DROP CONSTRAINT IF EXISTS pk_country_id;
ALTER TABLE IF EXISTS ONLY geoinfo.countrycallcode DROP CONSTRAINT IF EXISTS pk_callcode_idcountrycallcode;
ALTER TABLE IF EXISTS ONLY geoinfo.altspelling DROP CONSTRAINT IF EXISTS pk_altspelling_id;
ALTER TABLE IF EXISTS ONLY cluster.version DROP CONSTRAINT IF EXISTS uk_version_share_cluster;
ALTER TABLE IF EXISTS ONLY cluster.cluster DROP CONSTRAINT IF EXISTS uk_cluster_namespace;
ALTER TABLE IF EXISTS ONLY cluster.version DROP CONSTRAINT IF EXISTS pk_version_uid;
ALTER TABLE IF EXISTS ONLY cluster.tperiod DROP CONSTRAINT IF EXISTS pk_trepeat_id;
ALTER TABLE IF EXISTS ONLY cluster.share DROP CONSTRAINT IF EXISTS pk_share_regclass;
ALTER TABLE IF EXISTS ONLY cluster.resource DROP CONSTRAINT IF EXISTS pk_reference_uid;
ALTER TABLE IF EXISTS ONLY cluster.pull DROP CONSTRAINT IF EXISTS pk_pull_uid;
ALTER TABLE IF EXISTS ONLY cluster.object DROP CONSTRAINT IF EXISTS pk_object_id;
ALTER TABLE IF EXISTS ONLY cluster.filter DROP CONSTRAINT IF EXISTS pk_filter_id;
ALTER TABLE IF EXISTS ONLY cluster.collector DROP CONSTRAINT IF EXISTS pk_collector_uid;
ALTER TABLE IF EXISTS ONLY cluster.sequence DROP CONSTRAINT IF EXISTS pk_cluster_sequence_id;
ALTER TABLE IF EXISTS ONLY cluster.cluster DROP CONSTRAINT IF EXISTS pk_cluster_id;
ALTER TABLE IF EXISTS ONLY cluster.classmap DROP CONSTRAINT IF EXISTS pk_classname;
ALTER TABLE IF EXISTS ONLY cluster.break DROP CONSTRAINT IF EXISTS pk_break_uid;
ALTER TABLE IF EXISTS ONLY cluster.branch DROP CONSTRAINT IF EXISTS pk_branch_uid;
ALTER TABLE IF EXISTS ONLY cluster.auth DROP CONSTRAINT IF EXISTS cluster_auth_uid;
ALTER TABLE IF EXISTS ONLY auth.menu DROP CONSTRAINT IF EXISTS uq_menu_codigo;
ALTER TABLE IF EXISTS ONLY auth.tsexo DROP CONSTRAINT IF EXISTS uk_tsexo_nome;
ALTER TABLE IF EXISTS ONLY auth.tsexo DROP CONSTRAINT IF EXISTS uk_tsexo_codigo;
ALTER TABLE IF EXISTS ONLY auth.perfil DROP CONSTRAINT IF EXISTS uk_perfil_nome;
ALTER TABLE IF EXISTS ONLY auth.colaborador DROP CONSTRAINT IF EXISTS uk_colaborador_nif;
ALTER TABLE IF EXISTS ONLY auth.colaborador DROP CONSTRAINT IF EXISTS uk_colaborador_email;
ALTER TABLE IF EXISTS ONLY auth.session DROP CONSTRAINT IF EXISTS session_pkey;
ALTER TABLE IF EXISTS ONLY auth.tsexo DROP CONSTRAINT IF EXISTS pk_tsexo_id;
ALTER TABLE IF EXISTS ONLY auth.privilegio DROP CONSTRAINT IF EXISTS pk_privilegio_id;
ALTER TABLE IF EXISTS ONLY auth.perfil DROP CONSTRAINT IF EXISTS pk_perfil_id;
ALTER TABLE IF EXISTS ONLY auth.menu DROP CONSTRAINT IF EXISTS pk_menu_id;
ALTER TABLE IF EXISTS ONLY auth.colaborador DROP CONSTRAINT IF EXISTS pk_colaborador_id;
ALTER TABLE IF EXISTS ONLY auth.autenticacao DROP CONSTRAINT IF EXISTS pk_autenticacao_id;
ALTER TABLE IF EXISTS ONLY auth.acesso DROP CONSTRAINT IF EXISTS pk_acesso_id;
ALTER TABLE IF EXISTS tweeks.lancamento ALTER COLUMN lancamento_sequencia DROP DEFAULT;
ALTER TABLE IF EXISTS tweeks.fluxo ALTER COLUMN fluxo_sequencia DROP DEFAULT;
ALTER TABLE IF EXISTS tweeks.circular ALTER COLUMN id DROP DEFAULT;
ALTER TABLE IF EXISTS patch.revision ALTER COLUMN seq DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.timezone ALTER COLUMN timezone_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.subregion ALTER COLUMN subregion_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.regionalblocother ALTER COLUMN regionalblocother_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.regionalblocname ALTER COLUMN regionalblocname_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.regionalbloc ALTER COLUMN regionalbloc_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.region ALTER COLUMN region_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.language ALTER COLUMN language_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.domain ALTER COLUMN domain_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.demonym ALTER COLUMN demonym_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.dataset ALTER COLUMN dataset_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.currency ALTER COLUMN currency_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countrytranslation ALTER COLUMN countrytranslation_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countrytopleveldomain ALTER COLUMN countrytopleveldomain_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countrytimezone ALTER COLUMN countrytimezone_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countryregionalbloc ALTER COLUMN countryregionalbloc_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countrylanguage ALTER COLUMN countrylanguage_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countrycurrency ALTER COLUMN countrycurrency_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countrycallcode ALTER COLUMN countrycallcode_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.countryborder ALTER COLUMN countryborder_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.country ALTER COLUMN country_id DROP DEFAULT;
ALTER TABLE IF EXISTS geoinfo.altspelling ALTER COLUMN altspelling_id DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.pull ALTER COLUMN pull_sequence DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.object ALTER COLUMN object_sseq DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.object ALTER COLUMN object_seq DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.filter ALTER COLUMN filter_sequence DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.filter ALTER COLUMN filter_id DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.collector ALTER COLUMN collector_sequence DROP DEFAULT;
ALTER TABLE IF EXISTS cluster.auth ALTER COLUMN auth_seq DROP DEFAULT;
DROP TABLE IF EXISTS tweeks.unit;
DROP TABLE IF EXISTS tweeks.transferencia;
DROP TABLE IF EXISTS tweeks.trabalha;
DROP TABLE IF EXISTS tweeks.tposto;
DROP TABLE IF EXISTS tweeks.tlink;
DROP TABLE IF EXISTS tweeks.tdocuemto;
DROP TABLE IF EXISTS tweeks.tbranch;
DROP TABLE IF EXISTS tweeks.taplicar;
DROP VIEW IF EXISTS tweeks.stock;
DROP SEQUENCE IF EXISTS tweeks.serie_serie_sequencia_seq;
DROP SEQUENCE IF EXISTS tweeks.seq_cliente_code;
DROP SEQUENCE IF EXISTS tweeks.seq_classe_code;
DROP TABLE IF EXISTS tweeks.retalho;
DROP TABLE IF EXISTS tweeks.repcolumn;
DROP TABLE IF EXISTS tweeks.ref2;
DROP TABLE IF EXISTS tweeks.ref;
DROP SEQUENCE IF EXISTS tweeks.lancamento_lancamento_sequencia_seq;
DROP TABLE IF EXISTS tweeks.impostovenda;
DROP TABLE IF EXISTS tweeks.imposto;
DROP SEQUENCE IF EXISTS tweeks.fluxo_fluxo_sequencia_seq;
DROP TABLE IF EXISTS tweeks.ean;
DROP TABLE IF EXISTS tweeks.dispoe;
DROP TABLE IF EXISTS tweeks.custoguia;
DROP TABLE IF EXISTS tweeks.codigoimposto;
DROP SEQUENCE IF EXISTS tweeks.circular_id_seq;
DROP TABLE IF EXISTS tweeks.circular;
DROP TABLE IF EXISTS tweeks.chave;
DROP TABLE IF EXISTS tweeks.cambio;
DROP TABLE IF EXISTS tweeks.branchmap;
DROP VIEW IF EXISTS tweeks.branch;
DROP TABLE IF EXISTS tweeks.aloca;
DROP TABLE IF EXISTS tweeks.acerto;
DROP VIEW IF EXISTS tweeks._vserie;
DROP TABLE IF EXISTS sys.version;
DROP VIEW IF EXISTS report.vreport_venda_artigo;
DROP VIEW IF EXISTS report.vreport_venda;
DROP VIEW IF EXISTS report.vreport_notacredito;
DROP VIEW IF EXISTS report.vreport_imposto;
DROP TABLE IF EXISTS tweeks.tipoimposto;
DROP VIEW IF EXISTS report.vreport_guiasaida;
DROP VIEW IF EXISTS report.vreport_guiaentrada;
DROP TABLE IF EXISTS tweeks.fornecedor;
DROP VIEW IF EXISTS report.vreport_fluxo;
DROP TABLE IF EXISTS tweeks.toperacao;
DROP TABLE IF EXISTS tweeks.fluxo;
DROP VIEW IF EXISTS report.vreport_fatura;
DROP TABLE IF EXISTS tweeks.tserie;
DROP VIEW IF EXISTS report.vreport_conta;
DROP TABLE IF EXISTS tweeks.tlancamento;
DROP TABLE IF EXISTS tweeks.tgrupo;
DROP TABLE IF EXISTS tweeks.lancamento;
DROP VIEW IF EXISTS report.vreport_caixa;
DROP TABLE IF EXISTS tweeks.tpaga;
DROP TABLE IF EXISTS tweeks.deposito;
DROP TABLE IF EXISTS tweeks.cliente;
DROP VIEW IF EXISTS report.vreport_balanco;
DROP TABLE IF EXISTS tweeks.entrada;
DROP TABLE IF EXISTS report.vcolumn;
DROP TABLE IF EXISTS report.var;
DROP TABLE IF EXISTS report.template;
DROP TABLE IF EXISTS report.talias;
DROP TABLE IF EXISTS report.report;
DROP TABLE IF EXISTS report.parametrized;
DROP TABLE IF EXISTS report.mask;
DROP TABLE IF EXISTS report.filter;
DROP TABLE IF EXISTS report.agg;
DROP TABLE IF EXISTS public.lancamento;
DROP SEQUENCE IF EXISTS patch.revision_seq_seq;
DROP TABLE IF EXISTS patch.revision;
DROP TABLE IF EXISTS patch.raw;
DROP TABLE IF EXISTS map.constvalue;
DROP TABLE IF EXISTS libdom.domsync;
DROP SEQUENCE IF EXISTS geoinfo.seq_timezone;
DROP TABLE IF EXISTS geoinfo.timezone;
DROP SEQUENCE IF EXISTS geoinfo.seq_subregion;
DROP TABLE IF EXISTS geoinfo.subregion;
DROP SEQUENCE IF EXISTS geoinfo.seq_regionalblocother;
DROP SEQUENCE IF EXISTS geoinfo.seq_regionalblocname;
DROP SEQUENCE IF EXISTS geoinfo.seq_regionalbloc;
DROP SEQUENCE IF EXISTS geoinfo.seq_region;
DROP SEQUENCE IF EXISTS geoinfo.seq_language;
DROP SEQUENCE IF EXISTS geoinfo.seq_domain;
DROP SEQUENCE IF EXISTS geoinfo.seq_demonym;
DROP SEQUENCE IF EXISTS geoinfo.seq_dataset;
DROP SEQUENCE IF EXISTS geoinfo.seq_currency;
DROP SEQUENCE IF EXISTS geoinfo.seq_countrytranslation;
DROP SEQUENCE IF EXISTS geoinfo.seq_countrytopleveldomain;
DROP SEQUENCE IF EXISTS geoinfo.seq_countrytimezone;
DROP SEQUENCE IF EXISTS geoinfo.seq_countryregionalbloc;
DROP SEQUENCE IF EXISTS geoinfo.seq_countrylanguage;
DROP SEQUENCE IF EXISTS geoinfo.seq_countrycurrency;
DROP SEQUENCE IF EXISTS geoinfo.seq_countrycallcode;
DROP SEQUENCE IF EXISTS geoinfo.seq_countryborder;
DROP SEQUENCE IF EXISTS geoinfo.seq_country;
DROP SEQUENCE IF EXISTS geoinfo.seq_altspelling;
DROP TABLE IF EXISTS geoinfo.regionalblocother;
DROP TABLE IF EXISTS geoinfo.regionalblocname;
DROP TABLE IF EXISTS geoinfo.regionalbloc;
DROP TABLE IF EXISTS geoinfo.region;
DROP TABLE IF EXISTS geoinfo.language;
DROP TABLE IF EXISTS geoinfo.domain;
DROP TABLE IF EXISTS geoinfo.demonym;
DROP TABLE IF EXISTS geoinfo.currency;
DROP TABLE IF EXISTS geoinfo.countrytranslation;
DROP TABLE IF EXISTS geoinfo.countrytopleveldomain;
DROP TABLE IF EXISTS geoinfo.countrytimezone;
DROP TABLE IF EXISTS geoinfo.countryregionalbloc;
DROP TABLE IF EXISTS geoinfo.countrylanguage;
DROP TABLE IF EXISTS geoinfo.countrycurrency;
DROP TABLE IF EXISTS geoinfo.countrycallcode;
DROP TABLE IF EXISTS geoinfo.countryborder;
DROP TABLE IF EXISTS geoinfo.country;
DROP TABLE IF EXISTS geoinfo.altspelling;
DROP TABLE IF EXISTS cluster.tperiod;
DROP TABLE IF EXISTS cluster.share;
DROP TABLE IF EXISTS cluster.sequence;
DROP SEQUENCE IF EXISTS cluster.pull_pull_sequence_seq;
DROP TABLE IF EXISTS cluster.pull;
DROP SEQUENCE IF EXISTS cluster.object_object_sseq_seq;
DROP SEQUENCE IF EXISTS cluster.object_object_seq_seq;
DROP TABLE IF EXISTS cluster.ignore;
DROP SEQUENCE IF EXISTS cluster.filter_filter_sequence_seq;
DROP SEQUENCE IF EXISTS cluster.filter_filter_id_seq;
DROP TABLE IF EXISTS cluster.filter;
DROP SEQUENCE IF EXISTS cluster.collector_collector_sequence_seq;
DROP TABLE IF EXISTS cluster.classmap;
DROP TABLE IF EXISTS cluster.break;
DROP SEQUENCE IF EXISTS cluster.auth_auth_seq_seq;
DROP TABLE IF EXISTS cluster.auth;
DROP TABLE IF EXISTS auth.tsexo;
DROP TABLE IF EXISTS auth.session;
DROP TABLE IF EXISTS auth.privilegio;
DROP TABLE IF EXISTS auth.autenticacao;
DROP TABLE IF EXISTS auth.acesso;
DROP OPERATOR IF EXISTS public.|| (lib.result, text);
DROP OPERATOR IF EXISTS public.|| (lib.result, integer);
DROP OPERATOR IF EXISTS public.|| (lib.result, lib.result);
DROP OPERATOR IF EXISTS public.|| (lib.result, jsonb);
DROP OPERATOR IF EXISTS public.? (boolean, jsonb);
DROP OPERATOR IF EXISTS public.? (boolean, text);
DROP OPERATOR IF EXISTS public.- (lib.result, integer);
DROP OPERATOR IF EXISTS public.- (lib.result, text);
DROP AGGREGATE IF EXISTS lib.last(anyelement);
DROP AGGREGATE IF EXISTS lib.first(anyelement);
DROP FUNCTION IF EXISTS tweeks.viewargs_show(OUT param text, OUT key text, OUT value jsonb, OUT text text);
DROP FUNCTION IF EXISTS tweeks.viewargs_sets(jsonb);
DROP FUNCTION IF EXISTS tweeks.viewargs_set(key text, element anyelement);
DROP FUNCTION IF EXISTS tweeks.viewargs_object();
DROP FUNCTION IF EXISTS tweeks.viewarg(argname text);
DROP FUNCTION IF EXISTS tweeks.sets_tipoimposto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.sets_lancamento(args jsonb);
DROP FUNCTION IF EXISTS tweeks.main(function regproc, args jsonb, mode text);
DROP FUNCTION IF EXISTS tweeks.load_clusters(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_sets_unit(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_sets_serie(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_sets_guia(args jsonb);
DROP TABLE IF EXISTS tweeks.guia;
DROP FUNCTION IF EXISTS tweeks.funct_sets_fornecedor(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_sets_branch(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_sets_autorizacao_continue(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_sets_autorizacao(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_venda_conta(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_venda_artigo(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_venda(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_transacao(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_stock_movimentos(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_estatistica_venda(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_estatistica_posto(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_compra_entrada(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_report_caixa(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_transferencia(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_transacao_movimentacao_posto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_trabalha(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_taxa(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_stock(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_precario(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_posto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_mesa(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_link_tecla(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_link_associacao(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_item(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_imposto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_fornecedor(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_espaco(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_entrada(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_ean(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_dispoe(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_conta_nota_credito(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_colaborador(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_classe(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_cambio(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_artigo(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_reg_acerto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_report_venda(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_vendaimposto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_venda(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_retalho(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_deposito(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_conta(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_cliente(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_reg_caixa(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_posto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_conta_proforma(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_conta_dia(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_conta_data(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_conta_aberto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_colaborador(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_cliente(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_class(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_caixa_auth(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_artigo_search(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_artigo_extras(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_artigo_composto(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_load_artigo(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_generate_key(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_change_conta_proforma(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_change_conta_fechar(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_change_conta_anular(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos_change_caixa_close(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos__sync_conta_amount(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_pos__calc_imposto(arg_artigo_id uuid, montante double precision, args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_unit(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_transferencia(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_trabalha(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_tpaga(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_tipoimposto(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_tespaco(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_stoks(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_serie_available(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_serie(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_posto_status(filters jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_posto_simple(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_posto_closed();
DROP FUNCTION IF EXISTS tweeks.funct_load_posto_by_endereco(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_posto(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_mesa_livre(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_mesa(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_lancamento(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_items_simple(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_guia_data(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_fornecedor_simple(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_fornecedor(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_espaco_simple(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_espaco_migrate(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_espaco_configuracao(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_espaco(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_entrada(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_device_unregistered(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_deposito_data(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_conta_preparacao(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_conta_notacredito(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_conta_by_caixa(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_colaborador(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_cluster_by_branch(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_cliente(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_classe_simple_report(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_classe(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_chave(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_cambio_history(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_cambio_ativo(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_caixa_by_colaborador(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_caixa(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_branch(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_autorizacao(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_artigo_simple(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_artigo_data(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_artigo_base(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_artigo_associar(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_artigo(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_artig_check_nome(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_load_acerto(filter jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_generate_chave(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_venda_preparado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_venda(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_tipoimposto_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_posto_open(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_posto_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_ordem_classe(parms jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_mesa_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_mesa(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_link_unlink(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_link_switch(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_link_move(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_link_disable(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_item_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_fornecedor_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_espaco_migrate(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_espaco_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_espaco_configuracao(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_espaco(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_conta_preparar(args json);
DROP FUNCTION IF EXISTS tweeks.funct_change_conta_imprimir(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_conta(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_colaborador(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_classe_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_chave_restore(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_autorizacao_closeyear(args jsonb);
DROP FUNCTION IF EXISTS tweeks.funct_change_artigo_estado(args jsonb);
DROP FUNCTION IF EXISTS tweeks._get_venda(arg_venda_id uuid);
DROP TABLE IF EXISTS tweeks.venda;
DROP FUNCTION IF EXISTS tweeks._get_tmovimento(arg_tmovimento_id smallint);
DROP TABLE IF EXISTS tweeks.tmovimento;
DROP FUNCTION IF EXISTS tweeks._get_stock(_artigo_id uuid, _espaco_id uuid);
DROP FUNCTION IF EXISTS tweeks._get_posto(arg_posto_id uuid);
DROP TABLE IF EXISTS tweeks.posto;
DROP FUNCTION IF EXISTS tweeks._get_link(arg_link_id uuid);
DROP TABLE IF EXISTS tweeks.link;
DROP FUNCTION IF EXISTS tweeks._get_item(arg_artigo_item uuid);
DROP FUNCTION IF EXISTS tweeks._get_impostos_taxa(args jsonb);
DROP FUNCTION IF EXISTS tweeks._get_espaco(arg_espaco_id uuid);
DROP FUNCTION IF EXISTS tweeks._get_conta(arg_conta_id uuid);
DROP TABLE IF EXISTS tweeks.conta;
DROP FUNCTION IF EXISTS tweeks._get_classe(arg_classe_id uuid);
DROP TABLE IF EXISTS tweeks.classe;
DROP FUNCTION IF EXISTS tweeks._get_caixa(arg_caixa_id uuid);
DROP TABLE IF EXISTS tweeks.caixa;
DROP FUNCTION IF EXISTS tweeks._get_branch_by_espaco(uuid);
DROP FUNCTION IF EXISTS tweeks._get_branch_by_colaborador(uuid);
DROP FUNCTION IF EXISTS tweeks._get_artigo(arg_atigo_id uuid);
DROP TABLE IF EXISTS tweeks.artigo;
DROP FUNCTION IF EXISTS tweeks.__tg_venda_before_check();
DROP FUNCTION IF EXISTS tweeks.__tg_use_branch();
DROP FUNCTION IF EXISTS tweeks.__tg_fluxo_on_venda();
DROP FUNCTION IF EXISTS tweeks.__tg_fluxo_on_transferencia();
DROP FUNCTION IF EXISTS tweeks.__tg_fluxo_on_retalho();
DROP FUNCTION IF EXISTS tweeks.__tg_fluxo_on_entrada();
DROP FUNCTION IF EXISTS tweeks.__tg_fluxo_on_acerto();
DROP FUNCTION IF EXISTS tweeks.__tg_create_lancamento();
DROP FUNCTION IF EXISTS tweeks.__tg_conta_after_close();
DROP FUNCTION IF EXISTS tweeks.__tg_before_update_classe();
DROP FUNCTION IF EXISTS tweeks.__sync_branch_map();
DROP FUNCTION IF EXISTS tweeks.__sets_generate_documento(arg_espaco_auth uuid, arg_tserie integer);
DROP FUNCTION IF EXISTS tweeks.__precario(jsonb);
DROP FUNCTION IF EXISTS tweeks.__lote(args jsonb);
DROP FUNCTION IF EXISTS tweeks.__load_cambio_day(arg_espaco_auth uuid, arg_currency_id smallint, arg_cambio_data date, _const map.constant);
DROP FUNCTION IF EXISTS tweeks.__lancamento_regularizacao(args jsonb);
DROP FUNCTION IF EXISTS tweeks.__infinity_loop(_espaco tweeks.espaco);
DROP FUNCTION IF EXISTS tweeks.__get_serie_espaco(arg_espaco_auth uuid, arg_tserie integer);
DROP TABLE IF EXISTS tweeks.serie;
DROP FUNCTION IF EXISTS tweeks.__get_branch(uuid);
DROP TABLE IF EXISTS cluster.branch;
DROP FUNCTION IF EXISTS tweeks.__get_autorizacao(uuid);
DROP TABLE IF EXISTS tweeks.autorizacao;
DROP FUNCTION IF EXISTS tweeks.__generate_retalho_code(brc uuid, user_brc uuid, space_brc uuid);
DROP FUNCTION IF EXISTS tweeks.__generate_posto_chave();
DROP FUNCTION IF EXISTS tweeks.__generate_guia_code(_branch uuid, toperacao_id integer);
DROP FUNCTION IF EXISTS tweeks.__generate_fornecedor_code(_branch uuid);
DROP FUNCTION IF EXISTS tweeks.__generate_cliente_code(colaborador uuid, espaco uuid);
DROP FUNCTION IF EXISTS tweeks.__generate_classe_code(brc uuid, user_brc uuid, space_brc uuid);
DROP FUNCTION IF EXISTS tweeks.__generate_caixa_code(brc uuid, user_brc uuid, space_brc uuid);
DROP FUNCTION IF EXISTS tweeks.__generate_artigo_code(arg_classe_id uuid);
DROP FUNCTION IF EXISTS tweeks.__generate_acerto_code(brc uuid, user_brc uuid, space_brc uuid);
DROP FUNCTION IF EXISTS tweeks.__fluxo_stock(_artigo_uid uuid, _espaco_uid uuid, _classe_uid uuid, _branch uuid);
DROP FUNCTION IF EXISTS tweeks.__fluxo_scan(_artigo_id uuid, _espaco_id uuid, _resume boolean, _branch uuid);
DROP FUNCTION IF EXISTS tweeks.__conta_adjust(arg_cliente_id uuid, arg_conta_id uuid, _const map.constant);
DROP FUNCTION IF EXISTS tweeks.__cluster_filter_branch(share character varying, _object cluster.object, _collector cluster.collector, _cluster cluster.cluster, _origin cluster.cluster);
DROP FUNCTION IF EXISTS tweeks.__check_stock_on_venda(_espaco_auth uuid, _vendas jsonb);
DROP FUNCTION IF EXISTS tweeks.__branch_uid(_colaborador_uid uuid, _espaco_uid uuid);
DROP FUNCTION IF EXISTS tweeks.__branch_menu(_branch_uid uuid, _user uuid, _espaco uuid, _force boolean);
DROP TABLE IF EXISTS auth.menu;
DROP FUNCTION IF EXISTS tweeks.__artigo_has_stock(arg_artigo_id uuid, arg_espaco_id uuid, arg_quantidadedebito double precision);
DROP FUNCTION IF EXISTS tweeks.___override_auth_funct_load_menu(args jsonb);
DROP FUNCTION IF EXISTS tweeks.___override_auth_funct_load_grants(args jsonb);
DROP FUNCTION IF EXISTS tweeks.___override_auth_funct_autenticacao(args jsonb);
DROP FUNCTION IF EXISTS rule.transacao_create(arg_espaco_auth uuid, arg_posto_id uuid, arg_toperacao_id smallint, arg_tmovimento_id smallint, arg_colaborador_id integer, arg_transacao_montante double precision, arg_transacao_documento character varying, arg_transacao_referencia jsonb, arg_transacao_zera boolean, arg_transacao_observacao character varying);
DROP TABLE IF EXISTS tweeks.transacao;
DROP FUNCTION IF EXISTS rule.tipoimposto_referencia(arg_tipoimposto_id uuid);
DROP FUNCTION IF EXISTS rule.tg_venda_after_update_create_or_cansel_movimento();
DROP FUNCTION IF EXISTS rule.tg_venda_after_update_adjust_conta_montante();
DROP FUNCTION IF EXISTS rule.tg_venda_after_update_adjust_agrega_estado();
DROP FUNCTION IF EXISTS rule.tg_venda_after_insert_create_movimento();
DROP FUNCTION IF EXISTS rule.tg_transacao_after_insert_adjust_posto_montante();
DROP FUNCTION IF EXISTS rule.tg_stock_before_insert_or_update_check_quantidade();
DROP FUNCTION IF EXISTS rule.tg_stock_after_update();
DROP FUNCTION IF EXISTS rule.tg_retalho_after_insert_create_movimento();
DROP FUNCTION IF EXISTS rule.tg_conta_after_update_adjust_venda_estado();
DROP FUNCTION IF EXISTS rule.tg_caixa_after_updade_fechar_posto();
DROP FUNCTION IF EXISTS rule.tg_caixa_after_insert_abrir_posto();
DROP FUNCTION IF EXISTS rule.tg_amortizacao_afeter_insert_syncronize_montante();
DROP FUNCTION IF EXISTS rule.taxa_retirar_percentagem_adicionada(arg_value double precision, arg_percentagem double precision);
DROP FUNCTION IF EXISTS rule.taxa_espaco(_taxa tweeks.taxa, _const map.constant, arg_espaco_auth uuid);
DROP TABLE IF EXISTS tweeks.taxa;
DROP FUNCTION IF EXISTS rule.movimento_revert(arg_espaco_auth uuid, arg_colaborador_id uuid, arg_toperacao_id smallint, arg_movimento_tmovimento_id smallint, arg_referencia_key character varying, arg_referencia_value text, arg_movimento_estado smallint, arg_movimento_observacao character varying);
DROP FUNCTION IF EXISTS rule.movimento_create(arg_espaco_auth uuid, arg_colaborador_id uuid, arg_stock_id uuid, arg_toperacao_id smallint, arg_movimento_referencia jsonb, arg_movimento_quantidade double precision, arg_tmovimento_id smallint, arg_movimento_quantidadefinal double precision, arg_movimento_data date, arg_movimento_documento character varying);
DROP TABLE IF EXISTS tweeks.movimento;
DROP FUNCTION IF EXISTS rule.espaco_get_serializer(arg_espaco_id uuid);
DROP TABLE IF EXISTS tweeks.espaco;
DROP FUNCTION IF EXISTS tweeks.__space_branch_level(_espaco_id uuid);
DROP FUNCTION IF EXISTS rule.espaco_get_parent(arg_espaco_id uuid);
DROP FUNCTION IF EXISTS rule.espaco_get_childrens_static(arg_espaco_id uuid);
DROP FUNCTION IF EXISTS rule.espaco_get_childrens(arg_espaco_id uuid);
DROP FUNCTION IF EXISTS rule.constant();
DROP FUNCTION IF EXISTS rule.classe_referencia(arg_classe_id uuid);
DROP FUNCTION IF EXISTS rule.calculate_cost(arg_precario_quantidade double precision, arg_precario_custo double precision, arg_quantidade double precision);
DROP FUNCTION IF EXISTS rule.artigo_referencia(arg_artigo_id uuid);
DROP FUNCTION IF EXISTS rule.artigo_has_open_account(arg_artigo_id uuid);
DROP FUNCTION IF EXISTS rule.artigo_generate_nextcodigo(arg_classe_id uuid);
DROP FUNCTION IF EXISTS report.vreport_imposto_financas(args jsonb);
DROP FUNCTION IF EXISTS report.vcolumns(args jsonb);
DROP FUNCTION IF EXISTS report.vars(args jsonb);
DROP FUNCTION IF EXISTS report.sync(regclass, name text, priority integer, active boolean);
DROP FUNCTION IF EXISTS report.source_map(regclass);
DROP FUNCTION IF EXISTS report.source_filter(args jsonb);
DROP FUNCTION IF EXISTS report.sets_parametrized_report(args jsonb);
DROP FUNCTION IF EXISTS report.reduce_name(text);
DROP FUNCTION IF EXISTS report.funct_load_report_parametrized_filter(args jsonb);
DROP FUNCTION IF EXISTS report.funct_load_report_parametrized(args jsonb);
DROP FUNCTION IF EXISTS report.eval(expression text, args anyelement);
DROP FUNCTION IF EXISTS report.engine(report jsonb);
DROP FUNCTION IF EXISTS report.configs(args jsonb);
DROP FUNCTION IF EXISTS report.columns(regclass);
DROP FUNCTION IF EXISTS report.__template_of(ref jsonb, colconfigs jsonb);
DROP FUNCTION IF EXISTS report.__rownumber_of(text);
DROP FUNCTION IF EXISTS report.__prepare_where(report jsonb);
DROP FUNCTION IF EXISTS report.__prepare_wf(report jsonb);
DROP FUNCTION IF EXISTS report.__prepare_row_number(report jsonb);
DROP FUNCTION IF EXISTS report.__prepare_order(report jsonb, columns jsonb[], aggregates jsonb[]);
DROP FUNCTION IF EXISTS report.__prepare_column(report jsonb);
DROP FUNCTION IF EXISTS report.__prepare_aggregate(report jsonb);
DROP FUNCTION IF EXISTS report.__prepare(report jsonb);
DROP FUNCTION IF EXISTS report.__mask_reduce(anyelement, type text, format text);
DROP FUNCTION IF EXISTS report.__mask(anyelement, type text, format text, representation boolean);
DROP FUNCTION IF EXISTS report.__formattable();
DROP FUNCTION IF EXISTS report.____tg_report_format();
DROP FUNCTION IF EXISTS report."3x"(report jsonb);
DROP FUNCTION IF EXISTS public.regula_v3(_cred_id integer);
DROP FUNCTION IF EXISTS public.regula_v2(_cred_id integer);
DROP FUNCTION IF EXISTS public.regula(_cred_id integer);
DROP FUNCTION IF EXISTS public.consts(VARIADIC consts text[]);
DROP FUNCTION IF EXISTS patch.revision(args jsonb);
DROP FUNCTION IF EXISTS patch.ref(file character varying, identifier character varying);
DROP FUNCTION IF EXISTS patch.raw_of(text text);
DROP FUNCTION IF EXISTS patch.create_raw(text text);
DROP FUNCTION IF EXISTS map.funct_load_constvalue(filter jsonb);
DROP FUNCTION IF EXISTS map.funct_change_constvalue(arg jsonb);
DROP FUNCTION IF EXISTS map.describe(VARIADIC name character varying[]);
DROP FUNCTION IF EXISTS map.constants(name character varying);
DROP FUNCTION IF EXISTS map.constantdrop(arg_constant_name name, arg_dropforce boolean);
DROP FUNCTION IF EXISTS map.constant_rename(name name, newname name, force boolean);
DROP FUNCTION IF EXISTS map.constant_list(name character varying);
DROP FUNCTION IF EXISTS map.constant_list(VARIADIC name character varying[]);
DROP FUNCTION IF EXISTS map.constant(name name, type regtype, val anyelement, description character varying, editable boolean, comment character varying);
DROP FUNCTION IF EXISTS map.as_json();
DROP FUNCTION IF EXISTS map."array"(anyelement, VARIADIC name name[]);
DROP FUNCTION IF EXISTS map.any_equal(anyelement, VARIADIC name name[]);
DROP FUNCTION IF EXISTS libdom.trigger_sync_entry();
DROP FUNCTION IF EXISTS libdom.trigger_sync_domsync();
DROP FUNCTION IF EXISTS libdom.sync_entry(name name, classtype regtype);
DROP FUNCTION IF EXISTS libdom.sync_drop(name name, classtype regtype);
DROP FUNCTION IF EXISTS libdom.set(name name, value character varying, label character varying, domain character varying, force boolean);
DROP FUNCTION IF EXISTS libdom.rebuild(clean boolean);
DROP FUNCTION IF EXISTS libdom.prefix(VARIADIC prefix character varying[]);
DROP TABLE IF EXISTS libdom.entryset;
DROP FUNCTION IF EXISTS libdom.get(arg_name name);
DROP FUNCTION IF EXISTS libdom.exports(schema_name character varying, VARIADIC name character varying[]);
DROP FUNCTION IF EXISTS libdom.entry_list(args jsonb);
DROP FUNCTION IF EXISTS libdom.entry_drop(arg_name name, arg_dropforce boolean);
DROP FUNCTION IF EXISTS libdom.entry(name name, type regtype, val anyelement, domain character varying, label character varying, editable boolean, comment character varying, force boolean);
DROP FUNCTION IF EXISTS libdom.domsync(classname character varying, columnname character varying, domain character varying);
DROP FUNCTION IF EXISTS libdom.domset(_class character varying, _column character varying, _domain character varying, _comment character varying);
DROP FUNCTION IF EXISTS libdom.domain_of(domain character varying, value text);
DROP FUNCTION IF EXISTS libdom.domain_of(name name);
DROP FUNCTION IF EXISTS libdom.domain_document(VARIADIC prefix character varying[]);
DROP FUNCTION IF EXISTS libdom.domain(VARIADIC prefix character varying[]);
DROP FUNCTION IF EXISTS libdom.describe(VARIADIC prefix character varying[]);
DROP FUNCTION IF EXISTS libdom.constant_document(VARIADIC prefix character varying[]);
DROP FUNCTION IF EXISTS libdom.constant(VARIADIC prefix character varying[]);
DROP FUNCTION IF EXISTS libdom.columns(regclass);
DROP FUNCTION IF EXISTS libdom.api_load_entryset(args jsonb);
DROP FUNCTION IF EXISTS libdom.api_change_entryset(args jsonb);
DROP FUNCTION IF EXISTS lib."when"(boolean, _then anyelement, _else anyelement);
DROP FUNCTION IF EXISTS lib.version();
DROP FUNCTION IF EXISTS lib.swith(VARIADIC list anyarray);
DROP FUNCTION IF EXISTS lib.switch(anyelement, VARIADIC list anyarray);
DROP FUNCTION IF EXISTS lib.str_nospace(text);
DROP FUNCTION IF EXISTS lib.str_is_numeric_sequence(argment text);
DROP FUNCTION IF EXISTS lib.sets_up(_row anyelement, replacer jsonb, defaults text[], ref jsonb, t_where text, "with" jsonb);
DROP FUNCTION IF EXISTS lib.sets_ref_clean("table" regclass, document jsonb);
DROP FUNCTION IF EXISTS lib.sets_ref("table" regclass, document jsonb);
DROP FUNCTION IF EXISTS lib.sets_ref(jsonb, name[]);
DROP FUNCTION IF EXISTS lib.sets_ref(_record anyelement);
DROP FUNCTION IF EXISTS lib.sets_pks_array(regclass);
DROP FUNCTION IF EXISTS lib.sets_pks(regclass);
DROP FUNCTION IF EXISTS lib.sets_in(_row anyelement, replacer jsonb, "with" jsonb);
DROP FUNCTION IF EXISTS lib.sets_doc_up(regclass, doc jsonb, defaults text[], ref jsonb, t_where text, "with" jsonb);
DROP FUNCTION IF EXISTS lib.sets_doc_in(regclass, doc jsonb, "with" jsonb);
DROP FUNCTION IF EXISTS lib.sets_doc(regclass, doc jsonb, defaults name[], ref jsonb, t_where text, "with" jsonb);
DROP FUNCTION IF EXISTS lib.sets_defaults(regclass, replacer jsonb);
DROP FUNCTION IF EXISTS lib.sets_defaults(anyelement, replacer jsonb);
DROP FUNCTION IF EXISTS lib.sets(_row anyelement, replacer jsonb, defaults text[], ref jsonb, t_where text, "with" jsonb);
DROP FUNCTION IF EXISTS lib.result_true(message text);
DROP FUNCTION IF EXISTS lib.result_true(content jsonb);
DROP FUNCTION IF EXISTS lib.result_true();
DROP FUNCTION IF EXISTS lib.result_remove(lib.result, text);
DROP FUNCTION IF EXISTS lib.result_remove(lib.result, integer);
DROP FUNCTION IF EXISTS lib.result_false(message text);
DROP FUNCTION IF EXISTS lib.result_false(content jsonb);
DROP FUNCTION IF EXISTS lib.result_exception(text text, errcode character varying, hint text, detail text);
DROP FUNCTION IF EXISTS lib.result_concat(lib.result, jsonb);
DROP FUNCTION IF EXISTS lib.result_concat(lib.result, lib.result);
DROP FUNCTION IF EXISTS lib.result_catch(errocode character varying, message text, hint text, detail text, context text);
DROP FUNCTION IF EXISTS lib.result_catch(message text);
DROP FUNCTION IF EXISTS lib.result(result boolean, text text);
DROP FUNCTION IF EXISTS lib.result(result boolean, message jsonb);
DROP FUNCTION IF EXISTS lib.result(result boolean);
DROP FUNCTION IF EXISTS lib.res_true(data jsonb, message text, level integer);
DROP FUNCTION IF EXISTS lib.res_false(message text, error jsonb, level integer);
DROP FUNCTION IF EXISTS lib.res_exception(errocode character varying, message text, hint text, detail text, context text, user_message text, level integer);
DROP FUNCTION IF EXISTS lib.res(result boolean, message text, data jsonb, error jsonb, level integer);
DROP FUNCTION IF EXISTS lib.represent(number bigint, base text, length integer, lpad character);
DROP FUNCTION IF EXISTS lib.money(moneyvalue anyelement);
DROP FUNCTION IF EXISTS lib.jsonb_values_as(document jsonb, VARIADIC keys text[]);
DROP FUNCTION IF EXISTS lib.jsonb_values(document jsonb, VARIADIC keys text[]);
DROP FUNCTION IF EXISTS lib.jsonb_values(document jsonb, VARIADIC indexes integer[]);
DROP FUNCTION IF EXISTS lib.jsonb_values(element anyelement, VARIADIC keys text[]);
DROP FUNCTION IF EXISTS lib.jsonb_values(element anyelement, VARIADIC indexes integer[]);
DROP FUNCTION IF EXISTS lib.jsonb_object_length(object jsonb);
DROP FUNCTION IF EXISTS lib.jsonb_iterate_cascade(document jsonb);
DROP FUNCTION IF EXISTS lib.jsonb_iterate(document jsonb);
DROP FUNCTION IF EXISTS lib.jsonb_concat(VARIADIC jsonb[]);
DROP FUNCTION IF EXISTS lib.is_numeric(argment text);
DROP FUNCTION IF EXISTS lib.is_integer(argment text);
DROP FUNCTION IF EXISTS lib.is_bigint(argment text);
DROP FUNCTION IF EXISTS lib.initials(name character varying);
DROP FUNCTION IF EXISTS lib.in_year(interval);
DROP FUNCTION IF EXISTS lib.in_week(interval);
DROP FUNCTION IF EXISTS lib.in_second(interval);
DROP FUNCTION IF EXISTS lib.in_month(interval);
DROP FUNCTION IF EXISTS lib.in_minute(interval);
DROP FUNCTION IF EXISTS lib.in_hour(interval);
DROP FUNCTION IF EXISTS lib.in_day(interval);
DROP FUNCTION IF EXISTS lib.format(jsonb);
DROP FUNCTION IF EXISTS lib."extract"(jsonb);
DROP FUNCTION IF EXISTS lib.exception(errocode character varying, text text, hint text, detail text);
DROP FUNCTION IF EXISTS lib.eval(expression text);
DROP FUNCTION IF EXISTS lib.each(jsonb, force boolean);
DROP FUNCTION IF EXISTS lib.duplicates(list jsonb, maps jsonb, aggregate boolean);
DROP FUNCTION IF EXISTS lib.dump_functions(VARIADIC schemas text[]);
DROP FUNCTION IF EXISTS lib.dset_random_text(elements character varying, length integer);
DROP FUNCTION IF EXISTS lib.dset_random_text(length integer);
DROP FUNCTION IF EXISTS lib.dset_random_serial(length integer);
DROP FUNCTION IF EXISTS lib.dset_random_nexttimestamptz(min timestamp with time zone, max timestamp with time zone);
DROP FUNCTION IF EXISTS lib.dset_random_nextdate(arg_datainicio date, arg_datafim date);
DROP FUNCTION IF EXISTS lib.dset_random_next(min anyelement, max anyelement);
DROP FUNCTION IF EXISTS lib.dset_random_next(anyelement);
DROP FUNCTION IF EXISTS lib.dset_random_name(min integer, max integer);
DROP FUNCTION IF EXISTS lib.dset_random_element(elements anyarray);
DROP FUNCTION IF EXISTS lib.combinator(items text[], start integer, parent text[], indexs integer[], size integer);
DROP FUNCTION IF EXISTS lib.coincidences_likes(arguments_left text[], arguments_right text[], option jsonb);
DROP FUNCTION IF EXISTS lib.coincidences(arguments_left anyarray, arguments_right anyarray, option jsonb);
DROP FUNCTION IF EXISTS lib.array_min_element(arr anyarray, element anyelement);
DROP FUNCTION IF EXISTS lib.array_max_element(arr anyarray, element anyelement);
DROP FUNCTION IF EXISTS lib.array_delete(list anyarray, start integer, elements integer);
DROP FUNCTION IF EXISTS lib.array_delete(list anyarray, element integer);
DROP FUNCTION IF EXISTS lib.agg_last(anyelement, anyelement);
DROP FUNCTION IF EXISTS lib.agg_first(anyelement, anyelement);
DROP FUNCTION IF EXISTS lib.age(timestamp with time zone);
DROP FUNCTION IF EXISTS geoinfo.dataset_use(arg_dataset_link character varying);
DROP FUNCTION IF EXISTS geoinfo.dataset_update(arg_dataset_link character varying, arg_dataset_version character varying, arg_dataset_data jsonb);
DROP FUNCTION IF EXISTS geoinfo.dataset_setup();
DROP FUNCTION IF EXISTS geoinfo.dataset_populate(arg_dataset_link character varying, arg_dataset_version character varying, arg_dataset_data jsonb);
DROP FUNCTION IF EXISTS geoinfo.dataset(arg_dataset_link character);
DROP TABLE IF EXISTS geoinfo.dataset;
DROP FUNCTION IF EXISTS geoinfo.dataset();
DROP FUNCTION IF EXISTS cluster.unlink_cluster(args jsonb);
DROP FUNCTION IF EXISTS cluster.switch_remote_connection(args jsonb);
DROP FUNCTION IF EXISTS cluster.status(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_resources_downloaded(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_resources_downloaded(args json);
DROP FUNCTION IF EXISTS cluster.sets_clusters_admin(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_cluster_tree_position(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_cluster_remote(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_cluster_machine_id(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_cluster_license(args jsonb);
DROP FUNCTION IF EXISTS cluster.sets_cluster_configs(args jsonb);
DROP FUNCTION IF EXISTS cluster.reduce(VARIADIC jsonb[]);
DROP FUNCTION IF EXISTS cluster.push(args jsonb);
DROP FUNCTION IF EXISTS cluster.pull(args jsonb);
DROP FUNCTION IF EXISTS cluster.object_filter(share character varying, _object cluster.object, _collector cluster.collector, _req cluster.cluster, _origin cluster.cluster);
DROP FUNCTION IF EXISTS cluster.next(name character varying, sub character varying, zero_base boolean, steep integer, lpad integer, lpad_char character, exist text, exist_limit integer);
DROP FUNCTION IF EXISTS cluster.load_resources_pendents(args jsonb);
DROP FUNCTION IF EXISTS cluster.load_paths(args jsonb);
DROP FUNCTION IF EXISTS cluster.load_clusters_local_as_remotes(args jsonb);
DROP FUNCTION IF EXISTS cluster.load_clusters_configs_to_child(args jsonb);
DROP FUNCTION IF EXISTS cluster.load_clusters(args jsonb);
DROP FUNCTION IF EXISTS cluster.load_cluster_by_namespace(namespace character varying);
DROP FUNCTION IF EXISTS cluster.funct_reg_acesso(args jsonb);
DROP FUNCTION IF EXISTS cluster.funct_load_configs();
DROP FUNCTION IF EXISTS cluster.define_namespace(args jsonb);
DROP PROCEDURE IF EXISTS cluster.declare_filter(IN regnamespace, IN name character varying, IN share regclass, IN describe character varying);
DROP FUNCTION IF EXISTS cluster.create_resource(args jsonb);
DROP TABLE IF EXISTS cluster.resource;
DROP FUNCTION IF EXISTS cluster.commit(args jsonb);
DROP FUNCTION IF EXISTS cluster.change(jsonb, VARIADIC keys text[]);
DROP FUNCTION IF EXISTS cluster.can_send_revision(args jsonb);
DROP FUNCTION IF EXISTS cluster.can_send_object(_object cluster.object, _collector cluster.collector, _origin cluster.cluster, _request cluster.cluster, _local cluster.cluster, _master cluster.cluster, _child cluster.cluster, _const map.constant);
DROP FUNCTION IF EXISTS map.constant();
DROP FUNCTION IF EXISTS cluster.add(args jsonb);
DROP FUNCTION IF EXISTS cluster.accept_revision(args jsonb);
DROP FUNCTION IF EXISTS cluster.accept_remote_cluster(args jsonb);
DROP FUNCTION IF EXISTS cluster._get_version_local(regclass, increment boolean);
DROP FUNCTION IF EXISTS cluster._get_cluster_master();
DROP FUNCTION IF EXISTS cluster._get_cluster_local(increment boolean, try integer);
DROP FUNCTION IF EXISTS cluster._get_cluster_child(identifier character varying);
DROP FUNCTION IF EXISTS cluster._get_cluster(character varying);
DROP TABLE IF EXISTS cluster.cluster;
DROP FUNCTION IF EXISTS cluster._cluster_accept_child(args jsonb);
DROP FUNCTION IF EXISTS cluster.__user_replication();
DROP FUNCTION IF EXISTS cluster.__user_map();
DROP TABLE IF EXISTS cluster.users;
DROP FUNCTION IF EXISTS cluster.__user_default();
DROP FUNCTION IF EXISTS cluster.__tg_version_commit();
DROP FUNCTION IF EXISTS cluster.__tg_version_add_when_update();
DROP FUNCTION IF EXISTS cluster.__tg_version_add_when_insert();
DROP FUNCTION IF EXISTS cluster.__tg_share_truncate();
DROP FUNCTION IF EXISTS cluster.__tg_share_map();
DROP FUNCTION IF EXISTS cluster.__tg_share_guard_upgrade();
DROP FUNCTION IF EXISTS cluster.__tg_share_check();
DROP FUNCTION IF EXISTS cluster.__tg_before_create_filter();
DROP FUNCTION IF EXISTS cluster.__rows(VARIADIC regclass[]);
DROP FUNCTION IF EXISTS cluster.__pull(args jsonb);
DROP TABLE IF EXISTS cluster.object;
DROP FUNCTION IF EXISTS cluster.__pks(regclass);
DROP FUNCTION IF EXISTS cluster.__is_sub_path(base text, child_path text);
DROP FUNCTION IF EXISTS cluster.__is_replication();
DROP FUNCTION IF EXISTS cluster.__get(regclass, jsonb);
DROP FUNCTION IF EXISTS cluster.__generate_cluster_code();
DROP FUNCTION IF EXISTS cluster.__format_proc(regproc);
DROP FUNCTION IF EXISTS cluster.__format(regclass);
DROP FUNCTION IF EXISTS cluster.__create_object_version(regclass);
DROP TABLE IF EXISTS cluster.version;
DROP FUNCTION IF EXISTS cluster.__create_identifier();
DROP FUNCTION IF EXISTS cluster.__create_api();
DROP FUNCTION IF EXISTS cluster.__collect_change(regclass, _change jsonb, _old jsonb, _operation character, _ref jsonb, _force boolean);
DROP FUNCTION IF EXISTS cluster.__add(_regclass regclass);
DROP TABLE IF EXISTS cluster.collector;
DROP FUNCTION IF EXISTS cluster.__transaction_uid();
DROP FUNCTION IF EXISTS auth.funct_reg_trabalha(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_reg_privilegio(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_reg_perfil(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_reg_colaborador(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_reg_acesso(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_menu_cascade(filter jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_menu(filter jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_grants(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_colaborador_token_restore(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_colaborador_simple(filter jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_colaborador_by_token(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_colaborador_any_menu(filter jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_colaborador_all_menu(filter jsonb);
DROP FUNCTION IF EXISTS auth.funct_load_colaborador(filter jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_perfil(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_token_ativate(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_token_acesso(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_senha(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_pin(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_estado_disable(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_accesso_reativar(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador_accesso_disable(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_change_colaborador(args jsonb);
DROP FUNCTION IF EXISTS auth.funct_autenticacao_logoff(arg jsonb);
DROP FUNCTION IF EXISTS auth.funct_autenticacao(args jsonb);
DROP FUNCTION IF EXISTS auth._menu_load_structure(filter jsonb);
DROP FUNCTION IF EXISTS auth._menu_create_set_up();
DROP FUNCTION IF EXISTS auth._menu_create(arg_menu_codigo character varying, arg_menu_nome character varying, arg_menu_menu_codigo character varying, arg_menu_link character varying, arg_menu_icon character varying);
DROP FUNCTION IF EXISTS auth._get_perfil(arg_perfil_id uuid);
DROP TABLE IF EXISTS auth.perfil;
DROP FUNCTION IF EXISTS lib.str_normalize(text text);
DROP FUNCTION IF EXISTS lib.str_is_normalized(text);
DROP FUNCTION IF EXISTS auth._get_colaborador(arg_colaborador_id uuid);
DROP FUNCTION IF EXISTS auth._encrypt(word text);
DROP FUNCTION IF EXISTS auth._colaborador_token_encrypt(_colaborador auth.colaborador);
DROP TABLE IF EXISTS auth.colaborador;
DROP FUNCTION IF EXISTS map.get(arg_constant_name name);
DROP FUNCTION IF EXISTS lib.to_uuid(anyelement);
DROP FUNCTION IF EXISTS auth._colaborador_generate_senha_token();
DROP FUNCTION IF EXISTS auth._colaborador_generate_pin_token();
DROP FUNCTION IF EXISTS auth._colaborador_estado_desc(arg_colaborador_estado smallint);
DROP FUNCTION IF EXISTS auth._colaborador_accesso_desc(arg_colaborador_acesso smallint);
DROP FUNCTION IF EXISTS auth._autenticacao_chave_generate();
DROP TYPE IF EXISTS map.constant;
DROP TYPE IF EXISTS libdom.domain;
DROP TYPE IF EXISTS libdom.constant;
DROP TYPE IF EXISTS lib.result;
DROP TYPE IF EXISTS lib.res;
DROP TYPE IF EXISTS lib.exception;
DROP EXTENSION IF EXISTS "uuid-ossp";
DROP EXTENSION IF EXISTS unaccent;
DROP SCHEMA IF EXISTS tweeks;
DROP SCHEMA IF EXISTS sys;
DROP SCHEMA IF EXISTS rule;
DROP SCHEMA IF EXISTS report;
DROP SCHEMA IF EXISTS patch;
DROP SCHEMA IF EXISTS map;
DROP SCHEMA IF EXISTS libdom;
DROP SCHEMA IF EXISTS lib;
DROP SCHEMA IF EXISTS geoinfo;
DROP SCHEMA IF EXISTS cluster;
DROP SCHEMA IF EXISTS auth;
--
-- TOC entry 11 (class 2615 OID 16418)
-- Name: auth; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA auth;


--
-- TOC entry 12 (class 2615 OID 16419)
-- Name: cluster; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA cluster;


--
-- TOC entry 14 (class 2615 OID 16420)
-- Name: geoinfo; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA geoinfo;


--
-- TOC entry 13 (class 2615 OID 16421)
-- Name: lib; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA lib;


--
-- TOC entry 7 (class 2615 OID 16422)
-- Name: libdom; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA libdom;


--
-- TOC entry 15 (class 2615 OID 16423)
-- Name: map; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA map;


--
-- TOC entry 8 (class 2615 OID 16424)
-- Name: patch; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA patch;


--
-- TOC entry 9 (class 2615 OID 16425)
-- Name: report; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA report;


--
-- TOC entry 17 (class 2615 OID 16426)
-- Name: rule; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA rule;


--
-- TOC entry 10 (class 2615 OID 16427)
-- Name: sys; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA sys;


--
-- TOC entry 18 (class 2615 OID 16428)
-- Name: tweeks; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA tweeks;


--
-- TOC entry 2 (class 3079 OID 16400)
-- Name: unaccent; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS unaccent WITH SCHEMA public;


--
-- TOC entry 5542 (class 0 OID 0)
-- Dependencies: 2
-- Name: EXTENSION unaccent; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION unaccent IS 'text search dictionary that removes accents';


--
-- TOC entry 3 (class 3079 OID 16407)
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- TOC entry 5543 (class 0 OID 0)
-- Dependencies: 3
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- TOC entry 1539 (class 1247 OID 16431)
-- Name: exception; Type: TYPE; Schema: lib; Owner: -
--

CREATE TYPE lib.exception AS (
	errcode character varying,
	message text,
	hint text,
	detail text,
	context text,
	exception boolean
);


--
-- TOC entry 1542 (class 1247 OID 16434)
-- Name: res; Type: TYPE; Schema: lib; Owner: -
--

CREATE TYPE lib.res AS (
	result boolean,
	message text,
	data jsonb,
	error jsonb,
	level integer
);


--
-- TOC entry 1545 (class 1247 OID 16437)
-- Name: result; Type: TYPE; Schema: lib; Owner: -
--

CREATE TYPE lib.result AS (
	result boolean,
	message jsonb
);


--
-- TOC entry 1548 (class 1247 OID 16440)
-- Name: constant; Type: TYPE; Schema: libdom; Owner: -
--

CREATE TYPE libdom.constant AS (
	report_filter_state_active smallint,
	report_filter_state_fechado smallint,
	report_filter_filter_valuemode_samevalue smallint,
	report_filter_filter_valuemode_dateprocess smallint,
	report_filter_filter_valuemode_daterelative smallint,
	report_filter_filter_valuemode_ask smallint,
	report_filter_filter_valuemode_askallways smallint
);


--
-- TOC entry 1551 (class 1247 OID 16443)
-- Name: domain; Type: TYPE; Schema: libdom; Owner: -
--

CREATE TYPE libdom.domain AS (
	report_filter_state_active text,
	report_filter_state_fechado text,
	report_filter_filter_valuemode_samevalue text,
	report_filter_filter_valuemode_dateprocess text,
	report_filter_filter_valuemode_daterelative text,
	report_filter_filter_valuemode_ask text,
	report_filter_filter_valuemode_askallways text
);


--
-- TOC entry 1554 (class 1247 OID 16446)
-- Name: constant; Type: TYPE; Schema: map; Owner: -
--

CREATE TYPE map.constant AS (
	acesso_estado_fechado smallint,
	colaborador_tipo_system smallint,
	colaborador_estado_ativo smallint,
	perfil_estado_fechado smallint,
	menu_estado_ativo smallint,
	perfil_estado_ativo smallint,
	privilegio_estado_ativo smallint,
	privilegio_estado_fechado smallint,
	colaborador_tipo_user_master smallint,
	acesso_estado_ativo smallint,
	colaborador_estado_fechado smallint,
	colaborador_accesso_ativo smallint,
	autenticacao_estado_ativo smallint,
	autenticacao_estado_fechado smallint,
	colaborador_accesso_fechado smallint,
	menu_maxchildren smallint,
	menu_estado_fechado smallint,
	colaborador_tipo_user smallint,
	colaborador_token_limit interval,
	colaborador_token_length smallint,
	colaborador_accesso_pendente smallint,
	autenticacao_chave_length smallint,
	colaborador_system_data uuid,
	colaborador_system_support uuid,
	tespaco_venda smallint,
	tespaco_armazem smallint,
	classe_estado_ativo smallint,
	classe_estado_fechado smallint,
	espaco_estado_ativo smallint,
	espaco_estado_fechado smallint,
	artigo_estado_ativo smallint,
	artigo_estado_fechado smallint,
	item_estado_ativo smallint,
	dispoe_estado_ativo smallint,
	dispoe_estado_fechado smallint,
	stock_estado_ativo smallint,
	stock_estado_fechado smallint,
	entrada_estado_ativo smallint,
	entrada_estado_anulado smallint,
	transferencia_estado_ativo smallint,
	transferencia_estado_aanulado smallint,
	acerto_estado_ativo smallint,
	acerto_estado_anulado smallint,
	precario_estado_ativo smallint,
	precario_estado_fechado smallint,
	cambio_estado_ativo smallint,
	cambio_estado_fechado smallint,
	espaco_default smallint,
	item_estado_fechado smallint,
	movimento_estado_ativo smallint,
	movimento_estado_anulado smallint,
	movimento_estado_canselado smallint,
	classe_itemextra uuid,
	colaborador_chavemodo_padrao smallint,
	colaborador_chavemodo_gerado smallint,
	colaborador_chavemodo_utilizador smallint,
	cambio_estado_anulado smallint,
	currency_std smallint,
	toperacao_classe_stock smallint,
	toperacao_classe_montante smallint,
	menu_raizcomplete character varying,
	mesa_estado_disponivel smallint,
	mesa_estado_ocupado smallint,
	mesa_estado_desativado smallint,
	tposto_venda smallint,
	tposto_cobranca smallint,
	tposto_tudo smallint,
	taxa_estado_ativo smallint,
	taxa_estado_fechado smallint,
	impostovenda_estado_ativo smallint,
	impostovenda_estado_fechado smallint,
	tipoimposto_estado_ativo smallint,
	tipoimposto_estado_fechado smallint,
	maguita_retalho_estado_ativo smallint,
	maguita_ean_estado_ativo smallint,
	maguita_ean_estado_fechado smallint,
	maguita_tlink_preco smallint,
	maguita_fornecedor_estado_ativo smallint,
	maguita_fornecedor_estado_fechado smallint,
	maguita_aloca_estado_fechado smallint,
	maguita_aloca_estado_ativo smallint,
	maguita_posto_estado_encerado smallint,
	maguita_posto_estado_fechado smallint,
	maguita_posto_estado_aberto smallint,
	maguita_tlink_classe smallint,
	maguita_posto_caixamodo_pessoal smallint,
	maguita_posto_caixamodo_espaco smallint,
	maguita_posto_caixamodo_posto smallint,
	maguita_caixa_estado_ativo smallint,
	maguita_caixa_estado_fechado smallint,
	maguita_venda_estado_aberto smallint,
	maguita_venda_estado_fechado smallint,
	maguita_venda_estado_anulado smallint,
	maguita_venda_estado_canselado smallint,
	maguita_venda_estadopreparacao_pendente smallint,
	maguita_venda_estadopreparacao_preparado smallint,
	maguita_imposto_estado_ativo smallint,
	maguita_imposto_estado_fechado smallint,
	maguita_taplicar_adicionar smallint,
	maguita_taplicar_retirar smallint,
	maguita_cliente_estado_ativo smallint,
	maguita_conta_estado_anulado smallint,
	maguita_espaco_estado_ativo smallint,
	maguita_espaco_estado_fechado smallint,
	maguita_cambio_estado_ativo smallint,
	maguita_cambio_estado_fechado smallint,
	maguita_espaco_default smallint,
	maguita_cambio_estado_anulado smallint,
	maguita_tpaga_cash smallint,
	maguita_tpaga_deposito smallint,
	maguita_tpaga_transferencia smallint,
	maguita_tpaga_cheque smallint,
	maguita_tpaga_contacorrente smallint,
	maguita_deposito_estado_ativo smallint,
	maguita_tlancamento_deposito smallint,
	maguita_tlancamento_conta smallint,
	maguita_lancamento_estado_ativo smallint,
	maguita_conta_estado_aberto smallint,
	maguita_conta_estado_fechado smallint,
	maguita_transacao_estado_ativo smallint,
	maguita_link_estado_fechado smallint,
	maguita_link_estado_ativo smallint,
	maguita_trabalha_estado_ativo smallint,
	maguita_trabalha_estado_fechado smallint,
	maguita_cliente_estado_desativo smallint,
	maguita_tmovimento_credito smallint,
	maguita_tmovimento_debito smallint,
	maguita_toperacao_acerto smallint,
	maguita_toperacao_venda smallint,
	maguita_toperacao_transferencia smallint,
	maguita_toperacao_entrada smallint,
	maguita_toperacao_movimento smallint,
	maguita_toperacao_pagamento smallint,
	maguita_toperacao_retalho smallint,
	maguita_fluxo_estado_anulado smallint,
	maguita_serie_estado_ativo smallint,
	cluster_tcluster_local smallint,
	cluster_tcluster_master smallint,
	cluster_tcluster_remote smallint,
	cluster_tcluster_child smallint,
	cluster_treplication_replicate smallint,
	cluster_treplication_readonly smallint,
	cluster_tree_position_trunc smallint,
	cluster_tree_position_branch smallint,
	cluster_grant_revision_child character varying,
	cluster_grant_revision_sub_path character varying,
	cluster_break_status_pendent smallint,
	cluster_break_status_solved smallint,
	cluster_break_status_rejected smallint,
	cluster_grant_revision_supper_path text,
	maguita_tserie_fatura smallint,
	maguita_tserie_faturarecibo smallint,
	maguita_tserie_recibo smallint,
	maguita_tgrupo_cnormal smallint,
	maguita_tgrupo_ccorrente smallint,
	maguita_guia_estado_ativo smallint,
	maguita_tguia_entrada smallint,
	maguita_tguia_saida smallint,
	maguita_custoguia_estado_ativo smallint,
	maguita_custoguia_estado_canselado smallint,
	maguita_tlink_associacao smallint,
	money_round integer,
	maguita_tlancamento_outros smallint,
	maguita_lancamento_mode_automatic smallint,
	maguita_lancamento_mode_manual smallint,
	maguita_serie_estado_fechado smallint,
	maguita_lancamento_estado_anulado smallint,
	cluster_auth_status_active smallint,
	cluster_auth_status_close smallint,
	maguita_tserie_notacredito smallint,
	maguita_autorizacao_estado_ativo smallint,
	maguita_autorizacao_estado_fechado smallint,
	maguita_fluxo_estado_ativo smallint,
	maguita_fluxo_estado_fechado smallint,
	maguita_tserie_guiasaida smallint,
	maguita_cliente_final uuid,
	maguita_cliente_finalnotacredito uuid,
	maguita_unit_state_active smallint,
	maguita_unit_state_fechado smallint
);


--
-- TOC entry 586 (class 1255 OID 16447)
-- Name: _autenticacao_chave_generate(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._autenticacao_chave_generate() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para gerar a chave de atutenticação para uma autenticação
   */
  arg_autenticacao_chave character varying;
  _const map.constant;
begin
  _const := map.constant();

  <<random_key>> -- gerar uma chave unica para a proxima autenticação
  while arg_autenticacao_chave is null loop
    arg_autenticacao_chave := lib.dset_random_text( _const.autenticacao_chave_length );
    if (
      select count( * ) > 0
        from auth.autenticacao au
        where au.autenticacao_chave = arg_autenticacao_chave
    ) then
      arg_autenticacao_chave := null;
    end if;
  end loop;

  return arg_autenticacao_chave;
end;
$$;


--
-- TOC entry 570 (class 1255 OID 16448)
-- Name: _colaborador_accesso_desc(smallint); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._colaborador_accesso_desc(arg_colaborador_acesso smallint) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para obter a descrição do accesso colaborador
   */
  _const map.constant := map.constant();
begin

  if arg_colaborador_acesso = _const.colaborador_accesso_ativo then return 'Ativo';
  elseif arg_colaborador_acesso = _const.colaborador_accesso_pendente then return 'Pendente';
  elseif arg_colaborador_acesso = _const.colaborador_accesso_fechado then return 'Desativo';
  end if;
end;

$$;


--
-- TOC entry 573 (class 1255 OID 16449)
-- Name: _colaborador_estado_desc(smallint); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._colaborador_estado_desc(arg_colaborador_estado smallint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para devolver os estados do colaborador
   */
  _const map.constant;
begin
  _const := map.constant();
  if arg_colaborador_estado = _const.colaborador_estado_ativo then return 'Ativo'   ; end if;
  if arg_colaborador_estado = _const.colaborador_estado_fechado then return 'Desativo'; end if;

end;
$$;


--
-- TOC entry 574 (class 1255 OID 16450)
-- Name: _colaborador_generate_pin_token(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._colaborador_generate_pin_token() RETURNS character varying
    LANGUAGE sql
    AS $$
  -- gerar um pin automatico
  select to_char( ( random() * 9999 ), '0000' )
$$;


--
-- TOC entry 575 (class 1255 OID 16451)
-- Name: _colaborador_generate_senha_token(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._colaborador_generate_senha_token() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
      /**
        Essa função serve para criar um token novo
       */
      token character varying;
    begin
      loop
        token := lib.dset_random_text( 16 );
        if (
          select count( * )
            from auth.colaborador co
            where co.colaborador_token = token
        ) = 0 then
          return token;
        end if;
      end loop;
    end;
$$;


--
-- TOC entry 554 (class 1255 OID 16452)
-- Name: to_uuid(anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.to_uuid(anyelement) RETURNS uuid
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    select cast(lpad(to_hex( $1::int8 ), 32, '0') as uuid )
$_$;


--
-- TOC entry 469 (class 1255 OID 16453)
-- Name: get(name); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.get(arg_constant_name name) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
      Essa função serve para devolver o valor especifico de uma constante
   */
begin
  return (
    select cv.constvalue_value
      from map.constvalue cv
      where cv.constvalue_name = arg_constant_name
  );
end;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- TOC entry 233 (class 1259 OID 16454)
-- Name: colaborador; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.colaborador (
    colaborador_id uuid DEFAULT gen_random_uuid() NOT NULL,
    colaborador_tsexo_id smallint,
    colaborador_colaborador_id uuid NOT NULL,
    colaborador_colaborador_atualizacao uuid,
    colaborador_espaco_auth uuid,
    colaborador_nome character varying NOT NULL,
    colaborador_apelido character varying,
    colaborador_email character varying NOT NULL,
    colaborador_nif character varying,
    colaborador_datanascimento date,
    colaborador_senha character varying,
    colaborador_pin character varying,
    colaborador_pinmodo smallint,
    colaborador_senhamodo smallint,
    colaborador_accesso smallint DEFAULT (map.get('colaborador_accesso_pendente'::name))::smallint NOT NULL,
    colaborador_tipo smallint DEFAULT (map.get('colaborador_tipo_user'::name))::smallint NOT NULL,
    colaborador_foto character varying,
    colaborador_token character varying,
    colaborador_tokenlimit timestamp with time zone,
    colaborador_dataultimaatualizacasenha timestamp with time zone,
    colaborador_dataultimologin timestamp with time zone,
    colaborador_ficha jsonb,
    colaborador_estado smallint DEFAULT (map.get('colaborador_estado_ativo'::name))::smallint NOT NULL,
    colaborador_dataregisto timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    colaborador_dataatualizacao timestamp with time zone,
    colaborador_branch_uid uuid,
    _branch_uid uuid GENERATED ALWAYS AS (colaborador_branch_uid) STORED,
    CONSTRAINT ck_colaborador_unique_super_master CHECK (((colaborador_id <> colaborador_colaborador_id) OR (colaborador_id = lib.to_uuid(1))))
);


--
-- TOC entry 5551 (class 0 OID 0)
-- Dependencies: 233
-- Name: TABLE colaborador; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.colaborador IS 'Entidade para armazenar os colaboradores';


--
-- TOC entry 5552 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_id IS 'Identificacao do colaborador';


--
-- TOC entry 5553 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_tsexo_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_tsexo_id IS 'Identificador do sexo do colaborador';


--
-- TOC entry 5554 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_colaborador_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_colaborador_id IS 'Identificacao do colaborador master';


--
-- TOC entry 5555 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_colaborador_atualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_colaborador_atualizacao IS 'Identificação do ultimo colaborador que modificou o registo';


--
-- TOC entry 5556 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_nome; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_nome IS 'Corresponde ao nome do colaborador';


--
-- TOC entry 5557 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_apelido; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_apelido IS 'Corresponde ao apelido do colaborador';


--
-- TOC entry 5558 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_email; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_email IS 'Corresponde ao email único do colaborador';


--
-- TOC entry 5559 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_nif; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_nif IS 'Corresponde ao nif único do colaborador';


--
-- TOC entry 5560 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_datanascimento; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_datanascimento IS 'Corresponde a data do nascimento do colaborador';


--
-- TOC entry 5561 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_senha; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_senha IS 'Corresponde a senha do colaborador - É utilizado a função auth.encrypt( $passWord );';


--
-- TOC entry 5562 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_accesso; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_accesso IS 'Esse atributo indica o estado do acesso do colaborador ao sistema
<ul>
  <li> 2 - Pendente | O prochimo acesso ao sistema devera ser por meio do token e o colaborador sera obrigatorio a mudar de senha</li>
  <li> 1 - Ativo | O colaborador pode entrar e sair do sistema livrimente</li>
  <li> 0 - Fechado | O colaborador não pode mais entrar no sistema </li>
</ul>';


--
-- TOC entry 5563 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_tipo; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_tipo IS 'Indica o tipo do colaborador
<ul>
  <li> 0 - Sistema </li>
  <li> 1 - Utilizador normal </li>
  <li> 2 - Super utilizador </li>
</ul>';


--
-- TOC entry 5564 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_foto; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_foto IS 'Corresponde a fotografia do colaborador';


--
-- TOC entry 5565 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_token; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_token IS 'Corresponde ao token gerado para a primeira autenticação do colaborador no sistema ou a recuperação da senha do mesmo.';


--
-- TOC entry 5566 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_tokenlimit; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_tokenlimit IS 'A data limite do token (indica o tempo de validade to token de ativação)';


--
-- TOC entry 5567 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_dataultimaatualizacasenha; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_dataultimaatualizacasenha IS 'Indica a última data em que o a senha do colaborador foi atualizada';


--
-- TOC entry 5568 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_ficha; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_ficha IS 'A ficha do colaborador, serve para registar as informações do colaborador não planeada no momento do planejamento sem ter que mudar a estrutura da base de dados';


--
-- TOC entry 5569 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_estado; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_estado IS 'Corresponde ao estado do colaborador na base de dados, diferente do acesso esse indica se o colaborador esta valido ou invalido no sistama
<br/> Os colaboradores invalidos (Desativos) não podem mais entrar no sistema muito menos aparecer nas listagem (excepto uma listagem expecifica para ver os colaboradores nessa situação)
<ul>
  <li> 1 - Ativo | O colaborador pode comportar livrimente no sistema</li>
  <li> 0 - Destivo | É como se o registro fosse eliminado do sistam</li>
</ul>';


--
-- TOC entry 5570 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_dataregisto; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_dataregisto IS 'Corresponde a data em que o colaborador foi registrado no sistema';


--
-- TOC entry 5571 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN colaborador.colaborador_dataatualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.colaborador.colaborador_dataatualizacao IS 'Corresponde a última data em que o colaborador foi atualizado no sistema';


--
-- TOC entry 576 (class 1255 OID 16466)
-- Name: _colaborador_token_encrypt(auth.colaborador); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._colaborador_token_encrypt(_colaborador auth.colaborador) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
    /**
      Essa função serve para criar o token de ativação para um colaborador
     */
  begin
    return auth._encrypt( coalesce( _colaborador.colaborador_token, '' ) )
      || auth._encrypt( coalesce( _colaborador.colaborador_email, '' ) )
      || auth._encrypt( _colaborador.colaborador_id::text )
      || auth._encrypt( _colaborador.colaborador_senha::text );
  end;

$$;


--
-- TOC entry 580 (class 1255 OID 16467)
-- Name: _encrypt(text); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._encrypt(word text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
  wordMd5 character varying default md5( word );
begin
  return md5(
      md5(
          wordMd5
          ||substring( wordMd5, 1, 20 )
          ||md5(
              md5( $$%#*//-+@$£€{}[]()?!&|\\:;,.^~ºª«»<>çáèíÒú$$ )
              || word
              || substring( wordMd5, 15, 28 )
              || substring( wordMd5, 13, 11 )
              || substring( wordMd5, 17, 20 )
              || substring( wordMd5, 7,  21 )
          )
      )
  );
end;
$_$;


--
-- TOC entry 581 (class 1255 OID 16468)
-- Name: _get_colaborador(uuid); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._get_colaborador(arg_colaborador_id uuid) RETURNS auth.colaborador
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para obter a instancia de um colaborador a partir do seu identificador único
   */
  _colaborador auth.colaborador;
begin

  select * into _colaborador
    from auth.colaborador co
    where co.colaborador_id = arg_colaborador_id
  ;
  return _colaborador;
end;
$$;


--
-- TOC entry 557 (class 1255 OID 16469)
-- Name: str_is_normalized(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.str_is_normalized(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
  /**
    Essa função serve para vefificar se um texto esta normalizado
   */
  arg_normalized text := lib.str_normalize( $1 );
begin
  if arg_normalized is null and $1 is not null then return false; end if;
  if arg_normalized != $1 then return false; end if;
  return true;
end;
$_$;


--
-- TOC entry 558 (class 1255 OID 16470)
-- Name: str_normalize(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.str_normalize(text text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para verificar se uma string esta normalizada (sem espacos desnecessarios)
   */
  new_text text;
begin
  new_text := trim( regexp_replace( text, '\s+', ' ', 'g') );
  if length( new_text ) = 0 then return null; end if;
  return new_text;
end;
$$;


--
-- TOC entry 234 (class 1259 OID 16471)
-- Name: perfil; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.perfil (
    perfil_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    perfil_perfil_id uuid,
    perfil_colaborador_id uuid NOT NULL,
    perfil_colaborador_atualizacao uuid,
    perfil_nome character varying NOT NULL,
    perfil_codigo character varying,
    perfil_estado smallint DEFAULT (map.get('perfil_estado_ativo'::name))::smallint NOT NULL,
    perfil_dataregisto timestamp with time zone DEFAULT now() NOT NULL,
    perfil_dataatualizacao timestamp with time zone,
    CONSTRAINT ck_perfil_codigo CHECK ((lib.str_is_normalized((perfil_codigo)::text) AND ((perfil_codigo)::text = lib.str_normalize((perfil_codigo)::text)))),
    CONSTRAINT ck_perfil_nome_is_normalizedo CHECK (lib.str_is_normalized((perfil_nome)::text)),
    CONSTRAINT ck_perfil_nome_normalized CHECK (lib.str_is_normalized((perfil_nome)::text))
);


--
-- TOC entry 5578 (class 0 OID 0)
-- Dependencies: 234
-- Name: TABLE perfil; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.perfil IS 'Essa entidade serve para armazenar os prefis para os colaboradores (um perfil indiga um agrupamento de menus)';


--
-- TOC entry 5579 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_id IS 'Identificador único do perfil';


--
-- TOC entry 5580 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_perfil_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_perfil_id IS 'Identificador do perfil parente';


--
-- TOC entry 5581 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_colaborador_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_colaborador_id IS 'Identificador do colaborador responsável pela criação do prefil.';


--
-- TOC entry 5582 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_colaborador_atualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_colaborador_atualizacao IS 'Identificador do último colaborador responsavel pela atualização do perfil';


--
-- TOC entry 5583 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_nome; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_nome IS 'Corresponde ao nome do perfil';


--
-- TOC entry 5584 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_codigo; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_codigo IS 'Corresponde ao código do perfil (perfil com codigos são perfis padrão e não podem ser modificados nem atualizados)';


--
-- TOC entry 5585 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_estado; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_estado IS 'Corresponde ao estado do perfil
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Desativo </li>
</ul>';


--
-- TOC entry 5586 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_dataregisto; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_dataregisto IS 'Corresponde ao instante em que a inscrição foi cadastrado';


--
-- TOC entry 5587 (class 0 OID 0)
-- Dependencies: 234
-- Name: COLUMN perfil.perfil_dataatualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.perfil.perfil_dataatualizacao IS 'Corresponde ao último instante em que o perfil foi atualizado';


--
-- TOC entry 582 (class 1255 OID 16482)
-- Name: _get_perfil(uuid); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._get_perfil(arg_perfil_id uuid) RETURNS auth.perfil
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para obter a instancia do perfil a partir do seu identificador único
   */
  _perfil auth.perfil;
begin

  select * into _perfil
    from auth.perfil pe
    where pe.perfil_id = arg_perfil_id
  ;

  return _perfil;

end;
$$;


--
-- TOC entry 606 (class 1255 OID 16483)
-- Name: _menu_create(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._menu_create(arg_menu_codigo character varying, arg_menu_nome character varying, arg_menu_menu_codigo character varying DEFAULT NULL::character varying, arg_menu_link character varying DEFAULT NULL::character varying, arg_menu_icon character varying DEFAULT NULL::character varying) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
DECLARE
  /**
    Essa função serve para criar um novo menu
   */
  arg_menu_nivel int default 0;
  arg_menu_raiz character varying;
  arg_total_raiz int;
  _menu auth.menu;
  _menu_menu auth.menu;
  _const constant map.constant := map.constant();
BEGIN
  -- O codigo do menu deve ser unico
  if (
       select count(*)
       from  auth.menu m
       where lower(m.menu_codigo) = lower( arg_menu_codigo )
     ) > 0 then
    raise exception 'Já existe um menu com esse codigo';
  end if;

  -- O codigo do menu super tem de existir
  if arg_menu_menu_codigo is not null and (
    select count(*)
    from  auth.menu m
    where lower(m.menu_codigo) =  lower( arg_menu_menu_codigo )
  ) = 0 then
    raise exception 'Identificador do menu super não foi encontrado!';
  end if;

  if arg_menu_menu_codigo is not null then
    select * into _menu_menu
      from  auth.menu m
      where upper( m.menu_codigo ) = upper( arg_menu_menu_codigo )
    ;

    select count (*) into arg_total_raiz
      from  auth.menu me
      where me.menu_menu_id = _menu_menu.menu_id
    ;

    arg_menu_raiz := _menu_menu.menu_raiz||'.'||trim(to_char( arg_total_raiz, _const.menu_raizcomplete ));
    arg_menu_nivel := _menu_menu.menu_nivel +1;
  else
    select count (*) into arg_total_raiz
      from auth.menu me
      where me.menu_menu_id is null;

    -- Quando exeder a quantidade de sub menu maximo em um menu entao abortar a operacao emitindo uma message de eroo
    if arg_total_raiz > _const.menu_maxchildren then
      return lib.result_false(
          lib.message('max-submenu-exceeded')
      );
    END IF;
    arg_menu_raiz := trim(to_char(arg_total_raiz, _const.menu_raizcomplete));
  end if;

  insert into auth.menu(
    menu_menu_id,
    menu_nome,
    menu_link,
    menu_codigo,
    menu_nivel,
    menu_raiz
  ) values (
    _menu_menu.menu_id,
    arg_menu_nome,
    arg_menu_link,
    arg_menu_codigo,
    arg_menu_nivel,
    arg_menu_raiz
  ) returning * into _menu;

  perform  auth._menu_create_set_up();

  return lib.result_false(
      jsonb_build_object(
          'data', to_jsonb( _menu ),
          'text', 'success'
      )
  );

END;
$$;


--
-- TOC entry 585 (class 1255 OID 16484)
-- Name: _menu_create_set_up(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._menu_create_set_up() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para estruturar os  eus depois que o novo menu é registrado
   */
  _menu record;
  icount int default 0;
begin
  for _menu in (
    select *
    from auth._menu_load_structure( )
  ) loop
    update auth.menu cur
    set menu_children = (
      select count( * )
      from auth.menu mm
      where mm.menu_raiz like cur.menu_raiz||'.%'
    ),
      menu_directchildern = (
        select count( * )
        from auth.menu mm
        where mm.menu_menu_id = cur.menu_id
      ),
      menu_maxnode = (
        select length( replace( substr( mm.menu_raiz, length( cur.menu_raiz )+1, length( mm.menu_raiz ) ), '.', '') ) /2
        from auth.menu mm
        where mm.menu_raiz like cur.menu_raiz||'%'
        order by mm.menu_nivel desc
        limit 1
      ),
      menu_position = icount
    where cur.menu_id = _menu.menu_id;

    icount := icount  + 1 ;
  end loop;
end;
$$;


--
-- TOC entry 607 (class 1255 OID 16485)
-- Name: _menu_load_structure(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth._menu_load_structure(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(menu_id smallint, menu_codigo character varying, menu_nome character varying, menu_raiz character varying, menu_nivel smallint, menu_link character varying, menu_icon character varying, menu_estado smallint, menu_children smallint, menu_directchildern smallint, menu_maxnode smallint, menu_position smallint, menu_menu_id smallint, menu_menu_codigo character varying, menu_menu_nome character varying, menu_menu_raiz character varying, menu_menu_nivel smallint, menu_menu_link character varying, menu_menu_icon character varying)
    LANGUAGE plpgsql
    AS $$
declare
  _menu record;
  menu_super_id int2 default filter->>'menu_id';
begin
  for _menu in (
    select
      me.menu_id,
      me.menu_codigo,
      me.menu_nome,
      me.menu_raiz,
      me.menu_nivel,
      me.menu_link,
      me.menu_icon,
      me.menu_estado,
      me.menu_children,
      me.menu_directchildern,
      me.menu_maxnode,
      me.menu_position,
      super.menu_id as menu_menu_id,
      super.menu_codigo as menu_menu_codigo,
      super.menu_nome as menu_menu_nome,
      super.menu_raiz as menu_menu_raiz,
      super.menu_nivel as menu_menu_nivel,
      super.menu_link as menu_menu_link,
      super.menu_icon as menu_menu_icon
    from auth.menu me
      left join auth.menu super on  me.menu_menu_id = super.menu_id
    where me.menu_menu_id = menu_super_id or (
      menu_super_id is null and me.menu_menu_id is null
    )
    order by
      me.menu_position,
      me.menu_nome
  ) loop -- proximo concorente



    -- Quando um menu tem filhos emtao motra todos os filhos desse menu antes de passa para o proximo meno
    return query
      select
        _menu.menu_id,
        _menu.menu_codigo,
        _menu.menu_nome,
        _menu.menu_raiz,
        _menu.menu_nivel,
        _menu.menu_link,
        _menu.menu_icon,
        _menu.menu_estado,
        _menu.menu_children,
        _menu.menu_directchildern,
        _menu.menu_maxnode,
        _menu.menu_position,
        _menu.menu_menu_id,
        _menu.menu_menu_codigo,
        _menu.menu_menu_nome,
        _menu.menu_menu_raiz,
        _menu.menu_menu_nivel,
        _menu.menu_menu_link,
        _menu.menu_menu_icon
    ;

    if _menu.menu_children > 0 then
      return query select *
        from auth._menu_load_structure(
          jsonb_build_object(
            'menu_id', _menu.menu_id
          )
        );
    end if;

  end loop;
end;
$$;


--
-- TOC entry 610 (class 1255 OID 16486)
-- Name: funct_autenticacao(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_autenticacao(args jsonb) RETURNS TABLE(autenticacao_id uuid, autenticacao_chave character varying, autenticacao_dataregistro character varying, colaborador_id uuid, colaborador_email character varying, colaborador_nome character varying, colaborador_apelido character varying, colaborador_foto character varying, colaborador_accesso smallint, colaborador_estado smallint, colaborador_dataultimaatualizacasenha timestamp with time zone, colaborador_accessodesc character varying, colaborador_estadodesc character varying, tsexo_id smallint, tsexo_codigo character, tsexo_nome character varying, acesso jsonb)
    LANGUAGE plpgsql
    AS $$
declare
/**
  Essa funcao serve para autenticar um colaborador
  no final da autenticacao sera devolvido as informacoes basica do colaborador
  args :{
    arg_auth_name: id | nif | email
    arg_auth_value: VALUE_OF_AUTH_NAME,
    arg_auth_method: senha | pin,
    arg_auth_key: VALUE_OF_AUTH_METHOD
    menus:[]
  }
*/

    arg_auth_name varchar := lib.str_normalize( lower( args->>'arg_auth_name' ) );
    arg_auth_value varchar := args->>'arg_auth_value';
    arg_auth_method varchar := lib.str_normalize( lower( args->>'arg_auth_method' ) );
    arg_auth_key varchar := args->>'arg_auth_key';


    _data record;
    _autenticacao auth.autenticacao;
    _const map.constant := map.constant();
    arg_autenticacao_chave character varying;
    arg_acessos jsonb;

begin
    if arg_auth_name is null then return; end if;
    if arg_auth_value is null then return; end if;
    if arg_auth_method is null then return; end if;
    if arg_auth_key is null then return; end if;

    if arg_auth_name not in ( 'id', 'nif', 'email' ) then return; end if;
    if arg_auth_method not in ( 'pin', 'senha' ) then return; end if;


    arg_auth_name := lower( lib.str_normalize( arg_auth_name ) );

    select * into _data
    from auth.colaborador co
             left join auth.tsexo sex on co.colaborador_tsexo_id = sex.tsexo_id
    where to_jsonb( co )->>format( 'colaborador_%s', arg_auth_name )  = arg_auth_value
      and to_jsonb( co )->>format( 'colaborador_%s', arg_auth_method )  = auth._encrypt( arg_auth_key )
      and co.colaborador_estado = _const.colaborador_estado_ativo
      and co.colaborador_accesso in ( _const.colaborador_accesso_ativo, _const.colaborador_accesso_pendente )
      and co.colaborador_tipo in ( _const.colaborador_tipo_user, _const.colaborador_tipo_user_master )
    ;



-- Quando as credenciais nao se conicedem
    if _data.colaborador_id is null then
        return;
    end if;

    -- Criar a chave única de autenticação
    arg_autenticacao_chave := auth._autenticacao_chave_generate();

    -- Criar a instancia de autenticação
    insert into auth.autenticacao(
        autenticacao_colaborador_id,
        autenticacao_chave
    ) values (
                 _data.colaborador_id,
                 arg_autenticacao_chave
             ) returning * into _autenticacao;

-- Carregar todos os menus do colaborador
  select jsonb_agg( e._grants ) into arg_acessos
    from auth.funct_load_grants( jsonb_build_object(
      'menus', args->'menus',
      'colaborador_id', _data.colaborador_id
    )) e ( _grants );

-- Devolver as informações do colaborador autenticado
    funct_autenticacao.autenticacao_id                        := _autenticacao.autenticacao_id;
    funct_autenticacao.autenticacao_chave                     := _autenticacao.autenticacao_chave;
    funct_autenticacao.autenticacao_dataregistro              := _autenticacao.autenticacao_dataregisto;

    funct_autenticacao.colaborador_id                         := _data.colaborador_id;
    funct_autenticacao.colaborador_email                      := _data.colaborador_email;
    funct_autenticacao.colaborador_nome                       := _data.colaborador_nome;
    funct_autenticacao.colaborador_apelido                    := _data.colaborador_apelido;
    funct_autenticacao.colaborador_foto                       := _data.colaborador_foto;
    funct_autenticacao.colaborador_estado                     := _data.colaborador_estado;
    funct_autenticacao.colaborador_accesso                    := _data.colaborador_accesso;
    funct_autenticacao.colaborador_dataultimaatualizacasenha  := _data.colaborador_dataultimaatualizacasenha;
    funct_autenticacao.colaborador_estadodesc                 := auth._colaborador_estado_desc( _data.colaborador_estado );
    funct_autenticacao.colaborador_accessodesc                := auth._colaborador_accesso_desc( _data.colaborador_accesso );

    funct_autenticacao.tsexo_id                               := _data.tsexo_id;
    funct_autenticacao.tsexo_nome                             := _data.tsexo_nome;
    funct_autenticacao.tsexo_codigo                           := _data.tsexo_codigo;
    funct_autenticacao.acesso                                 := arg_acessos;
    return next ;
end;
$$;


--
-- TOC entry 611 (class 1255 OID 16487)
-- Name: funct_autenticacao_logoff(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_autenticacao_logoff(arg jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa funçãos serve para terminar a seção de um colaborador
     */

  arg_autenticacao_chave character varying := arg->>'arg_autenticacao_chave';

  _autenticacao auth.autenticacao;
  _const constant map.constant := map.constant();
begin
  select * into _autenticacao
    from auth.autenticacao au
    where  au.autenticacao_chave = arg_autenticacao_chave
  ;

  if _autenticacao.autenticacao_estado != _const.autenticacao_estado_ativo then
    return lib.result_true();
  end if;

  update auth.autenticacao
    set autenticacao_estado = _const.autenticacao_estado_fechado,
        autenticacao_dataatualizacao = now()
    where autenticacao_id = _autenticacao.autenticacao_id;

  return lib.result_true( 'sucesso' );

end;
$$;


--
-- TOC entry 612 (class 1255 OID 16488)
-- Name: funct_change_colaborador(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para aatualizar as informações do colaborador
    args := {
      arg_colaborador_id: ID,
      arg_colaborador_editar: ID,
      arg_colaborador_email: MAIL,
      arg_colaborador_nome: NOME,
      arg_colaborador_apelido: APELIDO,
      arg_colaborador_datanascimento: DATA,
      arg_colaborador_nif: NIF,
      arg_colaborador_ficha: FICHA,
      arg_colaborador_foto: FICHA,
      arg_tsexo_id: SEXO
    }
    arg_colaborador_editar corresponde ao id do colaborador que sera atualizado
    arg_colaborador_id corresponde ao id do colaborador que esata efetuar a atualização
  */

  arg_colaborador_id uuid not null       := args->>'arg_colaborador_id';
  arg_colaborador_editar uuid not null   := args->>'arg_colaborador_editar';

  arg_colaborador_email character varying   := args->>'arg_colaborador_email';
  arg_colaborador_nome character varying    := args->>'arg_colaborador_nome';
  arg_colaborador_apelido character varying := args->>'arg_colaborador_apelido';
  arg_colaborador_datanascimento date       := args->>'arg_colaborador_datanascimento';
  arg_colaborador_nif character varying     := args->>'arg_colaborador_nif';
  arg_colaborador_ficha jsonb               := args->>'arg_colaborador_ficha';
  arg_colaborador_foto varchar               := args->>'arg_colaborador_foto';
  arg_tsexo_id int2                         := args->>'arg_tsexo_id';

  _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_editar );
  _const map.constant;
begin
    _const := map.constant();

    -- Tanto o nif, quanto o email deve ser único na base de dados
    arg_colaborador_email := lib.str_normalize( lower( arg_colaborador_email ) );
    arg_colaborador_nif := lib.str_normalize( lower( arg_colaborador_nif ) );

    -- Quando existir email e estiver associado ao utro colaborador então
    if arg_colaborador_email is not null  and (
      select count( * )
        from auth.colaborador
        where colaborador_email = arg_colaborador_email
          and colaborador_id != _colaborador.colaborador_id
    ) > 0 then
      return lib.result_false( '@auth.colaborador.email-exist' );
    end if;

    -- Quando existir um colaborador o nif expecificado
    if arg_colaborador_nif is not null is not null and  (
      select count( * ) > 0
        from auth.colaborador co
        where co.colaborador_nif = arg_colaborador_nif
          and co.colaborador_id != _colaborador.colaborador_id
    ) then
      return lib.result_false( '@auth.colaborador.nif-exist' );
    end if;

    -- A atualização deve ser feita apenas quando o novo valor vier nulo
    update auth.colaborador
      set colaborador_email = coalesce( arg_colaborador_email, colaborador_email ),
          colaborador_nome = coalesce( lib.str_normalize( arg_colaborador_nome ), colaborador_nome ),
          colaborador_apelido = coalesce( lib.str_normalize( arg_colaborador_apelido ), colaborador_apelido ),
          colaborador_tsexo_id = coalesce( arg_tsexo_id, colaborador_tsexo_id ),
          colaborador_datanascimento = coalesce( arg_colaborador_datanascimento, colaborador_datanascimento ),
          colaborador_nif = coalesce( arg_colaborador_nif, colaborador_nif ),
          colaborador_foto = coalesce( arg_colaborador_foto, colaborador_foto ),
          colaborador_ficha = coalesce( arg_colaborador_ficha, colaborador_ficha ),
          colaborador_colaborador_atualizacao = arg_colaborador_id,
          colaborador_dataatualizacao = now()
      where colaborador_id = _colaborador.colaborador_id
    ;

    return lib.result_true();
  end;
$$;


--
-- TOC entry 613 (class 1255 OID 16489)
-- Name: funct_change_colaborador_accesso_disable(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_accesso_disable(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa função serve para disativar o accesso de um dado colaborador no sistema
      args := {
        arg_colaborador_id: ID,
        arg_colaborador_disable: ID
      }
      -- argumentos
        arg_colaborador_id corresponde ao colaborador logado no sistema que esta a efetuar a operação de desativação
        arg_colaborador_disable corresponde ao colaborador que tera o acesso desabilitado do sistema
     */

  arg_colaborador_id uuid := args->>'arg_colaborador_id';
  arg_colaborador_disable uuid := args->>'arg_colaborador_disable';
  _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_disable );
  _const map.constant;
begin
  _const := map.constant();

  -- Um colaborador master não pode ser desabilitado do sistema
  if _colaborador.colaborador_tipo = _const.colaborador_tipo_user_master then
    return lib.result_false( 'auth.colaborador.disable-master' );
  end if;

  update auth.colaborador
    set colaborador_accesso = 0,
        colaborador_colaborador_atualizacao = arg_colaborador_id,
        colaborador_dataatualizacao = current_timestamp
    where colaborador_id = arg_colaborador_disable
    returning * into _colaborador;

  return lib.result_true(
    jsonb_build_object(
      'colaborador', _colaborador
    )
  );
end;
$$;


--
-- TOC entry 614 (class 1255 OID 16490)
-- Name: funct_change_colaborador_accesso_reativar(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_accesso_reativar(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa função serve para reativar um colaborador
        * Na reativação do colaborador sera gerado um token de ativação

      args := {
        arg_colaborador_id: ID,
        arg_colaborador_reative: ID,
        arg_colaborador_senha: SENHA,
        arg_colaborador_pin: PIN,
        arg_start:BOOLEAN
      }
      -- argumentos
        -- arg_colaborador_id corresponde ao colaborador logado no sistema que esta efetuar a operação de ativação
        -- arg_colaborador_reative corresponde ao colaborador que tera o acesso reativo no sistema.
     */

    arg_colaborador_id uuid := args->>'arg_colaborador_id';
    arg_colaborador_reative uuid := args->>'arg_colaborador_reative';
    arg_colaborador_senha varchar default args->>'arg_colaborador_senha';
    arg_colaborador_pin varchar default args->>'arg_colaborador_pin';
    arg_start boolean := args->>'arg_start';

    arg_token_senha boolean default false;
    arg_token_pin boolean default false;
    _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_reative );
    _const map.constant;
begin
    _const := map.constant();
    arg_start := coalesce( arg_start, false );

    -- Um colaborador já ativo não pode ser novamente reativado
    if _colaborador.colaborador_estado != _const.colaborador_estado_ativo then
        return lib.result_false( '@auth.colaborador.active-active' );
    end if;

    if arg_start and arg_colaborador_senha is not null then
      _colaborador.colaborador_senhamodo := _const.colaborador_chavemodo_utilizador;

    elsif arg_start and arg_colaborador_pin is not null then
      _colaborador.colaborador_pinmodo := _const.colaborador_chavemodo_utilizador;

    elseif not arg_start then
      _colaborador.colaborador_senhamodo := _const.colaborador_chavemodo_padrao;
      if arg_colaborador_senha is null then
          arg_token_senha := true;
          _colaborador.colaborador_senhamodo := _const.colaborador_chavemodo_gerado;
          arg_colaborador_senha := auth._colaborador_generate_senha_token();
      end if;

      _colaborador.colaborador_pinmodo := _const.colaborador_chavemodo_padrao;
      if arg_colaborador_pin is null then
        _colaborador.colaborador_pinmodo := _const.colaborador_chavemodo_gerado;
        arg_token_pin := true;
        arg_colaborador_pin := auth._colaborador_generate_pin_token();
      end if;
    end if;

    if arg_start then
      _colaborador.colaborador_token := null;
      _colaborador.colaborador_tokenlimit := null;
      _colaborador.colaborador_accesso := _const.colaborador_accesso_ativo;
    else
      _colaborador.colaborador_accesso := _const.colaborador_accesso_pendente;
    end if;

    update auth.colaborador
      set colaborador_accesso = _colaborador.colaborador_accesso,
        colaborador_estado = _const.colaborador_estado_ativo,

        colaborador_senhamodo = _colaborador.colaborador_senhamodo,
        colaborador_senha = case
            when arg_colaborador_senha is not null then auth._encrypt( arg_colaborador_senha )
            else colaborador_senha
          end,

        colaborador_pinmodo = _colaborador.colaborador_pinmodo,
        colaborador_pin = case
            when arg_colaborador_pin is not null then auth._encrypt( arg_colaborador_pin )
            else colaborador_pin
          end,

        colaborador_dataultimaatualizacasenha = now(),
        colaborador_token = _colaborador.colaborador_token,
        colaborador_tokenlimit = _colaborador.colaborador_tokenlimit,

        colaborador_colaborador_atualizacao = arg_colaborador_id,
        colaborador_dataatualizacao = now()
      where colaborador_id = arg_colaborador_reative
      returning * into _colaborador
    ;

    return lib.result_true(
      jsonb_build_object(
        'colaborador_token', case
          when arg_token_senha then auth._colaborador_token_encrypt( _colaborador )
        end,

        'colaborador_pin', case
          when arg_token_pin then arg_colaborador_pin
        end
      )
    );
end;
$$;


--
-- TOC entry 616 (class 1255 OID 16491)
-- Name: funct_change_colaborador_estado_disable(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_estado_disable(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
    /**
    Essa função serve para disativar o estaod de um dado colaborador no sistema
    args := {
      arg_colaborador_id: ID,
      arg_colaborador_disable: ID
    }
    -- argumentos
      arg_colaborador_id corresponde ao colaborador logado no sistema que esta a efetuar a operação de desativação
      arg_colaborador_disable corresponde ao colaborador que tera o acesso desabilitado do sistema
   */

    arg_colaborador_id uuid := args->>'arg_colaborador_id';
    arg_colaborador_disable uuid := args->>'arg_colaborador_disable';
    _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_disable );
    _const map.constant;
begin

   -- Um colaborador master não pode ser desabilitado do sistema
  if _colaborador.colaborador_tipo = _const.colaborador_tipo_user_master then
    return lib.result_false( 'auth.colaborador.disable-master' );
  end if;

  update auth.colaborador
    set colaborador_accesso = _const.colaborador_accesso_fechado,
        colaborador_estado = _const.colaborador_estado_fechado,
        colaborador_colaborador_atualizacao = arg_colaborador_id,
        colaborador_dataatualizacao = current_timestamp
    where colaborador_id = arg_colaborador_disable
    returning * into _colaborador;

  return lib.result_true(
    jsonb_build_object(
      'colaborador', _colaborador
    )
  );
end;
$$;


--
-- TOC entry 617 (class 1255 OID 16492)
-- Name: funct_change_colaborador_pin(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_pin(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para alterar a senha de um colaborador autenticado

    -- argumentos
      args := {
        arg_colaborador_id: ID,
        arg_colaborador_senha: OLD-PIN,
        arg_colaborador_pin: PIN
      }
      arg_colaborador_id corresponde ao identificador do colaborador que esta a alterar a sua propia senha
      arg_colaborador_senha corresponde a antiga senha do colaborador
      arg_colaborador_pin corresponde a nova senha do colaboarador
  */
  arg_colaborador_id uuid                      := args->>'arg_colaborador_id';
  arg_colaborador_senha character varying  := args->>'arg_colaborador_senha';
  arg_colaborador_pin character varying  := args->>'arg_colaborador_pin';
  _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_id );
  _const map.constant;

begin

  _const := map.constant();

  -- A antiga senha do colaborador tem que bater igual senha atual cadastrada na base de dados
  if auth._encrypt( arg_colaborador_senha ) not in ( _colaborador.colaborador_pin ) then
    return lib.result_false( 'PIN atual inválida!' );
  end if;

  -- A nova senha tem que ser uma senha diferente da senha antiga
  if _colaborador.colaborador_pin = auth._encrypt( arg_colaborador_pin ) then
    return lib.result_false( 'Novo PIN tem que ser diferente do PIN atual!' );
  end if;

  update auth.colaborador
    set colaborador_pin = auth._encrypt( arg_colaborador_pin ),
        colaborador_dataultimaatualizacasenha = now(),
        colaborador_dataatualizacao = now(),
        colaborador_colaborador_atualizacao = arg_colaborador_id,
        colaborador_pinmodo = _const.colaborador_chavemodo_utilizador,
        colaborador_accesso = _const.colaborador_accesso_ativo
    where colaborador_id = arg_colaborador_id
  ;

  return lib.result_true( 'success' );
end;
$$;


--
-- TOC entry 618 (class 1255 OID 16493)
-- Name: funct_change_colaborador_senha(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_senha(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para alterar a senha de um colaborador autenticado

      args := {
        arg_colaborador_id: ID,
        arg_colaborador_senhaold: SENHA,
        arg_colaborador_senhanew: SENHA
      }
    -- argumentos
      arg_colaborador_id corresponde ao identificador do colaborador que esta a alterar a sua propia senha
      arg_colaborador_senhaold corresponde a antiga senha do colaborador
      arg_colaborador_senhanew corresponde a nova senha do colaboarador
  */
  arg_colaborador_id uuid                      := args->>'arg_colaborador_id';
  arg_colaborador_senhaold character varying  := args->>'arg_colaborador_senhaold';
  arg_colaborador_senhanew character varying  := args->>'arg_colaborador_senhanew';
  _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_id );
  _const map.constant;

begin
  _const := map.constant();

  -- A antiga senha do colaborador tem que bater igual senha atual cadastrada na base de dados
  if _colaborador.colaborador_senha != auth._encrypt( arg_colaborador_senhaold ) then
    return lib.result_false( 'Palavra-passe atual inválida!' );
  end if;

  -- A nova senha tem que ser uma senha diferente da senha antiga
  if _colaborador.colaborador_senha = auth._encrypt( arg_colaborador_senhanew ) then
    return lib.result_false( 'Nova palavra-passe tem que ser diferente da palavra-passe atual!' );
  end if;

  update auth.colaborador
    set colaborador_senha = auth._encrypt( arg_colaborador_senhanew ),
        colaborador_dataultimaatualizacasenha = now(),
        colaborador_dataatualizacao = now(),
        colaborador_colaborador_atualizacao = arg_colaborador_id,
        colaborador_senhamodo = _const.colaborador_chavemodo_utilizador
    where colaborador_id = arg_colaborador_id
  ;

  return lib.result_true( 'success' );
end;
$$;


--
-- TOC entry 619 (class 1255 OID 16494)
-- Name: funct_change_colaborador_token_acesso(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_token_acesso(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para recria o token de ativacao de conta de um colaborador
    -- Quando um utilizador perder a senha dever ser usada essa função para a recupereção da sua senha.

    -- argumentos
      -- arg_colaborador_email corresponde ao email do colaborador que pretende recuperar a senha
  */

  arg_colaborador_email character varying := args->>'arg_colaborador_email';

  arg_colaborador_token character varying;

  _const constant map.constant := map.constant();
  _colaborador auth.colaborador;
  _tsexo auth.tsexo;

begin
    arg_colaborador_email := lower( lib.str_normalize( arg_colaborador_email  ) );
    select  * into _colaborador
      from auth.colaborador co
      where co.colaborador_email = arg_colaborador_email
    ;

    if _colaborador.colaborador_estado != _const.colaborador_estado_ativo
      or  _colaborador.colaborador_accesso not in ( _const.colaborador_accesso_ativo, _const.colaborador_accesso_pendente )
    then
      return lib.result_false( '@auth.colaborador.acesso-can-not-active' );
    end if;

    if _colaborador.colaborador_id is null then
      return lib.result_false( '@auth.colaborador.mail-not-found' );
    end if;

    arg_colaborador_token := auth._colaborador_generate_senha_token()
                                 ||auth._colaborador_generate_pin_token();

    update auth.colaborador
      set colaborador_token = arg_colaborador_token,
          colaborador_tokenlimit = current_timestamp + _const.colaborador_token_limit,
          colaborador_dataatualizacao = current_timestamp
      where colaborador_id = _colaborador.colaborador_id
      returning * into _colaborador;

    select * into _tsexo
        from auth.tsexo sx
        where sx.tsexo_id = _colaborador.colaborador_tsexo_id;

    return lib.result_true(
      jsonb_build_object(
        'colaborador', jsonb_build_object(
          'colaborador_nome', _colaborador.colaborador_nome,
          'colaborador_apelido', _colaborador.colaborador_apelido,
          'tsexo_id', _tsexo.tsexo_id,
          'tsexo_nome', _tsexo.tsexo_nome,
          'colaborador_email', _colaborador.colaborador_email
        ),
        'colaborador_token', auth._colaborador_token_encrypt( _colaborador )
      )
    );
  end;
$$;


--
-- TOC entry 620 (class 1255 OID 16495)
-- Name: funct_change_colaborador_token_ativate(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_colaborador_token_ativate(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para ativar um colaborador quando tem token ativo
    Na ativação a senha ser definida, o acesso passara a ser ativo e o token deixara de existir

   */

  arg_colaborador_id integer              := args->>'arg_colaborador_id';
  arg_colaborador_token character varying := args->>'arg_colaborador_token';
  arg_colaborador_senha character varying  := args->>'arg_colaborador_senha';
  arg_colaborador_pin character varying  := args->>'arg_colaborador_pin';


  _const map.constant := map.constant();
  _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_id := arg_colaborador_id );
begin
  if _colaborador.colaborador_token is null then
    return lib.result_false( '@auth.colaborador.token-not-found' );
  end if;

  if _colaborador.colaborador_estado != _const.colaborador_estado_ativo
    or  _colaborador.colaborador_accesso not in ( _const.colaborador_accesso_ativo, _const.colaborador_accesso_pendente )
  then
    return lib.result_false( 'auth.colaborador.acesso-can-not-active' );
  end if;

  if auth._colaborador_token_encrypt( _colaborador ) != arg_colaborador_token then
    return lib.result_false( '@auth.colaborador.token-invalid' );
  end if;

  -- Ativar o colaborador
  update auth.colaborador
    set
      colaborador_accesso = _const.colaborador_accesso_ativo,
      colaborador_token = null,
      colaborador_tokenlimit = null,
      colaborador_senha = auth._encrypt( arg_colaborador_senha ),
      colaborador_pin = auth._encrypt( arg_colaborador_pin ),
      colaborador_pinmodo = _const.colaborador_chavemodo_utilizador,
      colaborador_senhamodo = _const.colaborador_chavemodo_utilizador,
      colaborador_dataultimaatualizacasenha = now(),
      colaborador_dataatualizacao = now(),
      colaborador_colaborador_atualizacao = arg_colaborador_id
    where colaborador_id = arg_colaborador_id
  ;

  return lib.result_true( 'sucesso' );

end;
$$;


--
-- TOC entry 621 (class 1255 OID 16496)
-- Name: funct_change_perfil(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_change_perfil(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para modificar dos dados do perfil como o nome
    --args
      -- arg_colaborador_id corresponde ao identificador do colaborador responsavel pelo atualização do perfil
      -- arg_perfil_id corresponed ao identificador do perfil que tera as informações alterada
      -- arg_perfil_nome corresponde ao novo nome para o perfil
   */

  arg_colaborador_id uuid           := args ->>'arg_colaborador_id';
  arg_perfil_id uuid                := args ->>'arg_perfil_id';
  arg_menu jsonb                    := args ->>'arg_menus';
  arg_perfil_nome character varying := args ->>'arg_perfil_nome';

  _const map.constant;
  _perfil auth.perfil;
  _res lib.result;
begin
  _const := map.constant();
  _perfil := auth._get_perfil( arg_perfil_id );

  arg_perfil_nome := lib.str_normalize( arg_perfil_nome );

  -- para os perfil com código não pode ter as informações alteradas
  if _perfil.perfil_codigo is not null then
    return lib.result_false( '@auth.perfil.codigo.locked' );
  end if;

  update auth.perfil
    set perfil_nome = arg_perfil_nome,
        perfil_colaborador_atualizacao = arg_colaborador_id,
        perfil_dataatualizacao = current_timestamp
    where perfil_id = arg_perfil_id
  ;

  _res := auth.funct_reg_privilegio( args );
  _res.message := _res.message || jsonb_build_object(
    'perfil', _perfil
  );

  return _res;

end;
$$;


--
-- TOC entry 622 (class 1255 OID 16497)
-- Name: funct_load_colaborador(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_colaborador(filter jsonb) RETURNS TABLE(colaborador_id uuid, colaborador_nome character varying, colaborador_apelido character varying, colaborador_mail character varying, colaborador_estado smallint, colaborador_estadodesc character varying, colaborador_acesso smallint, colaborador_acessodesc character varying, colaborador_foto character varying, sexo_id smallint, sexo_nome character varying, sexo_codigo character, colaborador_datanascimento date, colaborador_nif character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função sere para carregar os colaborador apartir dos filtros expecificados
   */
  arg_colaborador_email character varying default filter->>'arg_colaborador_email';
  arg_colaborador_nif character varying default filter->>'arg_colaborador_nif';
  _const map.constant;
begin
  _const :=  map.constant();

  return query
    select co.colaborador_id,
        co.colaborador_nome,
        co.colaborador_apelido,
        co.colaborador_email,
        co.colaborador_estado,
        auth._colaborador_estado_desc( co.colaborador_estado ),
        co.colaborador_accesso,
        auth._colaborador_accesso_desc( co.colaborador_accesso ),
        co.colaborador_foto,
        s2.tsexo_id,
        s2.tsexo_nome,
        s2.tsexo_codigo,
        co.colaborador_datanascimento,
        co.colaborador_nif
      from auth.colaborador co
        left join auth.tsexo s2 ON co.colaborador_tsexo_id = s2.tsexo_id
      where co.colaborador_tipo in ( _const.colaborador_tipo_user, _const.colaborador_tipo_user_master )
        and co.colaborador_email = coalesce( arg_colaborador_email, co.colaborador_email )
        and co.colaborador_nif = coalesce( arg_colaborador_nif, co.colaborador_nif )
      order by
        case
          when co.colaborador_accesso = _const.colaborador_accesso_ativo then 1
          when co.colaborador_accesso = _const.colaborador_accesso_pendente then 2
          when co.colaborador_accesso = _const.colaborador_accesso_fechado then 3
        end asc,
        co.colaborador_nome,
        co.colaborador_apelido
      ;
end;
$$;


--
-- TOC entry 623 (class 1255 OID 16498)
-- Name: funct_load_colaborador_all_menu(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_colaborador_all_menu(filter jsonb) RETURNS TABLE(colaborador_id uuid, colaborador_nome character varying, colaborador_apelido character varying, colaborador_foto character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver os colaboradores que tenham o conjunto de menu especificado
    filter := {
      arg_colaborador_id: ID
      arg_menus: [
        menu_codigo,
        menu_codigo,
        menu_codigo
      ]
    }
  **/
  arg_colaborador_id uuid default filter->>'arg_colaborador_id';
  args_menus varchar[ ] := array( select distinct doc.menu_codigo from jsonb_array_elements_text( filter->'arg_menus' ) doc( menu_codigo ) );
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
        co.colaborador_id,
        co.colaborador_nome,
        co.colaborador_apelido,
        co.colaborador_foto
      from auth.colaborador co
        inner join auth.acesso acc on co.colaborador_id = acc.acesso_colaborador_propetario
        inner join auth.menu men on acc.acesso_menu_id = men.menu_id
      where acc.acesso_estado = _const.acesso_estado_ativo
        and co.colaborador_estado = _const.colaborador_estado_ativo
        and co.colaborador_id = coalesce( arg_colaborador_id, co.colaborador_id )
      group by co.colaborador_id
      having array_agg( men.menu_codigo ) @> args_menus
      order by co.colaborador_dataultimologin desc nulls last,
        co.colaborador_nome,
        co.colaborador_apelido
  ;
end;
$$;


--
-- TOC entry 624 (class 1255 OID 16499)
-- Name: funct_load_colaborador_any_menu(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_colaborador_any_menu(filter jsonb) RETURNS TABLE(colaborador_id uuid, colaborador_nome character varying, colaborador_apelido character varying, colaborador_foto character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver os colaboradores que tenha pelo menos um menu especificado
    filter := {
      arg_colaborador_id: ID,
      arg_menus: [
        menu_codigo,
        menu_codigo,
        menu_codigo
      ]
    }
  **/
  arg_colaborador_id uuid default filter->>'arg_colaborador_id';
  args_menus varchar[ ] := array( select distinct doc.menu_codigo from jsonb_array_elements_text( filter->'arg_menus' ) doc( menu_codigo ) );
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
        co.colaborador_id,
        co.colaborador_nome,
        co.colaborador_apelido,
        co.colaborador_foto
      from auth.colaborador co
        inner join auth.acesso acc on co.colaborador_id = acc.acesso_colaborador_propetario
        inner join auth.menu men on acc.acesso_menu_id = men.menu_id
      where acc.acesso_estado = _const.acesso_estado_ativo
        and co.colaborador_estado = _const.colaborador_estado_ativo
        and men.menu_codigo = any( args_menus )
        and co.colaborador_id = coalesce( arg_colaborador_id, co.colaborador_id )
      group by co.colaborador_id
      having count( men.menu_id ) > 0
      order by
       co.colaborador_dataultimologin  desc nulls last,
       co.colaborador_nome,
       co.colaborador_apelido
  ;
end;
$$;


--
-- TOC entry 625 (class 1255 OID 16500)
-- Name: funct_load_colaborador_by_token(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_colaborador_by_token(args jsonb) RETURNS TABLE(colaborador_id uuid, colaborador_nome character varying, colaborador_apelido character varying, colaborador_mail character varying, colaborador_nif character varying, colaborador_foto character varying, colaborador_ficha jsonb, tsexo_id smallint, tsexo_nome character varying, tsexo_codigo character)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para devolver as informações de um colaborador apartir do seu token de acesso
    O tokem a ser devolvido tem que estar no prazo

    -- argumentos
      -- arg_colaborador_token corresponde ao token encripitado do colaborador
   */

  arg_colaborador_token character varying := args->>'arg_colaborador_token';
begin
  return query
    select
      co.colaborador_id,
      co.colaborador_nome,
      co.colaborador_apelido,
      co.colaborador_email,
      co.colaborador_foto,
      co.colaborador_nif,
      co.colaborador_ficha,
      sx.tsexo_id,
      sx.tsexo_nome,
      sx.tsexo_codigo
    from auth.colaborador co
      left join auth.tsexo sx on co.colaborador_tsexo_id = sx.tsexo_id
    where auth._colaborador_token_encrypt( co ) = arg_colaborador_token
      and co.colaborador_tokenlimit >= current_timestamp
  ;
end;
$$;


--
-- TOC entry 565 (class 1255 OID 16501)
-- Name: funct_load_colaborador_simple(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_colaborador_simple(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(colaborador_id uuid, colaborador_nome character varying, colaborador_apelido character varying, colaborador_nomecompleto character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para carregar os colaboradores
   */
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
        co.colaborador_id,
        co.colaborador_nome,
        co.colaborador_apelido,
        format( '%s %s',co. colaborador_nome, co.colaborador_apelido )::character varying
      from auth.colaborador co
      where co.colaborador_estado != _const.colaborador_estado_fechado
        and co.colaborador_tipo != _const.colaborador_tipo_system
  ;
end;
$$;


--
-- TOC entry 597 (class 1255 OID 16502)
-- Name: funct_load_colaborador_token_restore(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_colaborador_token_restore(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para recuperar o token do acesso do colaborador ao sistema.
    -- argumentos
      -- arg_colaborador_restore identificador do colaborador a qual pretente restaurar o token de ativação
   */

  arg_colaborador_restore uuid := args->>'arg_colaborador_id';

  _const map.constant;
  _colaborador auth.colaborador;
begin
    _const := map.constant();
    _colaborador := auth._get_colaborador( arg_colaborador_restore );

  if _colaborador.colaborador_token is null
    or _colaborador.colaborador_tokenlimit is null
    or _colaborador.colaborador_tokenlimit < current_timestamp
  then
    return lib.result_false( 'auth.colaborador.token-not-restore' );
  end if;

  return lib.result_true(
    jsonb_build_object(
      'colaborador_token', auth._colaborador_token_encrypt( _colaborador )
    )
  );
end;
$$;


--
-- TOC entry 568 (class 1255 OID 16503)
-- Name: funct_load_grants(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_grants(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    menus: [ID, ID] || null
    colaborador_id: UID
   */
  _menu int[];
  _const map.constant;
  useMenu jsonb default args->'menus';
  _colaborador_id uuid default args->>'colaborador_id';

begin
  _const := map.constant();

  if jsonb_typeof( useMenu ) != 'array' then useMenu := null; end if;

  if useMenu is null or jsonb_array_length( useMenu ) = 0 then
    _menu := array(
        select me.menu_id
        from auth.menu me
      );
  else
    _menu := array(
        select e.text::int
        from jsonb_array_elements_text( useMenu ) e( text )
      );
  end if;

  return query
    select  to_jsonb( ac ) || to_jsonb( me )
      from auth.menu me
        inner join auth.acesso ac on me.menu_id = ac.acesso_menu_id
      where ac.acesso_estado = _const.acesso_estado_ativo
        and ac.acesso_colaborador_propetario = _colaborador_id
        and me.menu_id = any( _menu )
      order by me.menu_position
  ;
end;
$$;


--
-- TOC entry 604 (class 1255 OID 16504)
-- Name: funct_load_menu(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_menu(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(menu_id smallint, menu_codigo character varying, menu_raiz character varying, menu_nivel smallint, menu_icon character varying, menu_nome character varying, menu_link character varying, menu_estado smallint, menu_children smallint, menu_maxnode smallint, menu_directchildern smallint, menu_position smallint, menu_falta boolean, menu_mais boolean, menu_sincronizado boolean, acesso_id uuid, perfil_id uuid, menu_menu_id smallint, menu_menu_codigo character varying, menu_menu_raiz character varying, menu_menu_nivel smallint, menu_menu_icon character varying, menu_menu_nome character varying, menu_menu_link character varying, menu_menu_estado smallint, menu_menu_children smallint, menu_menu_maxnode smallint, menu_menu_directchildern smallint, menu_menu_position smallint)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função carrega os menus e faz um mach entre e perfil e o colaborador
    -- argumentos
      -- arg_colaborador_id identificador do colaborador o qual pretende-se obter os menus (opcional)
      -- arg_perfil_id identificador do perfil o qual pretende-se obter os menus (opcional)
      -- arg_allmenu boolean | quando true significa carregar todos os menus independete mente se o colaborador
        ou menu estiver associado ao mesmo
   */
  arg_colaborador_id uuid := filter->>'arg_colaborador_id';
  arg_perfil_id uuid := filter->>'arg_perfil_id';
  arg_allmenu boolean := filter->>'arg_allmenu';

  _const map.constant;
begin
    _const := map.constant();
  -- Quando o filtro não for expecificado carregar todos os menus
  arg_allmenu := coalesce( arg_allmenu, true );


  return query
    select
        me.menu_id                ,
        me.menu_codigo            ,
        me.menu_raiz              ,
        me.menu_nivel             ,
        me.menu_icon              ,
        me.menu_nome              ,
        me.menu_link              ,
        me.menu_estado            ,
        me.menu_children          ,
        me.menu_maxnode           ,
        me.menu_directchildern    ,
        me.menu_position          ,

        ac.acesso_id is null and perf.perfil_id is not null,
        ac.acesso_id is not null and perf.perfil_id is null,
        ac.acesso_id is not null and perf.perfil_id is not null,

        ac.acesso_id              ,
        perf.perfil_id,

        super.menu_id             ,
        super.menu_codigo         ,
        super.menu_raiz           ,
        super.menu_nivel          ,
        super.menu_icon           ,
        super.menu_nome           ,
        super.menu_link           ,
        super.menu_estado         ,
        super.menu_children       ,
        super.menu_maxnode        ,
        super.menu_directchildern ,
        super.menu_position

      from auth.menu me
        left join auth.menu super on me.menu_menu_id = super.menu_id
        left join auth.acesso ac on me.menu_id = ac.acesso_menu_id
          and ac.acesso_estado = _const.acesso_estado_ativo
          and ac.acesso_colaborador_propetario = arg_colaborador_id
        left join auth.colaborador col on ac.acesso_colaborador_propetario = col.colaborador_id
        left join auth.privilegio pri on me.menu_id = pri.privilegio_menu_id
          and pri.privilegio_estado = _const.privilegio_estado_ativo
        left join auth.perfil perf on pri.previlegio_perfil_id = perf.perfil_id
          and perf.perfil_estado = _const.perfil_estado_ativo
          and perf.perfil_id = arg_perfil_id
      where me.menu_estado = _const.menu_estado_ativo
        and (
          ac.acesso_id is not null
            or perf.perfil_id is not null
            or col.colaborador_tipo = _const.colaborador_tipo_user_master -- para os colaboradores master carregar dodos os menus disponiveis
            or arg_allmenu
        )
      order by me.menu_position
  ;
end;
$$;


--
-- TOC entry 605 (class 1255 OID 16505)
-- Name: funct_load_menu_cascade(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_load_menu_cascade(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(menu_id smallint, menu_menu_id smallint, menu_codigo character varying, menu_raiz character varying, menu_nivel smallint, menu_icon character varying, menu_nome character varying, menu_link character varying, menu_estado smallint, menu_children smallint, menu_maxnode smallint, menu_directchildern smallint, menu_position smallint, menu_falta boolean, menu_mais boolean, menu_sincronizado boolean, acesso_id uuid, perfil_id uuid, menu_childrenlist jsonb)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função carrega os menus e faz um mach entre e perfil e o colaborador
    args := {
      arg_colaborador_id: ID,
      arg_perfil_id: ID,
      arg_allmenu: TRUE | FALSE
    }
    -- argumentos
      -- arg_colaborador_id identificador do colaborador o qual pretende-se obter os menus (opcional)
      -- arg_perfil_id identificador do perfil o qual pretende-se obter os menus (opcional)
      -- arg_allmenu boolean | quando true significa carregar todos os menus independete mente se o colaborador
        ou menu estiver associado ao mesmo
   */
  arg_colaborador_id uuid := filter->>'arg_colaborador_id';
  arg_perfil_id uuid := filter->>'arg_perfil_id';
  arg_allmenu boolean := filter->>'arg_allmenu';

  _const constant map.constant := map.constant();
begin
  arg_allmenu := coalesce( arg_allmenu, false );

  -- Quando o filtro não for expecificado carregar todos os menus
  if filter is null then arg_allmenu := true; end if;

  return query
    with menu_colaborador as (
      select
        me.menu_id                ,
        me.menu_menu_id           ,
        me.menu_codigo            ,
        me.menu_raiz              ,
        me.menu_nivel             ,
        me.menu_icon              ,
        me.menu_nome              ,
        me.menu_link              ,
        me.menu_estado            ,
        me.menu_children          ,
        me.menu_maxnode           ,
        me.menu_directchildern    ,
        me.menu_position          ,

        ac.acesso_id is null and perf.perfil_id is not null as menu_falta,
        ac.acesso_id is not null and perf.perfil_id is null as menu_mais,
        ac.acesso_id is not null and perf.perfil_id is not null as menu_sincronizado,
        ac.acesso_id              ,
        perf.perfil_id

      from auth.menu me
             left join auth.menu super on me.menu_menu_id = super.menu_id
             left join auth.acesso ac on me.menu_id = ac.acesso_menu_id
        and ac.acesso_estado = _const.acesso_estado_ativo
        and ac.acesso_colaborador_propetario = arg_colaborador_id
             left join auth.colaborador col on ac.acesso_colaborador_propetario = col.colaborador_id
             left join auth.privilegio pri on me.menu_id = pri.privilegio_menu_id
        and pri.privilegio_estado = _const.privilegio_estado_ativo
             left join auth.perfil perf on pri.previlegio_perfil_id = perf.perfil_id
        and perf.perfil_estado = _const.perfil_estado_ativo
        and perf.perfil_id = arg_perfil_id
      where me.menu_estado = _const.menu_estado_ativo
        and (
          ac.acesso_id is not null
          or perf.perfil_id is not null
          or col.colaborador_tipo = _const.colaborador_tipo_user_master -- para os colaboradores master carregar dodos os menus disponiveis
          or arg_allmenu
        )
      order by me.menu_position asc
    ) select mc.*,
        jsonb_agg( to_jsonb( child ) ) filter ( where child.menu_id is not null ) menu_childrenlist
      from menu_colaborador mc
        left join menu_colaborador child on mc.menu_id = child.menu_menu_id
      where mc.menu_menu_id is null
      group by
        mc.menu_id,
        mc.menu_menu_id,
        mc.menu_codigo,
        mc.menu_raiz,
        mc.menu_nivel,
        mc.menu_icon,
        mc.menu_nome,
        mc.menu_link ,
        mc.menu_estado,
        mc.menu_children,
        mc.menu_maxnode,
        mc.menu_directchildern,
        mc.menu_position,
        mc.menu_falta,
        mc.menu_mais ,
        mc.menu_sincronizado,
        mc.acesso_id,
        mc.perfil_id
      order by mc.menu_position asc
  ;
end;
$$;


--
-- TOC entry 626 (class 1255 OID 16506)
-- Name: funct_reg_acesso(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_reg_acesso(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para dar acesse de um menu ao um colaborador
    -- Para dar acess o colaborador não pode ter previamente o acesso ao menu
    args := {
      arg_colaborador_id: ID,
      _branch_uid: UID
      arg_colaborador_propetario: ID,
      arg_menu_list: [
        ID, ID, ID
      ]
    }
      -- arg_colaborador_id corresponde ao colaborador que esta a definir os previlegio de acesso
      -- arg_colaborador_propetario corresponde ao colaborador que tera o acesso definido
      -- arg_menu_ids corresponde a lista de identificadores do menus que o colaborador tera acesso
   */

  arg__branch_uid uuid          := args->>'_branch_uid';
  arg_colaborador_id uuid          := args->>'arg_colaborador_id';
  arg_colaborador_propetario uuid  := args->>'arg_colaborador_propetario';
  arg_menu_list int2[]                := array( select jsonb_array_elements_text( args->'arg_menu_list' )::int2 );

  arg_acesso_lista auth.acesso[];

  _const map.constant;
begin

    _const := map.constant();

  -- Revogar os menus que o colaborador tinha acesso anteriormente mas atualmente já nao os têm
  -- São menus que aperecem no acesso ativo mas nao aperencem na nova lista de menus a ser dado ao colaborador
  update auth.acesso
    set acesso_estado = _const.acesso_estado_fechado,
        acesso_dataatualizacao = current_timestamp,
        acesso_colaborador_atualizacao = arg_colaborador_id
    where acesso_estado = _const.acesso_estado_ativo
      and acesso_colaborador_propetario = arg_colaborador_propetario
      and acesso_menu_id != all( arg_menu_list )
      and _branch_uid = arg__branch_uid
  ;

  -- Registrar para o colaborador apenas menus listado na lista que estão em faltas
  insert into auth.acesso(
    acesso_menu_id,
    acesso_colaborador_propetario,
    acesso_colaborador_id,
    _branch_uid
  ) select
      me.menu_id,
      arg_colaborador_propetario,
      arg_colaborador_id,
      arg__branch_uid
    from unnest( arg_menu_list ) un ( menu_id )
      inner join auth.menu me on un.menu_id = me.menu_id
      left join auth.acesso ac on me.menu_id = ac.acesso_menu_id
        and ac.acesso_estado = _const.acesso_estado_ativo
        and ac.acesso_colaborador_propetario = arg_colaborador_propetario
    where ac.acesso_id is null
  ;

  -- Obter todos os acessos ativos para esse colaborador
  select array_agg( ac ) into arg_acesso_lista
    from auth.acesso ac
    where ac.acesso_colaborador_propetario = arg_colaborador_propetario
      and ac.acesso_estado = _const.acesso_estado_ativo
  ;

  return lib.result_true(
    jsonb_build_object(
      'acesso', arg_acesso_lista
    )
  );

end;
$$;


--
-- TOC entry 627 (class 1255 OID 16507)
-- Name: funct_reg_colaborador(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_reg_colaborador(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para cadastra novos colaboradores
    Ao cadastar o colaborador a senha é atribuida automaticamente em um random
    E gerado tambem um token que devera ser enviado pela aplicao ao email do colaborador cadastrado
    O email e o NIF tem que ser unico
    args := {
      arg_colaborador_id: ID,
      arg_colaborador_email: EMAIL,
      arg_colaborador_nome: NOME,
      arg_colaborador_apelido: APELIDO,
      arg_colaborador_nif: NIF,
      arg_colaborador_datanascimento: DATA,
      arg_colaborador_ficha: FICHA,
      arg_colaborador_foto: FICHA,
      arg_tsexo_id: ID,

      arg_colaborador_senha: DEFAULT_SENHA_IF_EXIST,
      arg_colaborador_pin: DEFAULT_PIN_IF_SET,
    }

   */
  arg_colaborador_id uuid                := args->>'arg_colaborador_id';
  arg_colaborador_email character varying   := args->>'arg_colaborador_email';
  arg_colaborador_nome character varying    := args->>'arg_colaborador_nome';
  arg_colaborador_apelido character varying := args->>'arg_colaborador_apelido';
  arg_colaborador_nif character varying     := args->>'arg_colaborador_nif';
  arg_colaborador_datanascimento date       := args->>'arg_colaborador_datanascimento';
  arg_colaborador_ficha jsonb               := args->>'arg_colaborador_ficha';
  arg_colaborador_foto varchar               := args->>'arg_colaborador_foto';
  arg_tsexo_id int2                         := args->>'arg_tsexo_id';
  arg_colaborador_token text;
  arg_menu_list jsonb                       := args->>'arg_menu_list';
  arg_colaborador_pin varchar               := args->>'arg_colaborador_pin';
  arg_colaborador_senha varchar             := args->>'arg_colaborador_senha';


  _const map.constant := map.constant();
  _colaborador auth.colaborador;
  _res lib.result;

begin
  -- normalizar os dados do colaborador
  arg_colaborador_email := lower( lib.str_normalize( arg_colaborador_email ) );
  arg_colaborador_nif := lower( lib.str_normalize( arg_colaborador_nif ) );
  arg_colaborador_nome := lib.str_normalize( arg_colaborador_nome );
  arg_colaborador_apelido := lib.str_normalize( arg_colaborador_apelido );

  -- As informacoes do tipo texto tem que estar normalizados
  if arg_colaborador_email is null then
    return lib.result_false( '@auth.colaborador.invalid-mail' );
  end if;

  if arg_colaborador_nome is null then
    return lib.result_false( '@auth.colaborador.invalid-name' );
  end if;

  -- Garantir que nao exista o  NIF
  if (
    select count( * )
      from auth.colaborador co
      where co.colaborador_email =  arg_colaborador_email
  ) > 0 then
    return lib.result_false( '@auth.colaborador.email-exist' );
  end if;

  -- Garantir que o nif seja unico
  if (
    select count( * )
      from auth.colaborador co
      where co.colaborador_nif = arg_colaborador_nif
  ) > 0 then
    return lib.result_false( '@auth.colaborador.nif-exist' );
  end if;

  insert into auth.colaborador(
    colaborador_colaborador_id,
    colaborador_email,
    colaborador_nome,
    colaborador_apelido,
    colaborador_nif,
    colaborador_datanascimento,
    colaborador_foto,
    colaborador_tsexo_id
  ) values (
    arg_colaborador_id,
    arg_colaborador_email,
    arg_colaborador_nome,
    arg_colaborador_apelido,
    arg_colaborador_nif,
    arg_colaborador_datanascimento,
    arg_colaborador_foto,
    arg_tsexo_id
  ) returning * into _colaborador;

  perform auth.funct_reg_acesso(
    jsonb_build_object(
      'arg_colaborador_id', arg_colaborador_id,
      'arg_colaborador_propetario', _colaborador.colaborador_id,
      'arg_menu_list', arg_menu_list
    )
  );

  _res := auth.funct_change_colaborador_accesso_reativar(
    jsonb_build_object(
      'arg_colaborador_id', arg_colaborador_id,
      'arg_colaborador_reative', _colaborador.colaborador_id,
      'arg_colaborador_senha', arg_colaborador_senha,
      'arg_colaborador_pin', arg_colaborador_pin
    )
  );


  return lib.result_true(
    jsonb_build_object(
      'colaborador',
        lib.jsonb_values(
          to_jsonb( _colaborador ),
          'colaborador_id',
          'colaborador_tsexo_id',
          'colaborador_email',
          'colaborador_nif',
          'colaborador_nome',
          'colaborador_apelido',
          'colaborador_datanascimento',
          'colaborador_ficha',
          'colaborador_dataultimaatualizacasenha',
          'colaborador_accesso',
          'colaborador_estado',
          'colaborador_dataregisto'
        )
    ) || _res.message
  );
end;
$$;


--
-- TOC entry 628 (class 1255 OID 16508)
-- Name: funct_reg_perfil(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_reg_perfil(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registar um novo tipo de perfil dos colaboradores
    -- paramentros
      -- arg_colaborador_id corresponde ao colaborador responsavél pelo regustro do perfil «
      -- arg_perfil_perfil_id corresponde ao identificador do perfil parente
      -- arg_perfil_nome corresponde ao nome do perfil a ser criado
      -- arg_menus corresponde aos identificadores dos menus que esse perfil deve ter por padrão
        [ ID, ID, ID ... ]
   */

  arg_colaborador_id uuid                := args ->>'arg_colaborador_id';
  arg_perfil_perfil_id uuid             := args ->>'arg_perfil_perfil_id';
  arg_perfil_nome character varying     := args ->>'arg_perfil_nome';
  arg_menus jsonb                       := args ->'arg_menus';

  _perfil auth.perfil;
  _res lib.result;
begin

  -- Não pode existir mais de um perfil com o mesmo nome
  if(
    select count( * ) > 0
      from auth.perfil pef
      where pef.perfil_nome = arg_perfil_nome
  ) then
    return lib.result_false( 'auth.perfil.nome.already-exist' );
  end if;

  insert into auth.perfil (
    perfil_perfil_id,
    perfil_colaborador_id,
    perfil_nome
  ) values (
    arg_perfil_perfil_id,
    arg_colaborador_id,
    arg_perfil_nome
  ) returning * into _perfil;

  _res := auth.funct_reg_privilegio(
    args || jsonb_build_object(
      'arg_perfil_id', _perfil.perfil_id
    )
  );

  _res.message := _res.message || jsonb_build_object(
    'perfil', _perfil
  );

  return _res;
end;
$$;


--
-- TOC entry 629 (class 1255 OID 16509)
-- Name: funct_reg_privilegio(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_reg_privilegio(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registrar os menus que um perfil tem privilegiso por padrão
    -- argumentos
      -- arg_colaborador_id corresponde ao identificador do colabrador responsavel por privilegiar o menu ao perfil
      -- arg_menus corresponde aos identificadores dos menus em que serão associados ao perfil
      -- arg_perfil_id corresponde ao identificador do perfil que ira ter acesso aos menus
   */

  arg_colaborador_id uuid  := args ->>'arg_colaborador_id';
  arg_perfil_id uuid       := args ->>'arg_perfil_id';
  arg_menus         jsonb := args ->>'arg_menus';

  arg_menu_list int[ ] := array( select jsonb_array_elements_text( arg_menus )::int );

  _const map.constant;
  arg_privilegios auth.privilegio[];
begin

  _const := map.constant();
  -- Desativar todos os menus que não farão parte desse perfil
  update auth.privilegio
    set privilegio_estado = _const.privilegio_estado_fechado,
        privilegio_dataatualuzacao = current_timestamp,
        privilegio_colaborador_atualizacao = arg_colaborador_id
    where previlegio_perfil_id = arg_perfil_id
      and privilegio_estado = _const.perfil_estado_ativo
      and privilegio_menu_id != all( arg_menu_list )
  ;

  -- Associar os novos menus ao perfil
  insert into auth.privilegio(
    previlegio_perfil_id,
    privilegio_menu_id,
    privilegio_colaborador_id
  ) select
      arg_perfil_id,
      me.menu_id,
      arg_colaborador_id
    from unnest( arg_menu_list ) m( id )
      inner join auth.menu me on m.id = me.menu_id
      left join auth.privilegio pri on me.menu_id = pri.privilegio_menu_id
        and pri.privilegio_estado = _const.privilegio_estado_ativo
    where pri.privilegio_id is null
  ;

  -- Obter todos os privilegios associados ao perfil
  select array_agg( pri ) into arg_privilegios
    from auth.privilegio pri
    where pri.previlegio_perfil_id = arg_perfil_id
      and pri.privilegio_estado = _const.privilegio_estado_ativo
  ;

  return lib.result_true(
    jsonb_build_object(
      'privilegios', arg_privilegios
    )
  );
end;
$$;


--
-- TOC entry 630 (class 1255 OID 16510)
-- Name: funct_reg_trabalha(jsonb); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.funct_reg_trabalha(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para registar os locas que um colaborador pode trabalhar
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_colaborador_propetario: ID,
      _branch_uid: UID
      arg_espaco : [
        { arg_espaco_id: ID }
      ]
    }
  */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid  not null default args->>'arg_espaco_auth';
  arg_espaco_child uuid[ ] default rule.espaco_get_childrens( arg_espaco_auth );
  arg_colaborador_propetario uuid default args->>'arg_colaborador_propetario';
  arg_espaco uuid[ ] not null default array ( select ( el.doc->>'arg_espaco_id' )::uuid from jsonb_array_elements( args->'arg_espaco' ) el ( doc ) );
  _const map.constant;
  _branch  tweeks.branch;
begin
  _const := map.constant();
  _branch := tweeks._get_branch_by_colaborador( arg_colaborador_propetario );


  -- Fechar todos os espaços em que o colaborador não vai mais trabalhar
  update tweeks.trabalha
    set trabalha_estado = _const.maguita_trabalha_estado_fechado,
        trabalha_colaborador_atualizacao = arg_colaborador_id,
        trabalha_dataatualizacao = current_timestamp
    where trabalha_estado = _const.maguita_trabalha_estado_ativo
      and trabalha_colaborador_proprietario = arg_colaborador_propetario
      and trabalha_espaco_auth = any( arg_espaco_child )
      and _branch_uid = _branch.branch_uid

  ;

  insert into tweeks.trabalha (
    trabalha_colaborador_id,
    trabalha_colaborador_proprietario,
    trabalha_perfil_id,
    trabalha_espaco_destino,
    trabalha_espaco_auth,
    _branch_uid
  ) select arg_colaborador_id,
      arg_colaborador_propetario,
      null,
      es.arg_espaco_id,
      arg_espaco_auth,
     _branch.branch_uid
    from unnest( arg_espaco ) es ( arg_espaco_id )
  ;

  return true ? jsonb_build_object(
    'trabalha', array(
      select tr
        from tweeks.trabalha tr
        where tr.trabalha_estado = _const.maguita_trabalha_estado_ativo
          and tr.trabalha_colaborador_proprietario = arg_colaborador_propetario
    )
  );
end;
$$;


--
-- TOC entry 583 (class 1255 OID 16511)
-- Name: __transaction_uid(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__transaction_uid() RETURNS uuid
    LANGUAGE sql IMMUTABLE STRICT
    AS $$select gen_random_uuid();$$;


--
-- TOC entry 235 (class 1259 OID 16512)
-- Name: collector; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.collector (
    collector_transuid uuid DEFAULT cluster.__transaction_uid() NOT NULL,
    collector_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    collector_share_regclass character varying NOT NULL,
    collector_cluster_origin uuid NOT NULL,
    collector_sequence bigint NOT NULL,
    collector_order bigint,
    collector_minseq bigint,
    collector_maxseq bigint,
    collector_ref jsonb,
    collector_metadata jsonb,
    collector_old jsonb,
    collector_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    collector_version boolean DEFAULT false NOT NULL,
    collector_pid bigint DEFAULT pg_backend_pid(),
    collector_operation character(1),
    collector_remoteold jsonb,
    collector_originold jsonb,
    collector_changes character varying[] DEFAULT ARRAY[]::text[] NOT NULL,
    collector_metaapply jsonb,
    collector_changevalue jsonb,
    collector_usechage jsonb
);


--
-- TOC entry 5619 (class 0 OID 0)
-- Dependencies: 235
-- Name: COLUMN collector.collector_ref; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.collector.collector_ref IS 'Correspondem as chaves de acesso ao objecto real';


--
-- TOC entry 5620 (class 0 OID 0)
-- Dependencies: 235
-- Name: COLUMN collector.collector_metadata; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.collector.collector_metadata IS 'São os dados do proprio objecto real';


--
-- TOC entry 634 (class 1255 OID 16523)
-- Name: __add(regclass); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__add(_regclass regclass) RETURNS SETOF cluster.collector
    LANGUAGE plpgsql
    AS $_$
declare
  /**
    PROPOSE: Coletar nova modificação ocoridas numa tabela que ainda não foram versionadas,
      coletadas ou que a versão esteje ultrapassadas
   */
  _share cluster.share;
  _statement text;
begin
  select s.* into _share
    from cluster.share s
    where s.share_regclass = _regclass
  ;

  -- language=PostgreSQL
  _statement :=  $sql$
    with
      __unvercollector as (
        select
          uvcol.*,
          rank() over ( partition by uvcol.collector_ref order by uvcol.collector_sequence desc ) as rank
        from cluster.collector uvcol
        where not uvcol.collector_version
          and uvcol.collector_share_regclass = ($1::cluster.share).share_regclass
      ), __object as (
        select
            o.*,
            rank() over ( partition by o.object_ref order by o.object_seq desc ) as rank
          from cluster.object o
          where o.object_share_regclass = ($1::cluster.share).share_regclass
      ), __change as (
        select
            to_jsonb( _t ) as change,
            lib.sets_ref( to_jsonb( _t ), ($1::cluster.share).share_pks ) as ref
          from _$table as _t
      ), __news as (
        select _c.*, coalesce( uvcol.collector_metadata, vcol.collector_metadata ) as collector_metadata
          from __change _c
            left join  __object _ol on _ol.object_ref = _c.ref
              and _ol.rank = 1
            left join cluster.collector vcol on vcol.collector_uid = _ol.object_collector_uid
            left join __unvercollector uvcol on not uvcol.collector_version
              and uvcol.rank = 1
              and uvcol.collector_share_regclass = ( $1::cluster.share ).share_regclass
              and uvcol.collector_ref = _c.ref
        where (vcol.collector_uid is null or vcol.collector_metadata != _c.change)
          and ( uvcol.collector_uid is null or uvcol.collector_metadata != _c.change )
      ) select col.*
          from __news _n
            inner join cluster.__collect_change(
              ( $1::cluster.share ).share_regclass,
              _n.change,
              _n.collector_metadata,
              case when _n.collector_metadata is null then 'I' else 'U' end,
              ref
            ) col on true
  $sql$;

  _statement := replace( _statement, '_$table'::text, _regclass::text );
  return query execute _statement using _share;
end;
$_$;


--
-- TOC entry 635 (class 1255 OID 16524)
-- Name: __collect_change(regclass, jsonb, jsonb, character, jsonb, boolean); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__collect_change(regclass, _change jsonb, _old jsonb DEFAULT NULL::jsonb, _operation character DEFAULT 'I'::bpchar, _ref jsonb DEFAULT NULL::jsonb, _force boolean DEFAULT false) RETURNS SETOF cluster.collector
    LANGUAGE plpgsql
    AS $_$
declare
  _collector cluster.collector;
  _origin uuid default '00000000-0000-0000-0000-000000000000'::uuid;
begin
  if not _force and _change is null then return; end if;
  if not _force and _old is not null and _change = _old then return; end if;

  _collector.collector_share_regclass := cluster.__format( $1 );
  _collector.collector_metadata := _change;
  _collector.collector_changes := array(
    select e.key
      from jsonb_each( _change||coalesce( _old, jsonb_build_object() ) ) e( key, value )
      where _old isnull
        or _change -> ( e.key ) != _old ->( e.key )
  );

  _collector.collector_changevalue = (
    select jsonb_object_agg( e.key, e.value )
    from jsonb_each( _change||coalesce( _old, jsonb_build_object() ) ) e( key, value )
    where _old isnull
       or _change -> ( e.key ) != _old ->( e.key )
  );

  insert into cluster.collector(
    collector_share_regclass,
    collector_metadata,
    collector_metaapply,
    collector_changevalue,
    collector_changes,
    collector_cluster_origin,
    collector_old,
    collector_originold,
    collector_operation,
    collector_ref
  ) values (
    _collector.collector_share_regclass,
    _collector.collector_metadata,
    _collector.collector_metadata,
    _collector.collector_changevalue,
    _collector.collector_changes,
    _origin,
    _old,
    _old,
    coalesce( _operation, case
      when _old is null then 'I'
      else 'U'
    end),
    _ref
  ) returning * into _collector;

  return next _collector;
end;
$_$;


--
-- TOC entry 636 (class 1255 OID 16525)
-- Name: __create_api(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__create_api() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare
    _leter character varying default 'ABCDEFGHIJKLMNOQRSTUVWXYZ';
  begin
    return format( '%s', lib.dset_random_text( _leter || '0123456789', 128 ) );
  end;
$$;


--
-- TOC entry 637 (class 1255 OID 16526)
-- Name: __create_identifier(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__create_identifier() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare
    _leter character varying default 'ABCDEFGHIJKLMNOQRSTUVWXYZ';
  begin
    return format(
    '%s-%s-%s',
    lib.dset_random_text( _leter, 4 ),
    lib.dset_random_text( _leter||'0123456789', 5 ),
    lib.dset_random_text( '0123456789', 3 )
  );
  end;
$$;


--
-- TOC entry 236 (class 1259 OID 16527)
-- Name: version; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.version (
    version_uid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    version_share_regclass character varying NOT NULL,
    version_cluster_id uuid NOT NULL,
    version_number bigint DEFAULT 0 NOT NULL
);


--
-- TOC entry 638 (class 1255 OID 16534)
-- Name: __create_object_version(regclass); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__create_object_version(regclass) RETURNS cluster.version
    LANGUAGE plpgsql
    AS $_$
declare
  declare
  _regclass regclass default cluster.__format( $1 );
  _share record;
  _object cluster.object;
  _cluster cluster.cluster;
  _version cluster.version;
  _data record;
  _results record;
  _pid int default pg_backend_pid();
begin
  _cluster := cluster._get_cluster_local(  );
  _version := cluster._get_version_local( _regclass );

  select s.* into _share
    from cluster.share s
    where s.share_regclass::regclass = _regclass;

  _object.object_share_regclass := _share.share_regclass;
  _object.object_cluster_origin := _cluster.cluster_uid;
  _object.object_cluster_receiver := _cluster.cluster_uid;

  with __objects as (
    select
      count( o.object_uid )  as _object_localversion,
      count( o.object_uid ) filter ( where o.object_share_regclass::regclass = _regclass and o.object_cluster_origin = _cluster.cluster_uid )  as _object_originsseq,
      count( o.object_uid ) filter ( where o.object_share_regclass::regclass = _regclass  )  as _object_sseq
      from cluster.object o
  ), __collectors as (
    select
      count( c.collector_uid ) as collectors,
      min( c.collector_sequence ) as _collector_minseq,
      max( c.collector_sequence ) as _collector_maxseq
    from cluster.collector c
    where not c.collector_version
      and c.collector_share_regclass::regclass = _regclass
      and c.collector_cluster_origin = _cluster.cluster_uid
      and c.collector_pid = _pid
      and c.collector_ref is null
  ) select * into _data from __collectors, __objects;

  if _data.collectors = 0 then return _version; end if;

  with __apply_collector as  (
      update cluster.collector c
        set
          collector_version = true,
          collector_ref = lib.sets_ref( coalesce( collector_old, collector_metadata ), _share.share_pks ),
          collector_order = c.collector_sequence - _data._collector_minseq +1,
          collector_minseq = _data._collector_minseq,
          collector_maxseq = _data._collector_maxseq
        where not c.collector_version
          and c.collector_share_regclass::regclass = _regclass
          and c.collector_ref is null
          and c.collector_pid = _pid
          and c.collector_cluster_origin = _cluster.cluster_uid
        returning
          c.collector_transuid,
          c.collector_uid,
          c.collector_sequence,
          c.collector_minseq,
          c.collector_maxseq,
          c.collector_share_regclass,
          c.collector_ref,
          c.collector_metadata,
          c.collector_date,
          c.collector_order
      ) ,__creat_object as (
        insert into cluster.object (
          object_ref,
          object_transuid,
          object_share_regclass,
          object_cluster_origin,
          object_cluster_receiver,
          object_originver,
          object_originsver,
          object_origincver,
          object_originsseq,
          object_sseq,
          object_originrev,
          object_collector_uid
        ) select
              _ac.collector_ref,
              _ac.collector_transuid,
              cluster.__format( _regclass ),
              _object.object_cluster_origin,
              _object.object_cluster_receiver,
              _ac.collector_sequence,
              _version.version_number,
              _cluster.cluster_version,
              _data._object_originsseq + _ac.collector_order,
              _data._object_sseq + _ac.collector_order,
              count( col.collector_uid )+1,
              _ac.collector_uid
            from __apply_collector  _ac
              left join cluster.collector col on  _ac.collector_ref = col.collector_ref
                and _ac.collector_uid != col.collector_uid
            group by
              _regclass,
              _object.object_cluster_origin,
              _object.object_cluster_receiver,
              _version.version_number,
              _ac.collector_order,
              _ac.collector_sequence,
              _ac.collector_ref,
              _ac.collector_metadata,
              _ac.collector_uid,
              _ac.collector_transuid
            order by _ac.collector_sequence
            returning
                object_uid,
                object_originver,
                object_transuid,
                object_seq,
                object_cluster_origin,
                object_share_regclass,
                object_collector_uid
      )
      select
          count( o.object_uid ) as objects,
          max( o.object_originver ) as object_originver,
          max( c.collector_sequence ) as collector_sequence,
          max( o.object_seq ) as object_seq
        into _results
      from __creat_object o
        inner join cluster.collector c on c.collector_uid = o.object_collector_uid
          and c.collector_transuid = o.object_transuid
          and c.collector_cluster_origin = o.object_cluster_origin
          and c.collector_share_regclass = o.object_share_regclass
  ;

  if _results.objects > 0 then
      update cluster.version
        set version_number = version_number +1
        where version_uid = _version.version_uid
        returning  * into _version
      ;
  end if;

  if _results.objects > 0 then
      update cluster.cluster
        set cluster_sequence = _results.object_seq,
            cluster_version = cluster_version +1,
            cluster_objectver = _results.object_originver
        where cluster_uid = _cluster.cluster_uid;
  end if;

  return _version;
end;
$_$;


--
-- TOC entry 639 (class 1255 OID 16535)
-- Name: __format(regclass); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__format(regclass) RETURNS character varying
    LANGUAGE sql STABLE STRICT
    AS $_$
  with __source as (
    select schemaname, tablename
      from pg_tables 
    union all 
      select schemaname, viewname
        from pg_views
  )
    select format( '%I.%I', schemaname, tablename )
      from __source
      where format( '%s.%s', schemaname, tablename )::regclass = $1
$_$;


--
-- TOC entry 640 (class 1255 OID 16536)
-- Name: __format_proc(regproc); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__format_proc(regproc) RETURNS character varying
    LANGUAGE sql STABLE STRICT
    AS $_$
select format( '%I.%I', p.pronamespace::regnamespace::text, p.proname::text  )
  from pg_proc p
  where format( '%I.%I', p.pronamespace::regnamespace::text, p.proname::text  )::regproc = $1
$_$;


--
-- TOC entry 641 (class 1255 OID 16537)
-- Name: __generate_cluster_code(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__generate_cluster_code() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  chars character varying default '0123456789';
  code character varying;
  repeate integer default 0;
  codeLen integer default 3;
begin
  while code is null loop
    code := lib.dset_random_text( chars, codeLen );
    if exists(
        select *
          from cluster.cluster
          where  code in ( cluster.cluster_code, lpad('', codeLen, '0' ) )
    ) then
      code := null;
      if repeate  = 9999 then
        chars := '012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      elseif repeate = 99999 then
        chars := '012345678901234567890123456789012345678901234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      elseif repeate = 999999 then
        chars := '012345678901234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      elseif repeate = 9999999 then
        chars := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      elseif repeate = 99999999 then
        raise exception 'O sistema não consegue determinar um codigo para o cluster';
      end if;
    end if;
    repeate := repeate +1;
  end loop;

  return code;
end;
$$;


--
-- TOC entry 642 (class 1255 OID 16538)
-- Name: __get(regclass, jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__get(regclass, jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $_$
declare

begin
  --language=PostgreSQL
  return query execute replace( $sql$
    select to_jsonb( _t )
      from __tablename _t
      where lib.sets_ref( _t ) = $1
  $sql$, '__tablename', $1::text ) using $2;
end;
$_$;


--
-- TOC entry 631 (class 1255 OID 16539)
-- Name: __is_replication(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__is_replication() RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
declare
  _users cluster.users;
begin
  _users := cluster.__user_map();
  return _users.user_replication is not null
    and _users.user_replication = "current_user"()::regrole;
end;
$$;


--
-- TOC entry 602 (class 1255 OID 16540)
-- Name: __is_sub_path(text, text); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__is_sub_path(base text, child_path text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  _left text;
  _right text;
  _right_char char;
  _left_char char;
begin
  if child_path is null or base is null then return false; end if;
  if substr( base, length( base ) ) = '/' then base := substr( base, 1, length( base )-1 ); end if;
  if substr( child_path, length( child_path ) ) = '/' then child_path := substr( child_path, 1, length( child_path )-1 ); end if;

  if length( base ) >= length( child_path ) then return false; end if;

  _left := substr( child_path, 1, length(  base ) );
  _right := substr( child_path, length( base ) +1, length( child_path ) );
  _right_char := (regexp_split_to_array( _right, '' ) )[1];
  _left_char := (regexp_split_to_array( _left, '' ) )[1];


  return _left is not  null
    and _right is not null
    and _right_char is not null
    and _left = base
    and _right_char = '/'
  ;
end
$$;


--
-- TOC entry 603 (class 1255 OID 16541)
-- Name: __pks(regclass); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__pks(regclass) RETURNS name[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select array(
    select pk.name
      from lib.sets_pks( $1 ) pk( name )
  );
$_$;


--
-- TOC entry 237 (class 1259 OID 16542)
-- Name: object; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.object (
    object_transuid uuid DEFAULT cluster.__transaction_uid() NOT NULL,
    object_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    object_share_regclass character varying NOT NULL,
    object_cluster_origin uuid NOT NULL,
    object_cluster_receiver uuid,
    object_collector_uid uuid,
    object_ref jsonb NOT NULL,
    object_seq bigint NOT NULL,
    object_sseq bigint NOT NULL,
    object_originver bigint NOT NULL,
    object_originsver bigint NOT NULL,
    object_origincver bigint NOT NULL,
    object_originsseq bigint NOT NULL,
    object_originrev bigint NOT NULL,
    object_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    object_instant timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    object_receiver timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    object_sync boolean DEFAULT true NOT NULL,
    object_status smallint DEFAULT 1 NOT NULL,
    object_outdate boolean DEFAULT false NOT NULL
);


--
-- TOC entry 5635 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_uid; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_uid IS 'Identificador unico do objecto';


--
-- TOC entry 5636 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_share_regclass; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_share_regclass IS 'Correspone a tabela na qual o objecto pertense';


--
-- TOC entry 5637 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_cluster_origin; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_cluster_origin IS 'Corresponde ao cluster/maquina/pc na qual foi responsavel pela criação do objecto';


--
-- TOC entry 5638 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_cluster_receiver; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_cluster_receiver IS 'Corresponde ao cluster/maquina/pc na qual recebeu-se o objecto';


--
-- TOC entry 5639 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_seq; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_seq IS 'Corresponde a sequencia da ordem de entrada do objecto independente da origem e da regclass';


--
-- TOC entry 5640 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_sseq; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_sseq IS 'Corresponde a sequencia de entrada do objecto na tabela independentemente da origem';


--
-- TOC entry 5641 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_originver; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_originver IS 'Versão global do objecto';


--
-- TOC entry 5642 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_originsver; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_originsver IS 'Versão do share (table/regclss) as criar o objecto';


--
-- TOC entry 5643 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_origincver; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_origincver IS 'Versão em que o cluster que criou o objecto';


--
-- TOC entry 5644 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_originsseq; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_originsseq IS 'Numero de sequencia dentro do share';


--
-- TOC entry 5645 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_originrev; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_originrev IS 'Reivisao, ordem de mofificação ocorrida no objecto original';


--
-- TOC entry 5646 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN object.object_date; Type: COMMENT; Schema: cluster; Owner: -
--

COMMENT ON COLUMN cluster.object.object_date IS 'Corresponde ao instante em que foi criado a versão do objecto';


--
-- TOC entry 608 (class 1255 OID 16555)
-- Name: __pull(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__pull(args jsonb) RETURNS cluster.object
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      _classname: CLASS.NAME

      _current: JSONB
      _change: JSONB
      _outdate: BOOLEAN

      _origin: UID
      _receiver: UID

      _result: BOOLEAN
      _exist_object BOOLEAN
      _exist_collector BOOLEAN

      _object: CLUSTER.OBJECT
      _collector: CLUSTER.COLLECTOR
    }
   */
  _ref jsonb;
  _object cluster.object;
  _collector cluster.collector;

  _regclass regclass default (args->>'_classname')::text::regclass;
  _current jsonb default args->'_current';
  _change jsonb default args->'_change';
  _use_change jsonb;


  _origin uuid default args->>'_origin';
  _receiver uuid default args->>'_receiver';

  _outdate boolean not null default args->>'_outdate';
  _result boolean not null default args->>'_result';
  _exist_collector boolean default args->>'_exist_collector';
  _exist_object boolean default args->>'_exist_object';
  _metadata jsonb;


  _res cluster.object;
begin

  _object := jsonb_populate_record( _object, args->'_object' );
  _collector := jsonb_populate_record( _collector, args->'_collector' );
  _use_change := _change;

  if _current is not null and jsonb_typeof( _current ) != 'object' then
    _current := null;
  end if;

  _ref := coalesce( _object.object_ref, _collector.collector_ref, lib.sets_ref( _regclass, _collector.collector_metadata ) );
  _object.object_ref := _ref;
  _collector.collector_ref := _ref;

  if _ref is null then
    raise exception 'pull reference is null';
  end if;

  if _change is null or  jsonb_typeof( _change ) != 'object' or not exists(
    select * from jsonb_each( _change )
  ) then
    _use_change := _collector.collector_metadata;
  end if;

  if _current is null  then
    _metadata := _collector.collector_metadata;
  else
    _metadata := _current || _use_change;
  end if;

  if _regclass = 'cluster.resource'::regclass then
    _object.object_status := 2;
  else
    _object.object_status := 1;
  end if;

  _collector.collector_cluster_origin = _origin;
  _collector.collector_old = _current;
  _collector.collector_share_regclass = cluster.__format( _regclass );
  _collector.collector_ref = _object.object_ref;
  _collector.collector_metaapply = _metadata;
  _collector.collector_changevalue = _change;
  _collector.collector_usechage = _use_change;

  begin
    if not _outdate and _result and ( _current is null or _current != _metadata ) then
      perform lib.sets_doc(
        _regclass, _metadata,
        ref := _ref
      );
    end if;

    if not coalesce( _exist_collector, false ) then
      insert into cluster.collector (
        collector_transuid,
        collector_uid,
        collector_share_regclass,
        collector_cluster_origin,
        collector_sequence,
        collector_order,
        collector_minseq,
        collector_maxseq,
        collector_ref,
        collector_metadata,
        collector_date,
        collector_version,
        collector_operation,
        collector_old,
        collector_remoteold,
        collector_originold,
        collector_changes,
        collector_metaapply,
        collector_changevalue,
        collector_usechage
      ) values (
         _collector.collector_transuid,
         _collector.collector_uid,
         _collector.collector_share_regclass,
         _collector.collector_cluster_origin,
         _collector.collector_sequence,
         _collector.collector_order,
         _collector.collector_minseq,
         _collector.collector_maxseq,
         _collector.collector_ref,
         _collector.collector_metadata,
         _collector.collector_date,
         _collector.collector_version,
         _collector.collector_operation,
         _collector.collector_old,
         _collector.collector_old,
         _collector.collector_originold,
         _collector.collector_changes,
         _collector.collector_metaapply,
         _collector.collector_changevalue,
         _collector.collector_usechage
       );
    end if;

    if not coalesce( _exist_object, false ) then
      insert into cluster.object(
        object_transuid,
        object_uid,
        object_share_regclass,
        object_cluster_origin,
        object_cluster_receiver,
        object_collector_uid,
        object_ref,
        object_seq,
        object_sseq,
        object_originver,
        object_originsver,
        object_origincver,
        object_originsseq,
        object_originrev,
        object_date,
        object_instant,
        object_receiver,
        object_status,
        object_outdate
      ) values (
         _collector.collector_transuid,
         _object.object_uid,
         cluster.__format( _regclass ),
         _origin,
         _receiver,
         _collector.collector_uid,
         _object.object_ref,
         default,
         default,
         _object.object_originver,
         _object.object_originsver,
         _object.object_origincver,
         _object.object_originsseq,
         _object.object_originrev,
         _object.object_date,
         _object.object_instant,
         now(),
         _object.object_status,
         _outdate
       ) returning * into _res;
    else
      select * into _res
        from cluster.object ob
        where true
          and ob.object_uid = _object.object_uid
          and ob.object_collector_uid = _collector.collector_uid
          and ob.object_transuid = _collector.collector_transuid
          and ob.object_ref = _object.object_ref
          and ob.object_share_regclass = cluster.__format( _regclass )
      ;
    end if;

    if _outdate then return null;
    else return _res;
    end if;

  exception when others then
    <<_ex>>
    declare
      s text; m text; d text; h text; c text;
    begin
      get stacked diagnostics
        s = returned_sqlstate,
        m = message_text,
        d = pg_exception_detail,
        h = pg_exception_hint,
        c = pg_exception_context;

      insert into cluster.break(
        break_collector,
        break_object,
        break_old,
        break_regclass,
        break_origin,
        break_receiver,
        break_sqlstate,
        break_message,
        break_detail,
        break_hint,
        break_context,
        break_ref,
        break_current,
        break_change,
        break_metadata,
        break_document
      ) values (
        to_jsonb( _collector),
        to_jsonb( _object ),
        _current,
        cluster.__format( _regclass ),
        _origin,
        _receiver,
        _ex.s,
        _ex.m,
        _ex.d,
        _ex.h,
        _ex.c,
        _object.object_ref,
        _current,
        _change,
        _metadata,
        _collector.collector_metadata
      );
      return null;
    end;
  end;
end
$$;


--
-- TOC entry 633 (class 1255 OID 16557)
-- Name: __rows(regclass[]); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__rows(VARIADIC regclass[]) RETURNS TABLE(document jsonb, reference jsonb, classname regclass)
    LANGUAGE plpgsql
    AS $_$
declare
  _next record;
  _regclass regclass;
begin

  for _next in
    select *
    from unnest( $1 ) n( tname )
    loop
      _regclass := _next.tname::regclass;

      return query execute format( $sql$
        select
          to_jsonb( _t ),
          lib.sets_ref( _t ),
          %L::regclass
          from %s _t
        $sql$, _regclass, _regclass ) using $2;
    end loop;
end;
$_$;


--
-- TOC entry 394 (class 1255 OID 16558)
-- Name: __tg_before_create_filter(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_before_create_filter() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new cluster.filter;
begin
  _new := new;
  _new.filter_regproc := cluster.__format_proc( _new.filter_regproc::regproc );
  return _new;
end
$$;


--
-- TOC entry 587 (class 1255 OID 16559)
-- Name: __tg_share_check(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_share_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
begin
  if( to_regclass( new.share_regclass ) is null ) then
    raise exception '% is not a table', new.share_regclass;
  end if;
  new.share_regclass := cluster.__format( new.share_regclass );
  new.share_pksfrom := cluster.__format( new.share_pksfrom );
  new.share_pks := lib.sets_pks_array( coalesce( new.share_pksfrom, new.share_regclass ) );
  return new;
end;
$$;


--
-- TOC entry 632 (class 1255 OID 16560)
-- Name: __tg_share_guard_upgrade(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_share_guard_upgrade() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
declare
  _regclass regclass;
  _share cluster.share;
  _record record;
begin
  for _record  IN
    select *
      from pg_event_trigger_ddl_commands()
      where tg_tag in ( 'ALTER TABLE', 'CREATE TABLE' )
  loop
    _regclass := _record.object_identity;
    select * into _share
      from cluster.share s
      where s.share_regclass::regclass = _regclass;

    if _share.share_regclass::regclass is not null then
      update cluster.share
        set share_pks = default
        where share_regclass = _regclass;
      end if;
  end loop;
end;
$$;


--
-- TOC entry 643 (class 1255 OID 16561)
-- Name: __tg_share_map(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_share_map() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
declare
  PROCEDURE_COMMIT regprocedure default 'cluster.__tg_version_commit()'::regprocedure;
  PROCEDURE_ADD_INSERT regprocedure default 'cluster.__tg_version_add_when_insert()'::regprocedure;
  PROCEDURE_ADD_UPDATE regprocedure default 'cluster.__tg_version_add_when_update()'::regprocedure;

  _new cluster.share;
  _old cluster.share;
  _share record;
  _data record;
  _base_name character varying;
  _trigger_name name;
  _statement text;
  _tg record;
begin
  if tg_op in ( 'INSERT', 'UPDATE' ) then
    _new := new;
    select
        c.relname as table_name,
        c.relnamespace::regnamespace::text as table_scheme,
        _new.*
        into _share
      from pg_class c
      where c.oid::regclass = _new.share_regclass::regclass;
  end if;


  if tg_op in ( 'UPDATE', 'DELETE' ) then
    _old := old;
  end if;

  if tg_when = 'BEFORE' then
    if _old.share_regclass is not null and _old.share_triggers is not null and array_length( _old.share_triggers, 1 ) > 0 then
      for _data in
        select *  from unnest( _old.share_triggers ) u( trigger_name )
      loop
        begin 
          execute format( 'drop trigger %I on %s', _data.trigger_name, _old.share_regclass );
        exception when others then null;
        end;
      end loop;
    end if;
  end if;

  if tg_when = 'BEFORE' and _new.share_regclass is not null then
    select array_agg( tgname ) as triggers into _data
      from pg_trigger tg
      where tg.tgrelid::regclass = _new.share_regclass::regclass
    ;

    _new.share_triggers := array[]::name[];
    for _tg in
      with __when ( _tg_op, _for, _procedure ) as (
        select 'insert', 'each row', PROCEDURE_ADD_INSERT where _new.share_insert
        union all select 'insert', 'each statement', PROCEDURE_COMMIT where _new.share_insert
        union all select 'update', 'each row', PROCEDURE_ADD_UPDATE where _new.share_update
        union all select 'update', 'each statement', PROCEDURE_COMMIT where _new.share_update
      ) select *
      from __when w
    loop

      if _tg._for  = 'each row' then
        _base_name := format( 'cluster_version_add_change_after_%s_on_%s_%s', _tg._tg_op, _share.table_scheme, _share.table_name );
      else
        _base_name := format( 'cluster_version_commit_change_%s_on_%s_%s', _tg._tg_op, _share.table_scheme, _share.table_name );
      end if;

      _trigger_name := format( '%s_%s', _base_name, ( random() * (999999 - 100000 )+100000)::int );
      while _trigger_name = any( _data.triggers ) loop
        _trigger_name := format( '%s_%s', _base_name, ( random() * (999999 - 100000 )+100000)::int );
      end loop;

      --language=PostgreSQL
      _statement := $sql$
        create trigger _tg_name
          after delete
          on _table_name
          for statement
          when ( not cluster.__is_replication() )
          execute procedure _use_procedure
        ;
      $sql$;

      _statement := replace( _statement, '_tg_name', '%I' );
      _statement := replace( _statement, 'delete', '%s' );
      _statement := replace( _statement, '_table_name', '%s' );
      _statement := replace( _statement, 'statement', '%s' );
      _statement := replace( _statement, '_use_procedure', '%s' );
      _statement := format( _statement, _trigger_name, _tg._tg_op, _new.share_regclass::text, _tg._for, _tg._procedure );
      
      begin 
        execute _statement;
      exception when others then null;
      end;
      _new.share_triggers := _new.share_triggers || _trigger_name;
      _data.triggers := _data.triggers || _trigger_name;
    end loop;
  end if;

  if tg_when = 'BEFORE' and tg_op in (  'INSERT', 'UPDATE' ) then
    return _new;
  elseif tg_when = 'BEFORE' and tg_op in( 'DELETE' ) then
    return _old;
  end if;

  return null;
end;
$_$;


--
-- TOC entry 644 (class 1255 OID 16562)
-- Name: __tg_share_truncate(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_share_truncate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _add_insert regprocedure default 'cluster.__tg_version_add_when_insert()'::regprocedure;
  _add_update regprocedure default 'cluster.__tg_version_add_when_update()'::regprocedure;
  _commit regprocedure default 'cluster.__tg_version_commit()'::regprocedure;
  _data record;
begin
  for _data in
    select
      tg.tgrelid::regclass::text as share_regclass,
      tg.tgname as trigger_name,
      tg.*
    from pg_trigger tg
    where tg.tgfoid in( _add_insert, _add_update, _commit )
  loop
    begin
      execute format( 'drop trigger %I on %s', _data.trigger_name, _data.share_regclass );
    exception when others then null;
    end;
  end loop;
  return null;
end;
$$;


--
-- TOC entry 645 (class 1255 OID 16563)
-- Name: __tg_version_add_when_insert(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_version_add_when_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  perform cluster.__collect_change(
      tg_relid::regclass,
      to_jsonb( new )
    );
  return null;
end;
$$;


--
-- TOC entry 646 (class 1255 OID 16564)
-- Name: __tg_version_add_when_update(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_version_add_when_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

begin
  perform cluster.__collect_change(
    tg_relid::regclass,
    to_jsonb( new ),
    to_jsonb( old ),
    'U'
  );
  return null;
end;
$$;


--
-- TOC entry 647 (class 1255 OID 16565)
-- Name: __tg_version_commit(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__tg_version_commit() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  declare
  _regclass regclass default format( '%s.%s', tg_table_schema, tg_table_name )::regclass;

begin

  if cluster.__is_replication() then
    return null;
  end if;

  perform cluster.__create_object_version( _regclass );
  return null;
end;
$$;


--
-- TOC entry 648 (class 1255 OID 16566)
-- Name: __user_default(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__user_default() RETURNS regrole
    LANGUAGE sql STABLE
    AS $$select user_default from cluster.users limit 1$$;


--
-- TOC entry 238 (class 1259 OID 16567)
-- Name: users; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.users (
    user_default regrole NOT NULL,
    user_replication regrole
);


--
-- TOC entry 649 (class 1255 OID 16570)
-- Name: __user_map(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__user_map() RETURNS cluster.users
    LANGUAGE sql STABLE
    AS $$
  select * from cluster.users limit 1;
$$;


--
-- TOC entry 650 (class 1255 OID 16571)
-- Name: __user_replication(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.__user_replication() RETURNS regrole
    LANGUAGE sql STABLE
    AS $$select user_replication from cluster.users limit 1$$;


--
-- TOC entry 495 (class 1255 OID 16572)
-- Name: _cluster_accept_child(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster._cluster_accept_child(args jsonb) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _const map.constant;
begin
  _cluster := jsonb_populate_record( _cluster, args );
  _const := map.constant();
  return exists(
    select *
      from cluster.cluster c
      where c.cluster_identifier = _cluster.cluster_identifier
        and c.cluster_type = _const.cluster_tcluster_child
        and c.cluster_api = _cluster.cluster_api
  );
end;
$$;


--
-- TOC entry 239 (class 1259 OID 16573)
-- Name: cluster; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.cluster (
    cluster_uid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    cluster_identifier character varying,
    cluster_type smallint,
    cluster_path character varying,
    cluster_name character varying,
    cluster_domain character varying,
    cluster_port character varying,
    cluster_api character varying,
    cluster_pid integer,
    cluster_version bigint DEFAULT 0 NOT NULL,
    cluster_sequence bigint DEFAULT 0 NOT NULL,
    cluster_objectver bigint DEFAULT 0 NOT NULL,
    cluster_grants character varying[] DEFAULT ARRAY[]::text[] NOT NULL,
    cluster_configs jsonb DEFAULT jsonb_build_object() NOT NULL,
    cluster_tree smallint DEFAULT (map.get('cluster_tree_position_branch'::name))::smallint NOT NULL,
    cluster_private text,
    cluster_key text,
    cluster_machineid text,
    cluster_license timestamp without time zone,
    cluster_licenselife smallint,
    cluster_code character varying DEFAULT cluster.__generate_cluster_code(),
    cluster_verbose boolean DEFAULT false NOT NULL,
    cluster_tperiod_id smallint,
    cluster_namespace character varying,
    cluster_remote boolean DEFAULT false NOT NULL
);


--
-- TOC entry 498 (class 1255 OID 16588)
-- Name: _get_cluster(character varying); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster._get_cluster(character varying) RETURNS cluster.cluster
    LANGUAGE sql
    AS $_$ select * from cluster.cluster where cluster_identifier = $1 $_$;


--
-- TOC entry 502 (class 1255 OID 16589)
-- Name: _get_cluster_child(character varying); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster._get_cluster_child(identifier character varying) RETURNS cluster.cluster
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _const map.constant;
begin
  _const := map.constant();
  select * into _cluster
    from cluster.cluster c
    where c.cluster_identifier = identifier
      and c.cluster_type = _const.cluster_tcluster_child
  ;
  return  _cluster;
end
$$;


--
-- TOC entry 503 (class 1255 OID 16590)
-- Name: _get_cluster_local(boolean, integer); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster._get_cluster_local(increment boolean DEFAULT false, try integer DEFAULT 0) RETURNS cluster.cluster
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  -- local origin
  _origin uuid default '00000000-0000-0000-0000-000000000000'::uuid;
  _const map.constant;
begin
  _const := map.constant();

  if coalesce( increment, false ) then
    update cluster.cluster
      set cluster_version = cluster_version +1
      where cluster_uid = _origin
      returning * into _cluster;
  else
    select * into _cluster
      from cluster.cluster c
      where c.cluster_type = _const.cluster_tcluster_local;
  end if;

  if _cluster.cluster_uid is null then
    insert into cluster.cluster(
      cluster_uid,
      cluster_identifier,
      cluster_type,
      cluster_version
    ) values (
      _origin,
      cluster.__create_identifier(),
      _const.cluster_tcluster_local,
      lib."when"( coalesce( increment, false), 1, 0 )
    ) returning * into _cluster;
  end if;

  return _cluster;
exception when others then
  <<_ex>>
  declare
    e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    if try < 10 then
      perform pg_sleep( try );
      return cluster._get_cluster_local( increment, try+1 );
    else raise exception '%', m;
    end if;
  end;
end;
$$;


--
-- TOC entry 508 (class 1255 OID 16591)
-- Name: _get_cluster_master(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster._get_cluster_master() RETURNS cluster.cluster
    LANGUAGE plpgsql
    AS $$
declare
  _const map.constant;
  _cluster cluster.cluster;
begin
  _const := map.constant();
  select c.* into _cluster
    from cluster.cluster c
    where c.cluster_type = _const.cluster_tcluster_master
  ;
  return _cluster;
end;
$$;


--
-- TOC entry 651 (class 1255 OID 16592)
-- Name: _get_version_local(regclass, boolean); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster._get_version_local(regclass, increment boolean DEFAULT false) RETURNS cluster.version
    LANGUAGE plpgsql STRICT
    AS $_$
declare
  _version cluster.version;
  _cluster cluster.cluster;
begin
  _cluster := cluster._get_cluster_local();

  if coalesce( increment, false ) then
    update cluster.version
      set version_number = version_number +1
      where version_share_regclass::regclass = $1
        and version_cluster_id = _cluster.cluster_uid
      returning * into _version
    ;
  else
    select * into _version
      from cluster.version
      where version_cluster_id = _cluster.cluster_uid
        and version_share_regclass::regclass = $1;
  end if;

  if _version.version_uid is null then
    _version.version_number := lib."when"( coalesce( increment, false ), 1, 0 );
    _version.version_cluster_id := _cluster.cluster_uid;
    _version.version_share_regclass := cluster.__format( $1 );
    select ( "returning" ).* into _version from lib.sets_in( _version );
  end if;

  return _version;
end;
$_$;


--
-- TOC entry 652 (class 1255 OID 16593)
-- Name: accept_remote_cluster(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.accept_remote_cluster(args jsonb) RETURNS SETOF boolean
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _local cluster.cluster;
  _is_sub_path boolean;
  _const map.constant;

  _can_receiver_sub_path_revision boolean;
begin
  _cluster := jsonb_populate_record( _cluster, args );

  _const := map.constant();
  _local := cluster._get_cluster_local();
  _is_sub_path := cluster.__is_sub_path( _local.cluster_path, _cluster.cluster_path );
  _local.cluster_path := coalesce( _local.cluster_path, '/' );
  _cluster.cluster_path := coalesce( _cluster.cluster_path, '' );
  _can_receiver_sub_path_revision := _const.cluster_grant_revision_sub_path = any( _local.cluster_grants );

  if not (
    _cluster.cluster_path = _local.cluster_path
      or ( _is_sub_path and _can_receiver_sub_path_revision )
  ) then return; end if;

  return query select true;
end
$$;


--
-- TOC entry 654 (class 1255 OID 16594)
-- Name: accept_revision(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.accept_revision(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_identifier
      cluster_path
    }
   */
  _master cluster.cluster;
  _local cluster.cluster;
  _remote_child cluster.cluster;
  _remote cluster.cluster;

  _const map.constant;

  _local_is_child_of_remote boolean;
  _local_is_super_path_remote boolean;
  _local_is_master_of_remote boolean;
begin

  if args is null then return; end if;
  _remote := jsonb_populate_record( _remote, args );
  _master := cluster._get_cluster_master();

  _const := map.constant();
  _local := cluster._get_cluster_local();
  _local.cluster_path := coalesce( _local.cluster_path, '/' );
  _remote.cluster_path := coalesce( _remote.cluster_path, '/' );

  if _local.cluster_identifier = _remote.cluster_identifier then return; end if;

  select * into _remote_child
    from cluster.cluster c
    where c.cluster_type = _const.cluster_tcluster_child
      and c.cluster_identifier = _remote.cluster_identifier
  ;


  _local_is_child_of_remote := _master.cluster_identifier = _remote.cluster_identifier;
  _local_is_super_path_remote := cluster.__is_sub_path( _local.cluster_path, _remote.cluster_path );
  _local_is_master_of_remote := _remote_child.cluster_identifier is not null;

  if not (
    coalesce( _local.cluster_path = _remote.cluster_path, false )
    or coalesce( _local_is_child_of_remote, false )
    or coalesce( _local_is_super_path_remote and _const.cluster_grant_revision_sub_path = any( _local.cluster_grants ), false )
    or coalesce( _local_is_master_of_remote and _const.cluster_grant_revision_child = any ( _remote_child.cluster_grants ), false )
  ) then return; end if;

  return query
    select *
      from cluster.status( args );
end;
$$;


--
-- TOC entry 655 (class 1255 OID 16595)
-- Name: add(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.add(args jsonb DEFAULT NULL::jsonb) RETURNS SETOF cluster.collector
    LANGUAGE plpgsql
    AS $$
declare
  /**
    PROPOSE: Efetuar uma varedura completa nas tabelas verificação por modificações
      diferente das últimas que foram versionadas e colletalas para que sejas versionadas

    args := {
      regclass:[]
    }
   */
  _regclass regclass[] default array( select e.text::regclass from jsonb_array_elements_text( args->'regclass')e ( text ) );
begin
  if array_length( _regclass, 1 )  = 0 then _regclass := null; end if;

  return query
    with __foregin_key as (
      select
        tc.constraint_name,
        format( '%s.%s', tc.table_schema, tc.table_name )::regclass as local_table,
        kcu.column_name as local_column,
        format( '%s.%s',  ccu.table_schema, ccu.table_name )::regclass as foreign_table,
        ccu.column_name AS foreign_column_name
      from
        information_schema.table_constraints tc
          join information_schema.key_column_usage kcu on tc.constraint_name = kcu.constraint_name
          and  tc.table_schema = kcu.table_schema
          join information_schema.constraint_column_usage ccu on ccu.constraint_name = tc.constraint_name
          and ccu.table_schema = tc.table_schema
      where tc.constraint_type = 'FOREIGN KEY'
    ), __share as (
      select
        local_table,
        s.share_regclass,
        array_agg( foreign_table ),
        count( * ) as depencies,
        count( * ) filter ( where foreign_table = local_table ) as self
      from __foregin_key fk
        inner join cluster.share s on fk.local_table = s.share_regclass
      where s.share_regclass = any ( coalesce(_regclass, array[ s.share_regclass ]))
      group by local_table,
        s.share_regclass
    )
    select (cluster.__add( s.share_regclass )).*
      from __share s
      order by
        case
          when s.depencies = 0 then 1
          when s.depencies = s.self then 2
          else 3
        end,
        s.depencies,
        s.self
  ;
end;
$$;


--
-- TOC entry 470 (class 1255 OID 16596)
-- Name: constant(); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constant() RETURNS map.constant
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  /**
        Essa função serve para carregar os valores das constante e inicia-la
       */
select
  jsonb_populate_record(
      null::map.constant,
      jsonb_object_agg( cv.constvalue_name, cv.constvalue_value )
    )
from map.constvalue cv;
$$;


--
-- TOC entry 656 (class 1255 OID 16597)
-- Name: can_send_object(cluster.object, cluster.collector, cluster.cluster, cluster.cluster, cluster.cluster, cluster.cluster, cluster.cluster, map.constant); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.can_send_object(_object cluster.object, _collector cluster.collector, _origin cluster.cluster, _request cluster.cluster, _local cluster.cluster, _master cluster.cluster, _child cluster.cluster, _const map.constant DEFAULT map.constant()) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  begin

--   raise exception 'sshsnjsd nsd';
    -- Quando o custer PEDITNTE testiver no mesmo path que o cluster origem [OK]
    if _origin.cluster_path = _request.cluster_path then return true; end if;

    -- QUANDO TANTO O CLUSTER PEDINTE E O CLUSTER LOCAL ESTIVEREM EM PATH DIFERENTE [NEGAR]
    if not ( cluster.__is_sub_path( _request.cluster_path, _origin.cluster_path )
      or cluster.__is_sub_path( _origin.cluster_path, _request.cluster_path ) )
    then return false; end if;


    -- QUANDO O CLUSTER ORIGEM FOR SUBPATH DO CLUSTER PEDINTE E O CLUSTER PEDINTE ACEITA REVISÕES INFERIOR [OK]
    if _const.cluster_grant_revision_sub_path = any( _request.cluster_grants )
      and cluster.__is_sub_path( _request.cluster_path, _origin.cluster_path )
    then return true; end if;

    -- QUANDO O CLUSTER ORIGEM FOR O SUPER-PATH DO CLUSTER PEDINTE E O CLUSTER PEDINTE ACEITAR REVISÕS DE CAMINHO SUPERIOR [OK]
    if _const.cluster_grant_revision_supper_path = any( _request.cluster_grants )
      and cluster.__is_sub_path( _origin.cluster_path, _request.cluster_path  )
    then return true; end if;

    -- QUANDO O CLUSTER PEDINTE FOR O MASTER E O CLUSTER ORIGEN FOR LOCAL E O CLUSTER LOCAL SALVA REVISÕES NO MASTER [OK!]
    if _request.cluster_identifier = _master.cluster_identifier
      and _local.cluster_identifier = _origin.cluster_identifier
      and _const.cluster_grant_revision_child = any( _local.cluster_grants )
    then return true; end if;

    -- QUANDO O CLUSTER PEDINTE FOR UM FILHO DO CLUSTER LOCAL E A ORIGEM FOR CLUSTER LOCAL
    if _request.cluster_identifier = _child.cluster_identifier
      and _origin.cluster_identifier = _local.cluster_identifier
    then  return true; end if;

    return false;
  end;
$$;


--
-- TOC entry 657 (class 1255 OID 16598)
-- Name: can_send_revision(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.can_send_revision(args jsonb) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_identifier
      cluster_path
      cluster_grants
    }
   */
  _remote cluster.cluster;
  _master cluster.cluster;

  _local cluster.cluster;
  _remote_child cluster.cluster;
  _local_is_master_of_remote boolean;
  _local_is_child_of_remote boolean;
  _local_is_sub_path_of_remote boolean;
  _const map.constant;

begin
  _const := map.constant();
  _remote := jsonb_populate_record( _remote, args );
  _local := cluster._get_cluster_local();
  _master := cluster._get_cluster_master();

  _local.cluster_path := coalesce( _local.cluster_path, '/' );
  _remote.cluster_path := coalesce( _remote.cluster_path, '/' );

--   if _local.cluster_identifier = _remote.cluster_identifier then return; end if;
  if _local.cluster_identifier = _remote.cluster_identifier then return false; end if;

    select * into _remote_child
      from cluster.cluster c
      where c.cluster_identifier = _remote.cluster_identifier
        and c.cluster_type = _const.cluster_tcluster_child
  ;

--   return next jsonb_build_object(
--     '01', _local.cluster_path = _remote.cluster_path,
--     '02', _local_is_master_of_remote,
--     '03', _local_is_sub_path_of_remote and _const.cluster_grant_revision_sub_path = any( _remote.cluster_grants ) ,
--     '04',  _local_is_child_of_remote and _const.cluster_grant_revision_child = any( _local.cluster_grants )
--   );

  _local_is_master_of_remote := _remote_child.cluster_identifier is not null;
  _local_is_sub_path_of_remote := cluster.__is_sub_path( _remote.cluster_path, _local.cluster_path );
  _local_is_child_of_remote := _master.cluster_identifier = _remote.cluster_identifier;

  return (
    coalesce( _local.cluster_path = _remote.cluster_path, false )
      or coalesce( _local_is_master_of_remote, false )
      or coalesce( _local_is_sub_path_of_remote and _const.cluster_grant_revision_sub_path = any( _remote.cluster_grants ), false )
      or coalesce( _local_is_child_of_remote and _const.cluster_grant_revision_child = any( _local.cluster_grants ), false )
  );
end;
$$;


--
-- TOC entry 577 (class 1255 OID 16599)
-- Name: change(jsonb, text[]); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.change(jsonb, VARIADIC keys text[]) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  with __values as (
    select *
      from jsonb_each( $1 ) e
      where e.key = any ( keys )
  ) select jsonb_object_agg( e.key, e.value )
  from __values e
$_$;


--
-- TOC entry 658 (class 1255 OID 16600)
-- Name: commit(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.commit(args jsonb) RETURNS SETOF cluster.version
    LANGUAGE plpgsql
    AS $$
declare
  /**
    PROPOSE: Versionar tadas as modificações ocoridas na tabala já coletada
   */
begin

  return query
    with __foregin_key as (
      select
        tc.constraint_name,
        format( '%s.%s', tc.table_schema, tc.table_name )::regclass as local_table,
        kcu.column_name as local_column,
        format( '%s.%s',  ccu.table_schema, ccu.table_name )::regclass as foreign_table,
        ccu.column_name AS foreign_column_name
      from
        information_schema.table_constraints tc
          join information_schema.key_column_usage kcu on tc.constraint_name = kcu.constraint_name
          and  tc.table_schema = kcu.table_schema
          join information_schema.constraint_column_usage ccu on ccu.constraint_name = tc.constraint_name
          and ccu.table_schema = tc.table_schema
      where tc.constraint_type = 'FOREIGN KEY'
    ), __share as (
      select
        local_table,
        s.share_regclass,
        array_agg( foreign_table ),
        count( * ) as depencies,
        count( * ) filter ( where foreign_table = local_table ) as self
      from __foregin_key fk
        inner join cluster.share s on fk.local_table = s.share_regclass
      group by local_table,
        s.share_regclass
    )
    select (cluster.__create_object_version( s.share_regclass )).*
      from __share s
      order by
        case
          when s.depencies = 0 then 1
          when s.depencies = s.self then 2
          else 3
        end,
        s.depencies,
        s.self
  ;
end;
$$;


--
-- TOC entry 240 (class 1259 OID 16601)
-- Name: resource; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.resource (
    resource_identifier character varying NOT NULL,
    resource_cluster character varying NOT NULL,
    resource_name character varying NOT NULL,
    resource_subpath character varying,
    resource_extension character varying,
    resource_reference character varying NOT NULL,
    resource_url character varying NOT NULL,
    resource_metadata jsonb DEFAULT jsonb_build_object() NOT NULL,
    resource_version smallint DEFAULT 1 NOT NULL,
    resource_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    resource_update timestamp with time zone
);


--
-- TOC entry 660 (class 1255 OID 16609)
-- Name: create_resource(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.create_resource(args jsonb) RETURNS cluster.resource
    LANGUAGE plpgsql
    AS $_$
declare
  /*
    args := {
      resource_name character varying
      resource_subpath character varying
      reference_extension character varying
      reference_metadata jsonb not null default jsonb_build_object()
    }
   */
  _local cluster.cluster;
  _res cluster.resource;
  _letters character varying default 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  _number character varying default '0123456789';
  _rec record;
begin
  _local := cluster._get_cluster_local();
  _res := jsonb_populate_record( _res, args );

  _res.resource_cluster := upper( _local.cluster_identifier );
  _res.resource_identifier := format( '%s-%s-%s',
    lib.dset_random_text( _letters, 6 ),
    lib.dset_random_text( format( '%s%s', _letters, _number), 8 ),
    lib.dset_random_text( _number, 4 )
  );

  while exists(
    select *
      from cluster.resource r
      where r.resource_identifier = _res.resource_identifier
        and r.resource_cluster = _res.resource_cluster
  ) loop
      _res.resource_identifier := format( '%s-%s-%s',
        lib.dset_random_text( _letters, 6 ),
        lib.dset_random_text( format( '%s%s', _letters, _number), 8 ),
        lib.dset_random_text( _number, 4 )
      );
  end loop;

  for _rec in
    select *
      from unnest( array[
        '/', '\', '-', ' ', ':', '%', '$', '*', '?', '=', '"', '&',
        $c$'$c$,
       --  '(', ')', '[', ']',
        '{', '}'
      ]::text[]) c ( character )
  loop
    _res.resource_name := replace( _res.resource_name, _rec.character, '_' );
  end loop;

  _res.resource_name := lower( _res.resource_name );
  _res.resource_subpath := (
    with __sub as (
      select part
        from regexp_split_to_table( _res.resource_subpath, '/' ) part
        where part is not null and part.length > 0
    ) select string_agg( part, '/' )
      from __sub
  );

  _res.resource_reference := (
    with _path_part as (
      select path_part
        from regexp_split_to_table(
          format( '%s/%s/%s',
            _res.resource_cluster,
            _res.resource_subpath,
            _res.resource_identifier
          ), '/'
        ) t( path_part )
        where path_part is not null
          and length( path_part ) > 0
    ) select string_agg( _p.path_part, '/' )
      from _path_part _p
  );

  _res.resource_url := format( '%s/%s', _res.resource_reference, _res.resource_name );
  _res.resource_reference := format( '%s-%s', _res.resource_reference, _res.resource_name );

  if _res.resource_extension is not null and length( _res.resource_extension ) > 0 then
    _res.resource_reference := format( '%s.%s', _res.resource_reference, _res.resource_extension );
    _res.resource_url := format( '%s.%s', _res.resource_url, _res.resource_extension );
  end if;

  select ("returning" ).* into _res
    from lib.sets_in( _res );

  return _res;
end
$_$;


--
-- TOC entry 407 (class 1255 OID 16610)
-- Name: declare_filter(regnamespace, character varying, regclass, character varying); Type: PROCEDURE; Schema: cluster; Owner: -
--

CREATE PROCEDURE cluster.declare_filter(IN regnamespace, IN name character varying, IN share regclass DEFAULT NULL::regclass, IN describe character varying DEFAULT NULL::character varying)
    LANGUAGE plpgsql
    AS $_$
declare
  _regp character varying;
  _statement text;
begin
  _regp := format( '%I.%I', $1, name );

  --language=PostgreSQL
  _statement := format( $sql$
    create function __func_ ( share character varying, _object cluster.object, _collector cluster.collector, _req cluster.cluster, _origin cluster.cluster )
    returns boolean
    language plpgsql as $body$
      declare
      begin
        -- Accepted object
        -- return false;

        -- Accepted object
        return true;
      end;
    $body$
  $sql$ );

  _statement := replace( _statement, '__func_', _regp );
  execute _statement;

  insert into cluster.filter(
    filter_regclass,
    filter_regproc,
    filter_name,
    filter_describe
  ) values (
    cluster.__format( share ),
    _regp::regproc::text,
    name,
    describe
 );
end;
$_$;


--
-- TOC entry 661 (class 1255 OID 16611)
-- Name: define_namespace(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.define_namespace(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_uid: UID
      cluster_namespace: NAMESPACE
    }
   */
  _cluster cluster.cluster;
  _chars character varying[] = regexp_split_to_array( lower( 'ABCDEFGHIJKLMNOPQRSTUVWXYZ-0123456789_'), '' );
  _check record;
begin
  _cluster := jsonb_populate_record( _cluster, args );
  _cluster.cluster_namespace := lower( _cluster.cluster_namespace );
  
  select 
      string_agg( format( '%I posição %s', c.character, c.ordinality ), ', ' ) characters,
      count( * ) as count
      into _check
    from  unnest( regexp_split_to_array( _cluster.cluster_namespace, '' ) ) with ordinality c( character )
    where not c = any( _chars);
  
  if _check.count > 0 then 
    return lib.res_false( format( 'Namespace está invalido! caracteres: %s', _check.characters ) );
  end if;
  
  _cluster.cluster_namespace := lib.str_normalize( _cluster.cluster_namespace );
  if _cluster.cluster_namespace is null then
    return lib.res_false( 'Namespace está invalido ou não definido!' );
  end if;
  
  select ("returning").* into _cluster
    from lib.sets_up( _cluster, ref := lib.sets_ref(_cluster));
  
  return lib.result_true( jsonb_build_object(
    'cluster', _cluster
  ));
end;
$$;


--
-- TOC entry 662 (class 1255 OID 16612)
-- Name: funct_load_configs(); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.funct_load_configs() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
  declare
    _local cluster.cluster;
    _master cluster.cluster;
    _branch record;
    _source record;
  begin
    _local := cluster._get_cluster_local();
    _master := cluster._get_cluster_master();
    
    select 
        array_agg( b.branch_uid ) as branch_uid,
        array_agg( b ) as branch
        into _branch
      from cluster.branch b
        inner join source s2 on b.branch_uid = s2.source_branch_uid
      where s2.source_cluster_uid = _local.cluster_uid
    ;
    
    select 
        array_agg( s.source_uid ) as source_uid,
        array_agg( s ) as source
        into _source
      from cluster.source s
        inner join cluster c on s.source_cluster_uid = c.cluster_uid
      where s.source_branch_uid = any ( _branch.branch_uid )
    ;
    
    return jsonb_build_object(
      'local', _local,
      'master', _master,
      'branch', _branch.branch, 
      'branch_uid', _branch.branch_uid, 
      'sources', _source.source,
      'sources_uid', _source.source_uid
    );
  end;
  $$;


--
-- TOC entry 663 (class 1255 OID 16613)
-- Name: funct_reg_acesso(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.funct_reg_acesso(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para dar acesse de um menu ao um colaborador
    -- Para dar acess o colaborador não pode ter previamente o acesso ao menu
    args := {
      arg_colaborador_id: ID,
      arg_colaborador_propetario: ID,
      arg_menu_list: [
        ID, ID, ID
      ]
    }
      -- arg_colaborador_id corresponde ao colaborador que esta a definir os previlegio de acesso
      -- arg_colaborador_propetario corresponde ao colaborador que tera o acesso definido
      -- arg_menu_ids corresponde a lista de identificadores do menus que o colaborador tera acesso
   */

  arg_colaborador_id uuid          := args->>'arg_colaborador_id';
  arg_colaborador_propetario uuid  := args->>'arg_colaborador_propetario';
  arg_menu_list int2[]                := array( select jsonb_array_elements_text( args->'arg_menu_list' )::int2 );

  arg_acesso_lista auth.acesso[];
  arg_branch_uid uuid default args->>'_branch_uid';

  _const map.constant;
begin

    _const := map.constant();

  -- Revogar os menus que o colaborador tinha acesso anteriormente mas atualmente já nao os têm
  -- São menus que aperecem no acesso ativo mas nao aperencem na nova lista de menus a ser dado ao colaborador
  update auth.acesso
    set acesso_estado = _const.acesso_estado_fechado,
        acesso_dataatualizacao = current_timestamp,
        acesso_colaborador_atualizacao = arg_colaborador_id
    where acesso_estado = _const.acesso_estado_ativo
      and acesso_colaborador_propetario = arg_colaborador_propetario
      and acesso_menu_id != all( arg_menu_list )
  ;

  -- Registrar para o colaborador apenas menus listado na lista que estão em faltas
  insert into auth.acesso(
    acesso_menu_id,
    acesso_colaborador_propetario,
    acesso_colaborador_id,
    _branch_uid
  ) select
      me.menu_id,
      arg_colaborador_propetario,
      arg_colaborador_id,
      arg_branch_uid
    from unnest( arg_menu_list ) un ( menu_id )
      inner join auth.menu me on un.menu_id = me.menu_id
      left join auth.acesso ac on me.menu_id = ac.acesso_menu_id
        and ac.acesso_estado = _const.acesso_estado_ativo
        and ac.acesso_colaborador_propetario = arg_colaborador_propetario
    where ac.acesso_id is null
  ;

  -- Obter todos os acessos ativos para esse colaborador
  select array_agg( ac ) into arg_acesso_lista
    from auth.acesso ac
    where ac.acesso_colaborador_propetario = arg_colaborador_propetario
      and ac.acesso_estado = _const.acesso_estado_ativo
  ;

  return lib.result_true(
    jsonb_build_object(
      'acesso', arg_acesso_lista
    )
  );

end;
$$;


--
-- TOC entry 588 (class 1255 OID 16614)
-- Name: load_cluster_by_namespace(character varying); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.load_cluster_by_namespace(namespace character varying) RETURNS SETOF jsonb
    LANGUAGE sql
    AS $$
    select to_jsonb( c ) from cluster.cluster c where cluster_namespace = namespace;
  $$;


--
-- TOC entry 664 (class 1255 OID 16615)
-- Name: load_clusters(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.load_clusters(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _const map.constant;
begin
  _const := map.constant();
  return query with
    __cluster as (
      select
          c.cluster_uid,
          c.cluster_identifier,
          c.cluster_type,
          c.cluster_code,
          c.cluster_path,
          c.cluster_domain,
          c.cluster_licenselife,
          c.cluster_license,
          case
            when c.cluster_name is null and c.cluster_type = _const.cluster_tcluster_local then 'Local server'
            else c.cluster_name
          end as cluster_name,
          c.cluster_port,
          c.cluster_api,
          c.cluster_version,
          c.cluster_grants,
          c.cluster_configs,
          c.cluster_sequence,
          tp.*
        from cluster.cluster c
          left join cluster.tperiod tp on c.cluster_tperiod_id = tp.tperiod_id
    ) select to_jsonb( _c )
      from __cluster _c
      order by case
        when _c.cluster_type = _const.cluster_tcluster_local then 1
        when _c.cluster_type = _const.cluster_tcluster_master then 2
        when _c.cluster_type = _const.cluster_tcluster_child then 3
        when _c.cluster_type = _const.cluster_tcluster_remote then 4
      end,
      _c.cluster_name
  ;
end;
$$;


--
-- TOC entry 665 (class 1255 OID 16616)
-- Name: load_clusters_configs_to_child(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.load_clusters_configs_to_child(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_identifier: PATH
      cluster_api: PATH
      cluster_key
    }
   */
  _const map.constant;
  _cluster cluster.cluster;
begin
  _const := map.constant();
  _cluster := jsonb_populate_record( _cluster, args );

  if not exists(
      select *
      from cluster.cluster c
      where c.cluster_api = _cluster.cluster_api
        and c.cluster_identifier = _cluster.cluster_identifier
        and c.cluster_type = _const.cluster_tcluster_child
    ) then
    return;
  end if;

  return query with
     __cluster as (
       select
         c.cluster_identifier,
         case
           when c.cluster_type = _const.cluster_tcluster_child then _const.cluster_tcluster_local
           when c.cluster_type = _const.cluster_tcluster_local then _const.cluster_tcluster_master
           end as cluster_type,

         case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_key
           end as cluster_key,

         case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_configs
           else jsonb_build_object()
           end as cluster_configs,

         case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_grants
           else array[ ]::text[ ]
           end as cluster_grants,

         coalesce( c.cluster_path, '/' ) as cluster_path,

         case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_license
           end as cluster_license,
         case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_code
           end as cluster_code,

        case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_licenselife
           end as cluster_licenselife,

        case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_tperiod_id
           end as cluster_tperiod_id,

        case
           when c.cluster_type = _const.cluster_tcluster_child then c.cluster_namespace
           end as cluster_namespace,
       
         c.cluster_name
       
       
       from cluster.cluster c
       where c.cluster_type = _const.cluster_tcluster_local
          or ( c.cluster_identifier = _cluster.cluster_identifier and c.cluster_type = _const.cluster_tcluster_child )
     ) select
     case
       when _c.cluster_type = _const.cluster_tcluster_master and _c.cluster_name is null then to_jsonb( _c )
        - 'cluster_key'
        || jsonb_build_object( 'cluster_name', 'Main Master (trunc)' )
       else to_jsonb( _c )
       end
   from __cluster _c
  ;
end
$$;


--
-- TOC entry 653 (class 1255 OID 16617)
-- Name: load_clusters_local_as_remotes(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.load_clusters_local_as_remotes(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_path: PATH,
      cluster_grants:grants
    }
   */
  _cluster cluster.cluster;
  _const map.constant;
begin
  _const := map.constant();
  _cluster := jsonb_populate_record( _cluster, args );



  return query with
    __cluster as (
      select
          c.cluster_identifier,
          c.cluster_name,
          c.cluster_path,
          _const.cluster_tcluster_remote as cluster_type
        from cluster.cluster c
        where c.cluster_type = _const.cluster_tcluster_local
          and cluster.can_send_revision( args )
    ) select to_jsonb( _c )
      from __cluster _c
  ;
end;
$$;


--
-- TOC entry 659 (class 1255 OID 16618)
-- Name: load_paths(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.load_paths(args jsonb DEFAULT json_build_object()) RETURNS SETOF text
    LANGUAGE sql
    AS $$ select distinct lower( cluster_path ) from cluster.cluster where cluster_path is not null order by lower( cluster_path ) $$;


--
-- TOC entry 666 (class 1255 OID 16619)
-- Name: load_resources_pendents(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.load_resources_pendents(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
begin
  _cluster := jsonb_populate_record( _cluster, args );
  _cluster := cluster._get_cluster( _cluster.cluster_identifier );
  return query
    with __object as (
      select
          o.object_uid,
          o.object_transuid as collector_transuid,
          o.object_ref,
          res.*
        from cluster.object o
          inner join cluster.resource res on lib.sets_ref( res ) = o.object_ref
        where o.object_share_regclass::regclass = 'cluster.resource'::regclass
          and o.object_status = 2
          and _cluster.cluster_uid in ( o.object_cluster_origin, o.object_cluster_receiver )
    ) select to_jsonb( _o )
        from __object _o;
end;
$$;


--
-- TOC entry 667 (class 1255 OID 16620)
-- Name: next(character varying, character varying, boolean, integer, integer, character, text, integer); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.next(name character varying, sub character varying DEFAULT NULL::character varying, zero_base boolean DEFAULT false, steep integer DEFAULT 1, lpad integer DEFAULT 0, lpad_char character DEFAULT ''::bpchar, exist text DEFAULT NULL::text, exist_limit integer DEFAULT 1000) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _sequence cluster.sequence;
  _cluster cluster.cluster;
  _repeat boolean default true;
  _next_value character varying;
  _record record;
  _iterate int default 0;
begin

  if sub is null then sub := ''; end if;
  if next.name is null then
    raise exception 'Sequence name is required!';
  end if;

  if next.steep = 0 then
    raise exception 'Sequence steep can not by zero!';
  end if;

  if exist is not null then
    exist_limit := coalesce( exist_limit, 1000 );
  end if;

  _cluster := cluster._get_cluster_local();

  while _repeat loop

    update cluster.sequence
      set sequence = sequence.sequence + sequence.steep
      where sequence.name = next.name
        and  next.sub = sequence.sub
      returning * into _sequence
    ;

    if _sequence.name is null then
      next.zero_base := coalesce( next.zero_base, false );
      next.steep := coalesce( next.steep, 1 );

      insert into cluster.sequence ( name, steep, zerobase, lpad, lpad_char, sub, sequence )
        values ( next.name, next.steep , next.zero_base, next.lpad, next.lpad_char, next.sub,
          case
            when next.zero_base then next.steep
            else next.steep
          end
        )
      returning * into _sequence;
    end if;

    if _sequence.zerobase then
      _sequence.sequence := _sequence.sequence + case
        when _sequence.steep > 0 then -1
        else 1
      end;
    end if;

    _next_value :=  format( '%s%s', _cluster.cluster_code, lpad( _sequence.sequence::text, greatest( _sequence.lpad, length( _sequence.sequence::text ) ), _sequence.lpad_char ) );
    _repeat := false;

    if exist is not null then
      <<find_duplicate>>
      for _record in execute exist using _next_value loop
        _repeat := true;
        exit find_duplicate;
      end loop;
    end if;

    _iterate := _iterate +1;
    if _iterate = exist_limit then
      raise exception 'Next code generation limit';
    end if;
  end loop;

  return _next_value;
end
$$;


--
-- TOC entry 668 (class 1255 OID 16621)
-- Name: object_filter(character varying, cluster.object, cluster.collector, cluster.cluster, cluster.cluster); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.object_filter(share character varying, _object cluster.object, _collector cluster.collector, _req cluster.cluster, _origin cluster.cluster) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  _validator record;
  _statement text;
  _result boolean;
begin

  $4.cluster_path := coalesce( $4.cluster_path, '/' );
  $5.cluster_path := coalesce( $5.cluster_path, '/' );


  -- Quando os cluster origem e o cluster requerente não tiver nehuma relação com os seus caminho
  -- Então reistar
  if _req.cluster_path != _origin.cluster_path
    and not cluster.__is_sub_path( _req.cluster_path, _origin.cluster_path )
    and not cluster.__is_sub_path( _origin.cluster_path, _req.cluster_path )
  then return false;
  end if;

  for _validator in
    select *
      from cluster.filter f
      where  share = coalesce( f.filter_regclass, share )
  loop
    _statement := format( 'select %s( $1, $2, $3, $4, $5 )', _validator.filter_regproc );
    execute _statement into _result using $1, $2, $3, $4, $5;
    if not _result then return false; end if;
  end loop;
  return true;
end
$_$;


--
-- TOC entry 669 (class 1255 OID 16622)
-- Name: pull(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.pull(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /**
      PROPOSE: Descaregar para o cluster local todas as modificações vinda dos outros cluster
      args := {
        server:ClusterSource,
        objects:( ObjectRevision[] )| DynamicReducer|any,
        ignores:cluster.ignore[]
        result:ClusterResult[]
        total:number
        limit:number,
        revCode:number,
        rejected:number,
      }
    */
    _limit int default args->>'limit';
    _server cluster.cluster;
    _cluster cluster.cluster;
    _local cluster.cluster;
    _data record;
    _i record;
    _obj jsonb default args->'objects';
    _objests cluster.object[] default array[]::cluster.object[];
    _next cluster.object;
    _pull cluster.pull;
  begin
    _pull.pull_server     :=  args->'server';
    _pull.pull_objects    :=  args->'objects';
    _pull.pull_ignores    :=  args->'ignores';
    _pull.pull_result     :=  args->'result';
    _pull.pull_total      :=  args->>'total';
    _pull.pull_limit      :=  args->>'limit';
    _pull.pull_revcode    :=  args->>'revCode';
    _pull.pull_rejected   :=  args->>'rejected';
    
    select ( "returning" ).* into _pull
      from lib.sets_in( _pull )
    ;
    
    _server := jsonb_populate_record( _server, args->'server');
    _cluster := cluster._get_cluster( _server.cluster_identifier );
    _local := cluster._get_cluster_local(  );

    with __object as (
      select o.*
        from jsonb_array_elements( _obj ) e( document )
          inner join jsonb_populate_record( null::cluster.object, e.document ) o on true
    ) select max( _o.object_seq ) as _cluster_sequence
      into _data
        from __object _o
    ;

    set session_replication_role to replica;

    for _i in
      with __map as (
        select
            obj as _object,
            col as _collector,
            ( e.document->>'_origin_identifier' ) as _origin_identifier,
            coalesce( cmp.classnameref, e.document->>'_regclass' ) as _classname,
            e.document->'_change' as _change,
            e.document->>'_result' as _result,
            ( e.document->>'_regclass' )::regclass as _regclass,
            col.collector_uid as current_collector_uid,
            col.collector_transuid as current_transuid
          from jsonb_array_elements( args->'objects' ) e ( document )
            inner join jsonb_populate_record( null::cluster.object, e.document ) as obj on true
            inner join jsonb_populate_record( null::cluster.collector, e.document ) as col on true
            left join cluster.classmap cmp on e.document->>'_regclass' = cmp.classname
      ), __objects as (
        select
            v.*,
            co.cluster_uid as _origin,
            _cluster.cluster_uid as _receiver,
            ( v._object ).object_ref,
            ( v._object ).object_date,
            ( v._object ).object_uid,
            ( v._collector ).collector_uid,
            ( v._collector ).collector_transuid
          from __map v
            inner join cluster.cluster co on co.cluster_identifier =  v._origin_identifier

    ), __classnames as (
        select array_agg( distinct  mp._classname) as allclass
        from __map mp
    
      ), __row as (
        select _r.*
          from __classnames
          inner join cluster.__rows( variadic allclass ) _r on true

      ), __current as (
        select
            _up.object_ref,
            _up._classname,
            e.document as _current,
            max( ob.object_date ) as date
          from __objects _up
            left join __row e  on e.classname = _up._regclass
              and e.reference = _up.object_ref 
            left join cluster.object ob on ob.object_share_regclass = _up._classname
              and ob.object_ref = _up.object_ref
          group by
            _up.object_ref,
            _up._classname,
            e.document
          
      ), __new as (
        select
            _ob.*,
            _cur.*,
            _created_object.object_uid is not null as _exists_object,
            _create_collector.collector_uid is not null _exists_collector,
            _cur._current is null as _exists_ref,
            (
                _cur._current is not null -- Desatualiazado: Quando já existir previamente a instancia do objecto na tabela
                and _cur.date is not null -- Desatualiazado: & Quando ja existir pelo menus algum objecto para essa referencia
                and _cur.date > _ob.object_date -- Desatualizado: & Quando a data a instancia atual for superior a data do objecto recebido

--               not all: _cur._current is null -- Quando ainda não existir a instancia do dado na tabela
--               or  _cur.date is null -- Ainda não existir nenhuma revisão para a referencia do objecto
--               or _cur.date < _ob.object_date -- Data da ultima revisão registrada for inferior a data da reisão recebida
            ) as _outdate
          from __objects _ob
            inner join __current _cur on _ob.object_ref = _cur.object_ref and _ob._classname = _cur._classname

            -- object_uid, object_share_regclass, object_cluster_origin
            left join cluster.object _created_object on
              ( _ob ).object_uid = _created_object.object_uid
              and ( _ob ).collector_transuid = _created_object.object_transuid
              and _cur._classname = _created_object.object_share_regclass
              and ( _ob )._origin = _created_object.object_cluster_origin

            -- collector_uid, collector_transuid, collector_share_regclass, collector_cluster_origin
            left join cluster.collector _create_collector on
              ( _ob ).collector_uid = _create_collector.collector_uid
              and ( _ob ).collector_transuid = _create_collector.collector_transuid
              and _cur._classname  = _create_collector.collector_share_regclass
              and ( _ob )._origin = _create_collector.collector_cluster_origin
        ) select  *
      from __new
    loop
      _next := cluster.__pull( to_jsonb( _i ) );
      if _next.object_uid is not null then
        _objests := _objests || _next;
      end if;

    end loop;
    set session_replication_role to default;

    return query
      with __object as (
        select (o::cluster.object).*
          from unnest( _objests ) o
      ), __collector as (
        select
            _o.*,
            c.*,
            _o.object_share_regclass as _regclass,
            cc.cluster_identifier as _origin_identifier
          from __object _o
          inner join cluster.collector c on _o.object_collector_uid = c.collector_uid
            and _o.object_transuid = c.collector_transuid
            and _o.object_cluster_origin = c.collector_cluster_origin
          inner join cluster.cluster cc on _o.object_cluster_origin = cc.cluster_uid
      )select to_jsonb( _c )
        from __collector _c
    ;

    -- Atualizar a versão do cluster
    with
    __result as (
      select
          pc.cluster_identifier,
          coalesce( pc.cluster_version, 0 ) as cluster_version,
          coalesce( pc.cluster_sequence, 0 ) as cluster_sequence
        from jsonb_array_elements( args->'result') e( doc )
          inner join jsonb_populate_record( null::cluster.cluster, e.doc ) pc on true
    ), __clusters as (
      select
          c.cluster_identifier,
          c.cluster_sequence,
          max( o.object_origincver ) as object_origincver,
          max( o.object_seq ) as object_seq
        from cluster.object o
          inner join cluster.cluster c on c.cluster_uid = o.object_cluster_origin
        where o.object_cluster_origin != _local.cluster_uid
        group by c.cluster_uid

    ), __status as (
      select
          _r.cluster_identifier,
          case
            when _c.cluster_identifier = _server.cluster_identifier then _r.cluster_version
            when _c.object_origincver >= _r.cluster_version then _c.object_origincver
            else _r.cluster_version
          end as cluster_version,
          case
            when _c.cluster_identifier = _server.cluster_identifier then _r.cluster_sequence
            when _c.cluster_sequence >= _r.cluster_sequence then _c.cluster_sequence
            else _r.cluster_sequence
          end as cluster_sequence
        from __clusters _c
          inner join __result _r on _c.cluster_identifier = _r.cluster_identifier

    ) update cluster.cluster c
        set
          cluster_version = _s.cluster_version,
          cluster_sequence = _s.cluster_sequence,
          cluster_verbose = case
            when _s.cluster_identifier = _cluster.cluster_identifier
              and _limit is not null
              and _limit > jsonb_array_length( _obj ) then false
            else c.cluster_verbose
          end
        from __status _s
        where c.cluster_identifier = _s.cluster_identifier
    ;

    with __ignore as (
      select _pi.*
        from jsonb_array_elements( args->'ignores' ) e( doc )
          inner join jsonb_populate_record( null::cluster.ignore, e.doc ) _pi on true
    ) insert into cluster.ignore
        select _ignor.*
        from __ignore _ignor
    ;
    
    update cluster.pull
      set pull_status = 1,
          pull_pulled = to_jsonb( _objests )
      where pull_uid = _pull.pull_uid;

    return query
      with __clusters as (
        select
            c.cluster_identifier,
            c.cluster_name,
            c.cluster_path,
            c.cluster_version,
            c.cluster_sequence
          from cluster.cluster c
      ) select jsonb_agg( _c )
        from __clusters _c;
  end;
$$;


--
-- TOC entry 670 (class 1255 OID 16624)
-- Name: push(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.push(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    PROPOSE: Devolver as modificações que o cluster cliente tem em falta
      Push funciona relativamente ao cluster cliente
    args := {
      request:*CLUSTER{
        cluster_identifier
        cluster_path,
        cluster_grants
      }
      limit:row limit
      clusters :[  -- all cluster include request
          cluster_identifier: CID -- request cluster
          cluster_sequence:   CSE
          cluster_version:    CVE
          cluster_verbose:    CVB
      ]
    }
   */
  _local cluster.cluster;
  _master cluster.cluster;
  _child cluster.cluster;
  _request cluster.cluster;
  _const map.constant;
  _limit int8 default args->>'limit';
  _cluster cluster.cluster;
begin
  _const := map.constant();
  _local := cluster._get_cluster_local();
  _master := cluster._get_cluster_master();
  _request := jsonb_populate_record( _request, args->'request' );
  _child := cluster._get_cluster_child( _request.cluster_identifier );
  select * into _cluster
    from cluster.cluster c
    where c.cluster_identifier = _request.cluster_identifier
  ;

  if _cluster.cluster_identifier is null then return; end if;
  if _cluster.cluster_type = _const.cluster_tcluster_child then
    _request := _cluster;
  else
    _request.cluster_uid = _cluster.cluster_uid;
  end if;

  return query
    with  __clusters_statuas as (
      select
          ( e.doc->>'cluster_identifier' ) as cluster_identifier,
          ( e.doc->>'cluster_identifier' ) = _request.cluster_identifier as _is_cluster_to,
          ( e.doc->>'cluster_version' )::int8 as cluster_version,
          ( e.doc->>'cluster_sequence' )::int8 as cluster_sequence,
          ( e.doc->>'cluster_verbose' )::boolean as cluster_verbose
        from jsonb_array_elements( args-> 'clusters' ) e( doc )

    ), __clusters as (
      select _cs.*,
             c.cluster_uid
        from __clusters_statuas _cs
          inner join cluster.cluster c on _cs.cluster_identifier = c.cluster_identifier

    ), __objects as (
      select
          o.*,
          o as _obj,
          array_agg( cluster.change( col.collector_metadata, variadic col.collector_changes )
            order by oi.object_seq
          ) as _change
        from  cluster.object o
          left join __clusters _co on o.object_cluster_origin = _co.cluster_uid
          left join cluster.object oi on o.object_seq > _co.cluster_sequence
            and o.object_ref = oi.object_ref
            and o.object_share_regclass = oi.object_share_regclass
            and oi.object_seq <= o.object_seq
          left join cluster.collector col on oi.object_collector_uid = col.collector_uid
            and oi.object_transuid = col.collector_transuid
            and oi.object_share_regclass = col.collector_share_regclass
            and oi.object_ref = col.collector_ref

        where o.object_seq > _co.cluster_sequence
          and ( o.object_cluster_origin != _request.cluster_uid or _co.cluster_verbose )
          and ( o.object_cluster_receiver != _request.cluster_uid or _co.cluster_verbose )
          and o.object_originver > _co.cluster_version
        group by o.object_uid,
          o.object_share_regclass,
          o.object_cluster_origin

    ), __ranks as (
      select
          o.*,
          rank() over ( partition by o.object_ref order by o.object_seq desc ) as rank,
          min( o.object_seq ) over ( partition by o.object_ref ) as minseq
        from  __objects o
    ), __collector as (
      select
        _o.object_uid             ,
        _o.object_originver       ,
        _o.object_originsver      ,
        _o.object_origincver      ,
        _o.object_originsseq      ,
        _o.object_originrev       ,
        _o.object_date            ,
        _o.object_instant         ,
        _o.object_ref             ,
        _o.object_seq             ,

        col.collector_metadata    ,
        col.collector_changes     ,
        col.collector_transuid    ,
        col.collector_uid         ,
        col.collector_sequence    ,
        col.collector_order       ,
        col.collector_minseq      ,
        col.collector_maxseq      ,
        col.collector_date        ,
        col.collector_version     ,
        col.collector_operation   ,
        col.collector_old         ,
        col.collector_originold   ,

        _origin.cluster_identifier as _origin_identifier,
        _o.object_share_regclass   as _regclass,
        _o.rank = 1 as _result,
        coalesce( cluster.reduce( variadic _o._change ), col.collector_metadata ) as _change
      from __ranks _o
          inner join cluster.collector col on _o.object_collector_uid = col.collector_uid
            and _o.object_transuid = col.collector_transuid
            and _o.object_share_regclass = col.collector_share_regclass
            and _o.object_ref = col.collector_ref
          inner join cluster.cluster _origin on _origin.cluster_uid = _o.object_cluster_origin
        where true
         and cluster.can_send_object( _o._obj, col, _origin, _request, _local, _master, _child, _const )
      order by _o.object_seq
      limit _limit
    ) select to_jsonb( _c )
      from __collector _c;
end;
$$;


--
-- TOC entry 671 (class 1255 OID 16625)
-- Name: reduce(jsonb[]); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.reduce(VARIADIC jsonb[]) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select jsonb_object_agg( it.key, it.value order by e.index, it.index )
    from unnest( $1 ) with ordinality e( document, index )
      inner join jsonb_each( e.document ) with ordinality it( key, value, index ) on e.document ? it.key
$_$;


--
-- TOC entry 672 (class 1255 OID 16626)
-- Name: sets_cluster_configs(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_cluster_configs(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      clusters: [{
        cluster_uid
        cluster_identifier
        cluster_path
        cluster_name
        cluster_domain
        cluster_port
        cluster_key,
        cluster_license,
        cluster_licenselife,
        cluster_tperiod_id
      }]
    }
   */
  _const map.constant;
  _data record;
begin
  _const := map.constant();

  with __clusters as (
    select c as _cluster, e.doc as cluster_replace
      from jsonb_array_elements( args->'clusters' ) e( doc )
        inner join jsonb_populate_record( null::cluster.cluster, e.doc ) _clu on true
        inner join cluster.cluster c on  _clu.cluster_type = c.cluster_type
          and _clu.cluster_type in ( _const.cluster_tcluster_master, _const.cluster_tcluster_local )
  ), __sets as (
    select s."returning" as cluster
    from __clusters _c
      inner join lib.sets( _c._cluster, _c.cluster_replace ) s on true
  ) select array_agg( s.cluster ) as clusters into _data
  from __sets s
  ;

  return lib.res_true(  to_jsonb( _data ) );
end;
$$;


--
-- TOC entry 673 (class 1255 OID 16627)
-- Name: sets_cluster_license(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_cluster_license(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_uid:UID
      cluster_tperiod_id
      cluster_licenselife: NUMBER >> REPITICAO DO PERIODO
    }
   */
  _cluster cluster.cluster;
  _interval interval;
  _tperid cluster.tperiod;
  _result cluster.cluster;
begin
  _cluster := jsonb_populate_record( _cluster, args );
  select * into _tperid from cluster.tperiod where tperiod_id = _cluster.cluster_tperiod_id;

  if _cluster.cluster_licenselife > 0
    and _cluster.cluster_tperiod_id is not null
  then
    _interval := format( '%L %s',  _cluster.cluster_licenselife, _tperid.tperiod_code )::interval;
    _cluster.cluster_license := current_timestamp + _interval;

    select ( "returning" ).* into _result
      from lib.sets( _cluster );

    return lib.res_true( jsonb_build_object(
      '_cluster', _result
    ));
  end if;

  return lib.res_false( 'Licensa invalida!' );
end;
$$;


--
-- TOC entry 674 (class 1255 OID 16628)
-- Name: sets_cluster_machine_id(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_cluster_machine_id(args jsonb) RETURNS TABLE(result boolean, message text, data jsonb)
    LANGUAGE plpgsql
    AS $$
declare
  _machine cluster.cluster;
  _status cluster.cluster;
  _const map.constant;
begin
  _const := map.constant();
  _machine := jsonb_populate_record( _machine, args );

  select * into _status
    from cluster.cluster c
    where c.cluster_identifier = _machine.cluster_identifier
      and c.cluster_type = _const.cluster_tcluster_child
  ;

    sets_cluster_machine_id.result := true;
    sets_cluster_machine_id.message := 'Success';

  if _machine.cluster_machineid is null then
    sets_cluster_machine_id.result := false;
    sets_cluster_machine_id.message := 'Required machine ID form connect';

  elseif _status.cluster_identifier is null then
    sets_cluster_machine_id.result := false;
    sets_cluster_machine_id.message := 'Cluster not registered in current server as child as child';

  elseif _status.cluster_machineid is not null
    and _machine.cluster_machineid != _status.cluster_machineid
  then
    sets_cluster_machine_id.result := false;
    sets_cluster_machine_id.message := 'Cluster is active in another server';

  elseif _status.cluster_machineid is null then
    update cluster.cluster
      set cluster_machineid = _machine.cluster_machineid
      where cluster_identifier = _status.cluster_identifier
        and cluster_type = _status.cluster_type
        and cluster_api = _status.cluster_api
      returning *  into _status
    ;
  end if;

  sets_cluster_machine_id.data := to_jsonb( _status );
  return next ;
end;
$$;


--
-- TOC entry 675 (class 1255 OID 16629)
-- Name: sets_cluster_remote(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_cluster_remote(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      clusters: [{
        cluster_uid
        cluster_identifier
        cluster_receive
        cluster_send
        cluster_path
        cluster_name
        cluster_domain
        cluster_port
      }]
    }
   */
  _const map.constant;
  _data record;
begin
  _const := map.constant();

  with __clusters as (
    select c as _cluster, e.doc as cluster_replace
      from jsonb_array_elements( args->'clusters' ) e( doc )
        inner join jsonb_populate_record( null::cluster.cluster, e.doc ) _clu on true
        left join cluster.cluster c on
          ( _clu.cluster_identifier = c.cluster_identifier and c.cluster_type = _const.cluster_tcluster_remote )
      where _clu.cluster_identifier not in (
        select c.cluster_identifier
          from cluster.cluster c
          where c.cluster_type != _const.cluster_tcluster_remote
      )
  ), __sets as (
    select s."returning" as cluster
      from __clusters _c
        inner join lib.sets( _c._cluster, _c.cluster_replace ) s on true
  ) select array_agg( s.cluster ) as clusters into _data
      from __sets s
  ;

  return lib.res_true(  to_jsonb( _data ) );
end;
$$;


--
-- TOC entry 676 (class 1255 OID 16630)
-- Name: sets_cluster_tree_position(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_cluster_tree_position(args jsonb) RETURNS SETOF cluster.cluster
    LANGUAGE plpgsql
    AS $$
declare
  _const map.constant;
  _cluster cluster.cluster;
begin
  _cluster := jsonb_populate_record( cluster._get_cluster_local(), args );
  _const := map.constant();
  return query
    select ( "returning" ).*
      from lib.sets_up( _cluster );
end;
$$;


--
-- TOC entry 677 (class 1255 OID 16631)
-- Name: sets_clusters_admin(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_clusters_admin(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      cluster_license?: ( no carragamento de license )
      cluster_licenselife: QT
      cluster_tperiod_id: PERIODO (select * from cluster.tperiod order by tperiod_id)
    }
   */
  _cluster cluster.cluster;
  _result cluster.cluster;
  _res lib.res;
  _const map.constant;
  _master cluster.cluster;
  _local cluster.cluster;
  _tperiod cluster.tperiod;

  _doc jsonb default jsonb_build_object();
begin
  _const := map.constant();
  _cluster := jsonb_populate_record( _cluster, args );

  select * into _tperiod
    from cluster.tperiod tp
    where tp.tperiod_id = _cluster.cluster_tperiod_id
  ;


  -- Quando for o cluster master
  if _cluster.cluster_type = _const.cluster_tcluster_master then
--       raise exception 'Master:%', args;

    -- Aplicar as confifurações de cluster master
    _master := cluster._get_cluster_master();
    _master.cluster_domain := _cluster.cluster_domain;
    _master.cluster_api := _cluster.cluster_api;
    _master.cluster_port := _cluster.cluster_port;
    _master.cluster_type := _const.cluster_tcluster_master;
    _master.cluster_name := coalesce( _master.cluster_name, 'Master' );
    select ( "returning" ).* into _result from lib.sets( _master );
    _doc := _doc || jsonb_build_object( 'master', _result );


    -- Aplicar as configuraçõa do cluster local
    _local := cluster._get_cluster_local();
    _local.cluster_name := coalesce( _local.cluster_name, 'Local' );
    _local.cluster_identifier := _cluster.cluster_identifier;
    _local.cluster_license := _cluster.cluster_license;
    _local.cluster_licenselife := _cluster.cluster_licenselife;
    _local.cluster_tperiod_id := _cluster.cluster_tperiod_id;
    select ( "returning" ).* into _result from  lib.sets( _local );
    _doc := _doc || jsonb_build_object( 'local', _result );

  elseif _cluster.cluster_type = _const.cluster_tcluster_child then

    _cluster.cluster_identifier := cluster.__create_identifier();
    _cluster.cluster_api := cluster.__create_api();
    _cluster.cluster_key := format( '%s-%s', cluster.__create_api(), cluster.__create_api() );

    select ( "returning" ).* into _result
      from lib.sets( _cluster );

    if _cluster.cluster_uid is null then
      select * into _res
        from cluster.sets_cluster_license( to_jsonb( _cluster ) || lib.sets_ref( _result ) );
    end if;

    _doc := _doc || jsonb_build_object( 'child', _res );
  end if;

  return lib.res_true( _doc );
end;
$$;


--
-- TOC entry 678 (class 1255 OID 16632)
-- Name: sets_resources_downloaded(json); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_resources_downloaded(args json) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _object uuid default args->>'object_uid';
  _trans uuid default args->>'collector_transuid';
  _ref jsonb default args->>'object_ref';
begin
  return query
    update cluster.object o
      set object_status = 1
      where object_status = 2
        and object_share_regclass::regclass = 'cluster.resource'::regclass
        and object_uid = _object
        and object_transuid = _trans
        and object_ref = _ref
      returning to_jsonb( o )
  ;
end;
$$;


--
-- TOC entry 679 (class 1255 OID 16633)
-- Name: sets_resources_downloaded(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.sets_resources_downloaded(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _object uuid default args->>'object_uid';
  _trans uuid default args->>'collector_transuid';
  _ref jsonb default args->>'object_ref';
begin
  return query
    update cluster.object o
      set object_status = 1
      where object_status = 2
        and object_share_regclass::regclass = 'cluster.resource'::regclass
        and object_uid = _object
        and object_transuid = _trans
        and object_ref = _ref
      returning to_jsonb( o )
  ;
end;
$$;


--
-- TOC entry 680 (class 1255 OID 16634)
-- Name: status(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.status(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    PROPOSE: Devolver o atual estado do cluster cluster local, isso é até onde o atual custer conhecer os outros

    args:={}

    return ({
      cluster:[{
        cluster_identifier: CID,
        cluster_version: VN
        cluster_sequence
      }],
      versions:[{
        cluster_identifier: CID,
        share_regclass: SRC,
        version_number: VN,
      }],
      creq:?{
        cluster_version: VN
        cluster_sequence,
        versions: [{
          share_regclass: SRC,
          version_number: VN,
        }]
      }
    })
 */
--   _cluster_identifier character varying default args->>'cluster_identifier';
--   _cluster cluster.cluster;
--   _local cluster.cluster;
begin

  --   _cluster := cluster._get_cluster( _cluster_identifier );
--   _local := cluster._get_cluster_local(  );

  return query with
  __clusters as (
     select
       c.cluster_identifier,
       c.cluster_name,
       c.cluster_path,
       c.cluster_version,
       c.cluster_sequence,
       c.cluster_verbose
     from cluster.cluster c
       group by c.cluster_uid
  ) select to_jsonb( array_agg( c ) )
  from __clusters c
  ;
end;
$$;


--
-- TOC entry 681 (class 1255 OID 16635)
-- Name: switch_remote_connection(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.switch_remote_connection(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  _local cluster.cluster;
  _result cluster.cluster;
begin
  _local := cluster._get_cluster_local();
  _result := jsonb_populate_record( _result, args );
  if _local.cluster_namespace is null then
    return lib.res_true( jsonb_build_object( 'cluster_remote', false, 'cluster_remote_old', false ));
  end if;
  
  update cluster.cluster
    set cluster_remote = _result.cluster_remote 
    where cluster_uid = _local.cluster_uid
    returning * into _result;
  
  return lib.res_true( jsonb_build_object(
    'cluster_remote', _result.cluster_remote,
    'cluster_remote_old', _local.cluster_remote
    
  ));
end;
$$;


--
-- TOC entry 682 (class 1255 OID 16636)
-- Name: unlink_cluster(jsonb); Type: FUNCTION; Schema: cluster; Owner: -
--

CREATE FUNCTION cluster.unlink_cluster(args jsonb) RETURNS TABLE(result boolean, message text, data jsonb, error jsonb)
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _const map.constant;
begin
  _const := map.constant();
  _cluster := jsonb_populate_record( _cluster, args );

  update cluster.cluster
    set cluster_machineid = null,
        cluster_api = cluster.__create_api()
    where cluster_uid = _cluster.cluster_uid
      and cluster_type = _const.cluster_tcluster_child
    returning * into _cluster;

  if _cluster.cluster_uid is null then
    unlink_cluster.result := false;
    unlink_cluster.message := 'Cluster not found!';
  else
    unlink_cluster.result := true;
  end if;

  return next;
end;
$$;


--
-- TOC entry 468 (class 1255 OID 16637)
-- Name: dataset(); Type: FUNCTION; Schema: geoinfo; Owner: -
--

CREATE FUNCTION geoinfo.dataset() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para carregar os data set
   */
  _dataset geoinfo.dataset;
begin
  select * into _dataset
    from geoinfo.dataset ds
    where ds.dataset_use
    order by ds.dataset_updatedate desc nulls last,
      ds.dataset_registerdate desc
    limit 1
  ;
  return _dataset.dataset_data;
end;
$$;


--
-- TOC entry 241 (class 1259 OID 16638)
-- Name: dataset; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.dataset (
    dataset_id smallint NOT NULL,
    dataset_link character varying NOT NULL,
    dataset_version character varying NOT NULL,
    dataset_use boolean DEFAULT false NOT NULL,
    dataset_registerdate timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    dataset_updatedate timestamp with time zone,
    dataset_data jsonb
);


--
-- TOC entry 464 (class 1255 OID 16645)
-- Name: dataset(character); Type: FUNCTION; Schema: geoinfo; Owner: -
--

CREATE FUNCTION geoinfo.dataset(arg_dataset_link character) RETURNS geoinfo.dataset
    LANGUAGE sql
    AS $$
  select *
    from geoinfo.dataset ds
    where ds.dataset_link = arg_dataset_link;
$$;


--
-- TOC entry 467 (class 1255 OID 16646)
-- Name: dataset_populate(character varying, character varying, jsonb); Type: FUNCTION; Schema: geoinfo; Owner: -
--

CREATE FUNCTION geoinfo.dataset_populate(arg_dataset_link character varying, arg_dataset_version character varying, arg_dataset_data jsonb) RETURNS geoinfo.dataset
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para povoar o data set bruto
   */
  _dataset geoinfo.dataset;
begin
  if (
    select count( * )
      from geoinfo.dataset ds
      where ds.dataset_link = arg_dataset_link
  ) > 0 then
    return geoinfo.dataset_update(
      arg_dataset_link,
      arg_dataset_version,
      arg_dataset_data
    );
  end if;

  insert into geoinfo.dataset( dataset_link, dataset_version, dataset_data, dataset_use )
    values ( arg_dataset_link, arg_dataset_version,  arg_dataset_data, true )
    returning * into _dataset;

  update geoinfo.dataset
    set dataset_use = false
    where dataset_link != arg_dataset_link
  ;

  return _dataset;
end;
$$;


--
-- TOC entry 590 (class 1255 OID 16647)
-- Name: dataset_setup(); Type: FUNCTION; Schema: geoinfo; Owner: -
--

CREATE FUNCTION geoinfo.dataset_setup() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para set o dataset para as suas respectiva tabela
   */
begin
  -- delete all data
  delete from geoinfo.altspelling where true;
  delete from geoinfo.country where true;
  delete from geoinfo.countryborder where true;
  delete from geoinfo.countrycallcode where true;
  delete from geoinfo.countrycurrency where true;
  delete from geoinfo.countrylanguage where true;
  delete from geoinfo.countryregionalbloc where true;
  delete from geoinfo.countrytimezone where true;
  delete from geoinfo.countrytopleveldomain where true;
  delete from geoinfo.currency where true;
  delete from geoinfo.demonym where true;
  delete from geoinfo.domain where true;
  delete from geoinfo.language where true;
  delete from geoinfo.region where true;
  delete from geoinfo.regionalbloc where true;
  delete from geoinfo.regionalblocname where true;
  delete from geoinfo.regionalblocother where true;
  delete from geoinfo.subregion where true;
  delete from geoinfo.timezone where true;
  delete from geoinfo.countrytranslation where true;

  -- //Insert region
  perform setval('geoinfo.seq_region', 1, false );
  insert into geoinfo.region(region_name )
    select distinct region
      from geoinfo.dataset_region
      where region  is not null
  ;

  -- //Insert subregion
  perform setval('geoinfo.seq_subregion', 1, false );
  insert into geoinfo.subregion(subregion_name )
    select distinct subregion
      from geoinfo.dataset_subregion
      where subregion is not null
  ;

  -- //Insert subregion
  perform setval('geoinfo.seq_demonym', 1, false );
  insert into geoinfo.demonym(demonym_name )
    select distinct demonym
      from geoinfo.dataset_demonym
      where demonym is not null
  ;


  --//set domain
  perform setval( 'geoinfo.seq_domain', 1, false );
  insert into geoinfo.domain( domain_name )
    select distinct "topLevelDomain"
      from geoinfo.dataset_topleveldomain
      where "topLevelDomain" is not null
  ;

  --//set currency
  perform setval( 'geoinfo.seq_currency', 1, false );
  insert into geoinfo.currency ( currency_code, currency_name, currency_symbol )
    select distinct code, name, symbol
      from geoinfo.dataset_currencies
      where coalesce( code, name, symbol ) is not null;

  --//set language
  perform setval( 'geoinfo.seq_language', 1, false );
  insert into geoinfo.language ( language_iso2, language_iso3, language_name, language_nativename )
    select distinct lan.iso639_1, lan.iso639_2, lan.name, lan."nativeName"
      from geoinfo.dataset_languages lan
      where coalesce( lan.iso639_1, lan.iso639_2, lan.name, lan."nativeName" ) is not null
  ;

  --//set timezone
  perform setval( 'geoinfo.seq_timezone', 1, false );
  insert into geoinfo.timezone( timezone_timezone )
    select distinct dtz.timezones
      from geoinfo.dataset_timezones dtz
      where dtz.timezones is not null
  ;

  --//set regionalBlocs
  perform setval( 'geoinfo.seq_regionalbloc', 1, false );
  insert into geoinfo.regionalbloc( regionalbloc_acronym, regionalbloc_name )
    select distinct rb.acronym, rb.name
      from geoinfo.dataset_regionalblocs rb
  ;

  --//set regionalblocks other
  perform setval( 'geoinfo.seq_regionalblocother', 1, false  );
  insert into geoinfo.regionalblocother( regionalblocother_regionalbloc_id, regionalblocother_otheracronym )
    select distinct rb.regionalbloc_id, drb."otherAcronyms"
      from geoinfo.regionalbloc rb
        inner join geoinfo.dataset_regionalblocs drb on rb.regionalbloc_acronym = drb.acronym
      where drb."otherAcronyms" is not null
  ;

  --//set regionalblocks names
  perform setval( 'geoinfo.seq_regionalblocname', 1, false  );
  insert into geoinfo.regionalblocname( regionalblocname_regionalbloc_id, regionalblocname_name )
    select distinct rb.regionalbloc_id, drb."otherNames"
      from geoinfo.regionalbloc rb
        inner join geoinfo.dataset_regionalblocs drb on rb.regionalbloc_acronym = drb.acronym
      where drb."otherNames" is not null
  ;

  --//set country
  perform setval('geoinfo.seq_country', 1, false );
  insert into geoinfo.country (
    country_region_id,
    country_subregion_id,
    country_demonym_id,
    country_name,
    country_iso2,
    country_iso3,
    country_capital,
    country_population,
    country_latitude,
    country_longitude,
    country_area,
    country_gini,
    country_nativename,
    country_numericcode,
    country_flag,
    country_cioc
  ) select distinct
      reg.region_id,
      sub.subregion_id,
      de.demonym_id,
      ds.name,
      ds."alpha2Code",
      ds."alpha3Code",
      ds.capital,
      ds.population,
      ds.latitude,
      ds.longitude,
      ds.area,
      ds.gini,
      ds."nativeName",
      ds."numericCode",
      ds.flag,
      ds.cioc
    from geoinfo.dataset_country ds
      left join geoinfo.subregion sub on ds.subregion = sub.subregion_name
      left join geoinfo.region reg on ds.region = reg.region_name
      left join geoinfo.demonym de on ds.demonym = de.demonym_name
    ;

  --// set altspelling
  perform setval('geoinfo.seq_altspelling', 1, false );
  insert into geoinfo.altspelling(
    altspelling_country_id,
    altspelling_altspelling
  ) select
      c.country_id,
      al."altSpelling"
    from geoinfo.country c
      inner join geoinfo.dataset_altSpelling al on c.country_iso2 = al."alpha2Code"
        and c.country_iso3 = al."alpha3Code"
    where "altSpelling" is not null
   ;

  --//set countrycallcode
  perform setval('geoinfo.seq_countrycallcode', 1, false );
  insert into geoinfo.countrycallcode(
    countrycallcode_country_id,
    countrycallcode_callcode
  )
    select distinct
        co.country_id,
        ca."callingCode"
      from geoinfo.country co
        inner join geoinfo.dataset_callingcode ca on co.country_iso2 = ca."alpha2Code"
          and co.country_iso3 = ca."alpha3Code"
  ;

  --//set countrytopleveldomain
  perform setval( 'geoinfo.seq_countrytopleveldomain', 1, false );
  insert into geoinfo.countrytopleveldomain( countrytopleveldomain_country_id, countrytopleveldomain_domain_id )
    select distinct co.country_id, dom.domain_id
      from geoinfo.country co
        inner join geoinfo.dataset_topleveldomain topl on co.country_iso2 = topl."alpha2Code"
          and co.country_iso3 = topl."alpha3Code"
        inner join geoinfo.domain dom on topl."topLevelDomain" = dom.domain_name
  ;

  --//set contryborders
  perform setval( 'geoinfo.seq_countryborder', 1, false );
  insert into geoinfo.countryborder( countryborder_country_id, countryborder_country_broder)
    select distinct co.country_id, bor.country_id
      from geoinfo.country co
        inner join geoinfo.dataset_borders dbor on co.country_iso2 = dbor."alpha2Code"
          and co.country_iso3 = dbor."alpha3Code"
        inner join geoinfo.country bor on dbor.borders = bor.country_iso3
  ;

  --//set countrycurrency
  perform setval( 'geoinfo.seq_countrycurrency', 1, false );
  insert into geoinfo.countrycurrency( countrycurrency_country_id, countrycurrency_currency_id )
    select distinct cu.country_id, curr.currency_id
      from geoinfo.country cu
        inner join geoinfo.dataset_currencies dcurs on cu.country_iso2 = dcurs."alpha2Code"
          and cu.country_iso3 = dcurs."alpha3Code"
        inner join geoinfo.currency curr on coalesce( dcurs."code" ) = curr.currency_code
          and coalesce( dcurs.name ) = curr.currency_name
          and coalesce( dcurs.symbol ) = curr.currency_symbol
  ;

  --//set countrylanguage
  perform setval( 'geoinfo.seq_countrylanguage', 1, false );
  insert into geoinfo.countrylanguage( countrylanguage_country_id, countrylanguage_language_id )
    select distinct cu.country_id, lan.language_id
      from geoinfo.country cu
        inner join geoinfo.dataset_languages dlang on cu.country_iso2 = dlang."alpha2Code"
          and cu.country_iso3 = dlang."alpha3Code"
        inner join geoinfo.language lan on coalesce( lan.language_iso2, '' ) = coalesce( dlang.iso639_1, '' )
          and coalesce( lan.language_iso3, '' ) = coalesce( dlang.iso639_2, '' )
          and coalesce( lan.language_name, '' ) = coalesce( dlang.name, '' )
          and coalesce( lan.language_nativename, '' ) = coalesce( dlang."nativeName", '' )
  ;

  ---//set countrytimezone
  perform setval( 'geoinfo.seq_countrytimezone', 1, false );
  insert into geoinfo.countrytimezone( countrytimezone_country_id, countrytimezone_timezone_id )
    select distinct curr.country_id, tz.timezone_id
      from geoinfo.country curr
        inner join geoinfo.dataset_timezones dtz on curr.country_iso2 = dtz."alpha2Code"
          and curr.country_iso3 = dtz."alpha3Code"
        inner join geoinfo.timezone tz on dtz.timezones = tz.timezone_timezone
  ;

  --//set country regionalBlocks
  perform setval( 'geoinfo.seq_countryregionalbloc', 1, false );
  insert into geoinfo.countryregionalbloc( countryregionalbloc_country_id, countryregionalbloc_regionalbloc_id )
    select distinct cu.country_id, rb.regionalbloc_id
      from geoinfo.country cu
        inner join geoinfo.dataset_regionalblocs drb on cu.country_iso2 = drb."alpha2Code"
          and cu.country_iso3 = drb."alpha3Code"
        inner join geoinfo.regionalbloc rb on drb.acronym = rb.regionalbloc_acronym
  ;

  --//set countrytranslation
  perform setval( 'geoinfo.seq_countrytranslation', 1, false );
  insert into geoinfo.countrytranslation( countrytranslation_country_id, countrytranslation_language_id, countrytranslation_translation )
    select distinct coun.country_id, lang.language_id, dtrans.translations
      from geoinfo.dataset_translations dtrans
        inner join geoinfo.country coun on dtrans."alpha2Code" = coun.country_iso2
          and dtrans."alpha3Code" = coun.country_iso3
        inner join geoinfo.language lang on dtrans.language = lang.language_iso2
      where dtrans.translations is not null
    ;
end;
$$;


--
-- TOC entry 465 (class 1255 OID 16649)
-- Name: dataset_update(character varying, character varying, jsonb); Type: FUNCTION; Schema: geoinfo; Owner: -
--

CREATE FUNCTION geoinfo.dataset_update(arg_dataset_link character varying, arg_dataset_version character varying, arg_dataset_data jsonb) RETURNS geoinfo.dataset
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para povoar o data set bruto
   */
  _dataset geoinfo.dataset;
begin
  update geoinfo.dataset
    set dataset_data = arg_dataset_data,
        dataset_version = arg_dataset_version,
        dataset_updatedate = current_timestamp
    where dataset_link = arg_dataset_link
    returning * into _dataset
  ;

  return _dataset;
end;
$$;


--
-- TOC entry 466 (class 1255 OID 16650)
-- Name: dataset_use(character varying); Type: FUNCTION; Schema: geoinfo; Owner: -
--

CREATE FUNCTION geoinfo.dataset_use(arg_dataset_link character varying) RETURNS geoinfo.dataset
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Definir o data set a ser usado
   */
begin

  update dataset
    set dataset_use = dataset_link = arg_dataset_link
  ;

  return geoinfo.dataset( arg_dataset_link );
end;
$$;


--
-- TOC entry 556 (class 1255 OID 16651)
-- Name: age(timestamp with time zone); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.age(timestamp with time zone) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
/**
  Essa função serve para calcular a idade apartir de um timestamptz estabelecido
 */
select cast(to_char(age( $1 ), 'yyyy') as integer);
$_$;


--
-- TOC entry 559 (class 1255 OID 16652)
-- Name: agg_first(anyelement, anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.agg_first(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
/**
  Essa função serve de base para obter o primeiro elemento aggregado na função de agregação first
 */
select $1;
$_$;


--
-- TOC entry 560 (class 1255 OID 16653)
-- Name: agg_last(anyelement, anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.agg_last(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
/**
  Essa função serve de base para obter o último elemento agregado na função de agregação last
  */
select $2;
$_$;


--
-- TOC entry 561 (class 1255 OID 16654)
-- Name: array_delete(anyarray, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.array_delete(list anyarray, element integer) RETURNS anyarray
    LANGUAGE sql
    AS $$
/**
  Essa função serve para remover um elemento em uma dada posição do array
  list corresponde ao array com elementos
  element corresponde ao elemento que devera ser removido
*/
select lib.array_delete( list, element, 1 );
$$;


--
-- TOC entry 562 (class 1255 OID 16655)
-- Name: array_delete(anyarray, integer, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.array_delete(list anyarray, start integer, elements integer) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para remover um range de elementos em um array e devolver um novo array com elementos que não foram eliminados
   */
begin
  return list[ :start -1 ] || list[ ( start + elements ): ];
end;
$$;


--
-- TOC entry 564 (class 1255 OID 16656)
-- Name: array_max_element(anyarray, anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.array_max_element(arr anyarray, element anyelement DEFAULT NULL::unknown) RETURNS anyelement
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para obeter o maior elemento em um array
  */
begin
  element := null;
  for iterator in 1.. array_length( arr, 1 ) loop
    if arr[ iterator ]  is not null and element is null or element < arr[ iterator ] then
      element := arr [ iterator ];
    end if;
  end loop;

  return element;
end;
$$;


--
-- TOC entry 685 (class 1255 OID 16657)
-- Name: array_min_element(anyarray, anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.array_min_element(arr anyarray, element anyelement DEFAULT NULL::unknown) RETURNS anyelement
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para obter o menor elemento em um array
   */
begin
  element := null;
  for iterator in 1 .. lib.array_length( arr ) loop
    if arr[ iterator ]  is not null and element is null or element > arr[ iterator ] then
      element := arr [ iterator ];
    end if;
  end loop;

  return element;
end;
$$;


--
-- TOC entry 686 (class 1255 OID 16658)
-- Name: coincidences(anyarray, anyarray, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.coincidences(arguments_left anyarray, arguments_right anyarray, option jsonb DEFAULT NULL::jsonb) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare

  --     iterator_left numeric default 1;

  -- text_left text;
  -- text_iterator text;
  coincidences_match_found numeric default 0;
  coincidences_total numeric;
begin
  coincidences_total := array_length( arguments_right, 1 );

  if arguments_left is null
     or coincidences_total = 0
     or arguments_right is null
     or array_length( arguments_right, 1 ) = 0
  then
    return 0;
  end if;


  for iterator_left in 1 .. array_length( arguments_left, 1 ) loop
    if  arguments_left[ iterator_left ] = any ( arguments_right ) then
      coincidences_match_found := coincidences_match_found + 1;
    end if;
  end loop;
  return ( 100 * coincidences_match_found ) / coincidences_total;
end;
$$;


--
-- TOC entry 687 (class 1255 OID 16659)
-- Name: coincidences_likes(text[], text[], jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.coincidences_likes(arguments_left text[], arguments_right text[], option jsonb DEFAULT NULL::jsonb) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare

  --     iterator_left numeric default 1;

  -- text_left text;
  -- text_iterator text;
  coincidences_match_found numeric default 0;
  coincidences_total numeric;
begin
  coincidences_total := array_length( arguments_right, 1 );

  if arguments_left is null
     or coincidences_total = 0
     or arguments_right is null
     or array_length( arguments_right, 1 ) = 0
  then
    return 0;
  end if;


  for iterator_left in 1 .. array_length( arguments_left, 1 ) loop
    if  arguments_left[ iterator_left ] like any ( arguments_right ) then
      coincidences_match_found := coincidences_match_found + 1;
    end if;
  end loop;

  return ( 100 * coincidences_match_found ) / coincidences_total;
end;
$$;


--
-- TOC entry 689 (class 1255 OID 16660)
-- Name: combinator(text[], integer, text[], integer[], integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.combinator(items text[], start integer DEFAULT 1, parent text[] DEFAULT NULL::text[], indexs integer[] DEFAULT NULL::integer[], size integer DEFAULT NULL::integer) RETURNS TABLE(combination_items text[], combination_elements integer, combination_indexs integer[])
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare

    /**
      Essa função serve para combinar de uma forma unica os elementos de uma lista
      items corresponde aos elementos que devem ser combinados ( arg_element_items )
      start corresponde a possição a qual a combinação devera iniciar (arg_element_start)
      parent cooresponde aos elementos já combinado que as novas combinações deverão conter na raiz (arg_element_parent)
      indexs corresponde ao index de todos os elementos já combinados no parrente (arg_element_index)
      size corresponde ao tamanho do array dos elementos que deverão ser combinadoos (arg_element_sizes)
     */

    arg_complete text[];
    arg_index int[];
    arg_items_count int default array_length( parent, 1 );
  begin

    -- Quando a lista dos itens a se combinar for nulo ou vazia então deve-se sair das tentativas de combinação
    if items is null or array_length( items, 1 ) = 0 then
      return;
    end if;

    -- Obter o tamanho total da lista dos elementos
    if size is null then
      size := array_length( items, 1 );
    end if;

    arg_items_count := coalesce( arg_items_count, 0 );
    start := coalesce( start, 1 );

    -- Combinar o parrente com todos os item apartir da posição atual do array
    for i in start .. size loop

      if parent is null then
        arg_complete := array [ items[ i ] ];
        arg_index := array [ i ];
      else
        arg_complete := parent || items[ i ];
        arg_index := indexs || i;
      end if;

      -- Para a nova combinação encontrada, combitar com os proximos item da lista caso tiver mais item na lista
      if i < size then
        return query
          select *
            from lib.combinator( items, i+1, arg_complete, arg_index, size )
        ;
      end if;

      return query select arg_complete, arg_items_count +1, arg_index;

    end loop;
  end;
$$;


--
-- TOC entry 690 (class 1255 OID 16661)
-- Name: dset_random_element(anyarray); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_element(elements anyarray) RETURNS anyelement
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para devolver um elemento aleatoriamente de uma lista
   */
begin
  return elements[ lib.dset_random_next( 1, array_length( elements, 1 ) ) ];
end;
$$;


--
-- TOC entry 691 (class 1255 OID 16662)
-- Name: dset_random_name(integer, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_name(min integer, max integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para gerar um termo composto apebas por letras com um minimo de sentido de leitura
   */
  vogais text[] default regexp_split_to_array( 'aeiyou', '' );
  consuant text[] default regexp_split_to_array( 'bcdfghjklmnprstvwxz', '' );
  consuant_composid text[] default array[ 'ch', 'qu' ];
  sufix text[] default regexp_split_to_array( 'lmnrsxz', '' );
  sufix_compused text[] default array [ 'ch' ];

  silabaQuant int := lib.dset_random_next( min, max );
  silabaFinal boolean;

  numConsuant int;
  numVogais int;
  numSufixo int;

  name text default '';
begin


  -- Unir todas as consoantes & sufixo
  consuant := consuant || consuant_composid;
  sufix := sufix || sufix_compused;

    numConsuant := array_length( consuant, 1 );
  numVogais := array_length( vogais, 1 );
  numSufixo := array_length( sufix, 1 );

  for i in 1 .. silabaQuant loop
    silabaFinal := i = silabaQuant;

    if not silabaFinal then
      name := name || consuant[ lib.dset_random_next( 1, numConsuant ) ];
      name := name || vogais [ lib.dset_random_next( 1, numVogais ) ];

    -- ? Opcao para colocar sufixo (10% de chance para colocar o sufixo)
    elseif lib.dset_random_next( 1, 100 ) <= 10 then
      -- SUFIXO: consoante, vogal, sufixo
      name := name || consuant[ lib.dset_random_next( 1, numConsuant ) ];
      name := name || vogais [ lib.dset_random_next( 1, numVogais ) ];
      name := name || sufix [ lib.dset_random_next( 1, numSufixo ) ];

    -- ? Adicionar consuante e vogal (90% de chanse de colocar consuante e vogal)
    elseif lib.dset_random_next( 1, 100 ) <= 90 then
      name := name || consuant[ lib.dset_random_next( 1, numConsuant ) ];
      name := name || vogais [ lib.dset_random_next( 1, numVogais ) ];

    else
      name := name || consuant[ lib.dset_random_next( 1, numConsuant ) ];

    end if;

  end loop;

  return name;
end;
$$;


--
-- TOC entry 692 (class 1255 OID 16663)
-- Name: dset_random_next(anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_next(anyelement) RETURNS anyelement
    LANGUAGE plpgsql STRICT
    AS $_$
declare
  arg_next numeric default ( random() * $1 );
begin
  if arg_next < 0 then return lib.dset_random_next( $1 );
  elseif arg_next > $1 then return lib.dset_random_next( $1 );
  end if;
  return arg_next;
end;
$_$;


--
-- TOC entry 695 (class 1255 OID 16664)
-- Name: dset_random_next(anyelement, anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_next(min anyelement, max anyelement) RETURNS anyelement
    LANGUAGE plpgsql
    AS $$
declare
    arg_max_abs numeric default case when abs( max ) > abs( min ) then abs( max ) else abs( min ) end;

    -- definir o sinal para o numero que sera gerado
    arg_sigal int default case
                              when min < 0 and max < 0 then -1
                              when min >= 0 and max >= 0 then 1
                              when lib.dset_random_next( 100 ) <= 50 then -1
                              else 1
        end;

    random numeric default random() * arg_max_abs * arg_sigal;
begin

    if min > max then return null; end if;

    if min = max then return min; end if;

    if random between min  and max then
        return random;
    else
        return lib.dset_random_next( min, max );
    end if;
end;
$$;


--
-- TOC entry 696 (class 1255 OID 16665)
-- Name: dset_random_nextdate(date, date); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_nextdate(arg_datainicio date, arg_datafim date) RETURNS date
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
    diferenca int;
begin
    if arg_datainicio > arg_datafim then return null; end if;
    diferenca := arg_datafim - arg_datainicio;

    return arg_datainicio + make_interval(
            0,
            0,
            0,
            lib.dset_random_next( 0, diferenca )
        );
end;
$$;


--
-- TOC entry 698 (class 1255 OID 16666)
-- Name: dset_random_nexttimestamptz(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_nexttimestamptz(min timestamp with time zone, max timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
    diferenca interval;
begin
    if min > max then return null; end if;
    diferenca := max - min;

    return min + make_interval(
            0,
            0,
            0,
            lib.dset_random_next( 0, extract( days from diferenca )::int ),
            lib.dset_random_next( 0, extract( hours from diferenca )::int ),
            lib.dset_random_next( 0, extract( minutes from diferenca )::int ),
            lib.dset_random_next( 0.0::double precision, extract( seconds from diferenca ) )
        );
end;
$$;


--
-- TOC entry 699 (class 1255 OID 16667)
-- Name: dset_random_serial(integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_serial(length integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para gerar uma combinação eleatoria dos elementos em uma string
   */
  arg_elements constant character varying default 'AaBbC0cDdEe1FfGgH2hIiJj3KkLlM4mNnOo5PpQqR6rSsTt7UuVvW8wXxYy9Zz';

begin
    return lib.dset_random_text( arg_elements, length );
end;
$$;


--
-- TOC entry 688 (class 1255 OID 16668)
-- Name: dset_random_text(integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_text(length integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
declare
  /**
    Essa função serve para gerar uma combinação eleatoria dos elementos em uma string
   */
  arg_elements constant character varying default 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz';

begin
    return lib.dset_random_text( arg_elements, length );
end;
$$;


--
-- TOC entry 593 (class 1255 OID 16669)
-- Name: dset_random_text(character varying, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dset_random_text(elements character varying, length integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
declare
  /**
    Essa função serve para gerar uma combinação eleatoria dos elementos em uma string
   */
  K constant character [] default regexp_split_to_array( elements, '' );
  gen text default '';
  max int default array_length( K, 1 );
begin
  for iterator in 1 .. length loop
    gen := gen || K[ lib.dset_random_next( 1, max ) ];
  end loop;
  return gen;
end;
$$;


--
-- TOC entry 595 (class 1255 OID 16670)
-- Name: dump_functions(text[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.dump_functions(VARIADIC schemas text[]) RETURNS SETOF text
    LANGUAGE sql
    AS $$

  select pg_get_functiondef(f.oid) || e';\n\n'
    from unnest( schemas ) with ordinality s ( schema_name, schema_index)
      inner join pg_catalog.pg_namespace n on n.nspname = s.schema_name
      inner join pg_catalog.pg_proc f on f.pronamespace = n.oid
    where f.oid not in (
      select aggfnoid from pg_catalog.pg_aggregate
    )
    order by s.schema_index
  ;
$$;


--
-- TOC entry 700 (class 1255 OID 16671)
-- Name: duplicates(jsonb, jsonb, boolean); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.duplicates(list jsonb, maps jsonb, aggregate boolean DEFAULT false) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
declare
  _keys text[] default array(
    select key
      from jsonb_each( maps )
  );
begin
  return query
    with __keys as (
      select distinct kv.key
        from jsonb_array_elements( list ) e( document )
          inner join jsonb_each( e.document ) kv ( key, value ) on kv.key = any( _keys )
        where kv.value = maps->( kv.key )
          and jsonb_typeof( kv.value ) != 'null'
    ) select distinct
        case
          when aggregate then  string_agg( _k.key, ', ') over ()
          else _k.key
        end
      from __keys _k
  ;
end
$$;


--
-- TOC entry 701 (class 1255 OID 16672)
-- Name: each(jsonb, boolean); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.each(jsonb, force boolean DEFAULT false) RETURNS TABLE(name text, index bigint, key text, value jsonb, text text, literal_text text, literal_json text, type text, source text)
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  _dd numeric;
begin
  each.source := jsonb_typeof( $1 );
  if each.source = 'object' then
    return query
      select
          e.key,
          null::int8,
          e.key,
          e.value,
          lib.extract( e.value ),
          format( '%L', case
            when jsonb_typeof( e.value ) = 'array' then array( select jsonb_array_elements_text( e.value) )::text
            else lib.extract( e.value )
          end) as literal_text,
          format( '%L', e.value::text ),
          jsonb_typeof( e.value ),
          each.source
        from jsonb_each( $1 )e( key, value );
  elseif each.source = 'array' then
    return query
      select
          e.index::text,
          e.index,
          null,
          e.value,
          lib.extract( e.value ),
          format( '%L', case
            when jsonb_typeof( e.value ) = 'array' then array( select jsonb_array_elements_text( e.value) )::text
            else lib.extract( e.value )
          end) as literal_text,
          format( '%L', e.value::text ) as literal_json,
          jsonb_typeof( e.value ),
          each.source
        from  jsonb_array_elements( $1 ) with ordinality e( value, index );
  elseif force then
    each.name := null;
    each.index := null;
    each.key := null;
    each.value := $1;
    each.text := lib.extract( $1 );
    each.literal_text := format( '%L', lib.extract( $1 ));
    each.literal_json := format( '%L', $1::text);
    each.type := jsonb_typeof( $1 );
    return next;
  else
    raise exception 'cannot call each on a non-object or a non-array';
  end if;
end;
$_$;


--
-- TOC entry 702 (class 1255 OID 16673)
-- Name: eval(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.eval(expression text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  result text;
begin
   execute( format( 'select (%s)::text', expression ) ) into result;
   return result;
end
$$;


--
-- TOC entry 703 (class 1255 OID 16674)
-- Name: exception(character varying, text, text, text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.exception(errocode character varying DEFAULT NULL::character varying, text text DEFAULT NULL::text, hint text DEFAULT NULL::text, detail text DEFAULT NULL::text) RETURNS lib.exception
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para criar uma instancia exception
   */
  _ex lib.exception;
begin
  _ex.errcode :=  errocode;
  _ex.text := text;
  _ex.hint := hint;
  _ex.detail := detail;

  return _ex;
end;
$$;


--
-- TOC entry 563 (class 1255 OID 16675)
-- Name: extract(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib."extract"(jsonb) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
select case jsonb_typeof( $1 )
    when 'array' then $1::text
    when 'object' then $1::text
    else $1->>0
  end;
$_$;


--
-- TOC entry 693 (class 1255 OID 16676)
-- Name: format(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.format(jsonb) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select case jsonb_typeof( $1 )
      when 'array' then $1::text
      when 'object' then $1::text
      else to_jsonb( $1 )::text
    end;
$_$;


--
-- TOC entry 694 (class 1255 OID 16677)
-- Name: in_day(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_day(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 )/( 60.0 * 60.0 * 24.0 );
end;
$_$;


--
-- TOC entry 512 (class 1255 OID 16678)
-- Name: in_hour(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_hour(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 )/( 60.0 * 60.0 );
end;
$_$;


--
-- TOC entry 517 (class 1255 OID 16679)
-- Name: in_minute(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_minute(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 )/60.0;
end;
$_$;


--
-- TOC entry 518 (class 1255 OID 16680)
-- Name: in_month(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_month(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 )/( 60.0 * 60.0 * 24.0 * 30 );
end;
$_$;


--
-- TOC entry 519 (class 1255 OID 16681)
-- Name: in_second(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_second(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 );
end;
$_$;


--
-- TOC entry 520 (class 1255 OID 16682)
-- Name: in_week(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_week(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 )/( 60.0 * 60.0 * 24.0 * 7 );
end;
$_$;


--
-- TOC entry 521 (class 1255 OID 16683)
-- Name: in_year(interval); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.in_year(interval) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  /**
    Devolver o intervalo em termos de segundos
   */
begin
  return extract( epoch from $1 )/ extract( epoch from make_interval( 1 ));
end;
$_$;


--
-- TOC entry 704 (class 1255 OID 16684)
-- Name: initials(character varying); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.initials(name character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  parts character varying [] default regexp_split_to_array(name, ' ');
  part character varying;
  initials character varying default '';
begin
  FOREACH part in ARRAY parts LOOP
    part := upper(trim(part));
    if part is not null and length(part)> 0 then
      initials := initials || substr(part, 1, 1);
    END IF;
  END LOOP;
  return initials;
end;
$$;


--
-- TOC entry 705 (class 1255 OID 16685)
-- Name: is_bigint(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.is_bigint(argment text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  num numeric;
begin
  num := argment::BIGINT;
  return true;
  exception when OTHERS  then return false;
end;

$$;


--
-- TOC entry 697 (class 1255 OID 16686)
-- Name: is_integer(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.is_integer(argment text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  num numeric;
begin
  num := argment::integer;
  return true;
  exception when OTHERS  then return false;
end;

$$;


--
-- TOC entry 683 (class 1255 OID 16687)
-- Name: is_numeric(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.is_numeric(argment text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  num numeric;
begin
  num := argment::numeric;
  return true;
  exception when OTHERS  then return false;
end;

$$;


--
-- TOC entry 684 (class 1255 OID 16688)
-- Name: jsonb_concat(jsonb[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_concat(VARIADIC jsonb[]) RETURNS jsonb
    LANGUAGE plpgsql
    AS $_$
  declare
    doc jsonb;
  begin
    for i in 1 .. array_length( $1, 1 ) loop
      if $1[ i ] is null then continue; end if;

      if doc is null then doc := $1[ i ];
      else doc := doc || $1 [ i ];
      end if;
    end loop;
    return doc;
  end;
$_$;


--
-- TOC entry 706 (class 1255 OID 16689)
-- Name: jsonb_iterate(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_iterate(document jsonb) RETURNS TABLE(key text, key_type regtype, value jsonb, value_type text)
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para iterar qualquer tipo de jsonb composta (array ou object )
      e devolver os valores disponiveis no mesmo
   */
begin
  -- para documento null não efetuar nehuma operção
  if document is null then return; end if;

  -- Quando o documento for objecto então iterar as key
  if jsonb_typeof( document ) in ( 'object' ) then
    return query
      select
          doc.key,
          'text'::regtype,
          doc.value,
          jsonb_typeof( doc.value )
        from jsonb_each( document ) doc
    ;
  end if;

  -- Quando o documento for array então iterar os index
  if jsonb_typeof( document ) in ( 'array' ) then
    return query
      select
          doc.index::text,
          'integer'::regtype,
          doc.value,
          jsonb_typeof( doc.value )
        from jsonb_array_elements( document ) with ordinality doc ( value, index )
    ;
  end if;

end;
$$;


--
-- TOC entry 707 (class 1255 OID 16690)
-- Name: jsonb_iterate_cascade(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_iterate_cascade(document jsonb) RETURNS TABLE(path text[], level integer, key text, key_type regtype, value jsonb, value_type text)
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para iterar em cascada qualquer tipo de jsonb composto (array ou object )
      e devolver os valores disponiveis no mesmo
   */
begin
  return query
    with recursive cascade as (
          select
              array[ i.key ] as path,
              0 as level,
              i.*
            from lib.jsonb_iterate ( document ) i
        union all
          select
            ca.path|| i.key,
              ca.level +1,
              i.*
              from cascade ca
            inner join lib.jsonb_iterate( ca.value ) i on true
          where ca.value_type in ( 'object', 'array' )
      )
    select *
      from cascade
      order by path
  ;

end;
$$;


--
-- TOC entry 708 (class 1255 OID 16691)
-- Name: jsonb_object_length(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_object_length(object jsonb) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para obtter o tamanho de um objecto json ( a quantidade de par chave valor que o objecto possui )
   */
  iCount int;
  objType text default jsonb_typeof( object );
begin
  if objType is null or objType != 'object' then return null; end if;
  select count(*)  into iCount
  from jsonb_object_keys(object);
  return iCount;
end;
$$;


--
-- TOC entry 596 (class 1255 OID 16692)
-- Name: jsonb_values(anyelement, integer[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_values(element anyelement, VARIADIC indexes integer[]) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para devolver varios valores de um documento em um sub-documento jsonb
   */
  sub jsonb := jsonb_build_object();
  doc jsonb;
begin
  doc := to_jsonb( element );
  if array_length( indexes, 1 ) = 0 then return jsonb_build_array(); end if;

  select
    jsonb_agg(
        doc->( key.index )
      ) into sub
  from unnest( indexes ) key( index )
  ;

  return coalesce( sub, jsonb_build_object() );
end;
$$;


--
-- TOC entry 709 (class 1255 OID 16693)
-- Name: jsonb_values(anyelement, text[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_values(element anyelement, VARIADIC keys text[]) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para devolver varios valores de um documento em um sub-documento jsonb
   */
  doc jsonb;
  sub jsonb := jsonb_build_object();
begin
  doc := to_jsonb( element );
  if array_length( keys, 1 ) = 0 then return jsonb_build_object(); end if;

  select
    jsonb_object_agg(
        key.name, doc->( key.name )
      ) into sub
  from unnest( keys ) key( name )
  ;

  return coalesce( sub, jsonb_build_object() );
end;
$$;


--
-- TOC entry 710 (class 1255 OID 16694)
-- Name: jsonb_values(jsonb, integer[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_values(document jsonb, VARIADIC indexes integer[]) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para devolver varios valores de um documento em um sub-documento jsonb
   */
  sub jsonb := jsonb_build_object();
begin
  if array_length( indexes, 1 ) = 0 then return jsonb_build_object(); end if;

  select
    jsonb_agg(
        document->( key.index )
      ) into sub
  from unnest( indexes ) key( index )
  ;

  return coalesce( sub, jsonb_build_object() );
end;
$$;


--
-- TOC entry 711 (class 1255 OID 16695)
-- Name: jsonb_values(jsonb, text[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_values(document jsonb, VARIADIC keys text[]) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para devolver varios valores de um documento em um sub-documento jsonb
   */
  sub jsonb := jsonb_build_object();
begin
  if array_length( keys, 1 ) = 0 then return jsonb_build_object(); end if;

  select
      jsonb_object_agg(
        key.name, document->( key.name )
      ) into sub
    from unnest( keys ) key( name )
  ;

  return coalesce( sub, jsonb_build_object() );
end;
$$;


--
-- TOC entry 712 (class 1255 OID 16696)
-- Name: jsonb_values_as(jsonb, text[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.jsonb_values_as(document jsonb, VARIADIC keys text[]) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função devolve um sub-docomento com os valores renomeados
    urgent: o numero de chave passada tem que ser par
   */
  sub jsonb := jsonb_build_object();
  length int;
begin

  length := array_length( keys, 1 );

  if length = 0 then return jsonb_build_object(); end if;

  -- A lista de chaves a ser renomeadas tem que ser par
  if ( length % 2 ) != 0 then
    raise exception 'lib.jsonb_values_as: lista de chaves impar';
  end if;

  select
      jsonb_object_agg(
        keys[ next.index +1 ], document-> keys[ next.index ]
      ) into sub
    from generate_series( 1, length, 2 ) next( index )
  ;

  return coalesce( sub, jsonb_build_object() );
end;
$$;


--
-- TOC entry 713 (class 1255 OID 16697)
-- Name: money(anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.money(moneyvalue anyelement) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  vMoney character varying;
  positive boolean default moneyvalue >= 0;
begin
  if moneyvalue is null then return null; end if;
  moneyvalue := abs( moneyvalue );
  vMoney := to_char(moneyValue, 'FM999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999G999D90');
  vMoney := replace( vMoney, ',', ' ' );
  vMoney := replace( vMoney, '.', ',' );

  if not positive then
    vMoney := '-'||vMoney;
  end if;

  return lib.normalize( vMoney );
END;

$$;


--
-- TOC entry 714 (class 1255 OID 16698)
-- Name: represent(bigint, text, integer, character); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.represent(number bigint, base text DEFAULT ''::text, length integer DEFAULT 0, lpad character DEFAULT ''::bpchar) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare

  _base_chars char[] default case
    when base is null or base = '' then '{0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}'::char[]
    else regexp_split_to_array( base, '' )::char[]
  end;
  _base_length int default array_length( _base_chars, 1 );

  result int8;
  rest int8;
  _rest_char char;
  _code text default '';

begin
  if _base_length < 2 then return null; end if;
  if number is null then return null; end if;
  if number < 0 then return null; end if;


  if exists(
    select c
      from unnest( _base_chars ) c
      group by c
      having count( c ) > 1
  ) then raise exception 'Invalid base representation'; end if;

  result := number;

  while result > 0 loop
    rest := result%_base_length;
    result := result/_base_length;
    _rest_char := _base_chars[ rest+1 ];
    _code := format( '%s%s', _rest_char, _code );
  end loop;

  if( length( _code ) < 1 and number >= 0 ) then _code := _base_chars[ 1 ]; end if;
  if lpad is not null and length is not null and length > length( _code ) then
    _code := lpad( _code, length, lpad );
  end if;

  return  _code;
end
$$;


--
-- TOC entry 715 (class 1255 OID 16699)
-- Name: res(boolean, text, jsonb, jsonb, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.res(result boolean, message text, data jsonb, error jsonb, level integer DEFAULT 0) RETURNS lib.res
    LANGUAGE sql IMMUTABLE
    AS $_$ select row ($1, $2, $3, $4, $5)$_$;


--
-- TOC entry 718 (class 1255 OID 16700)
-- Name: res_exception(character varying, text, text, text, text, text, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.res_exception(errocode character varying DEFAULT NULL::character varying, message text DEFAULT NULL::text, hint text DEFAULT NULL::text, detail text DEFAULT NULL::text, context text DEFAULT NULL::text, user_message text DEFAULT NULL::text, level integer DEFAULT '-1'::integer) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para criar uma instancia exception*/
  _ex lib.exception;
  _res lib.res;
begin
  _ex.errcode :=  errocode;
  _ex.message := coalesce( user_message, message );
  _ex.hint := hint;
  _ex.detail := detail;
  _ex.context := context;
  _ex.exception := true;

  _res.result := false;
  _res.message := message;
  _res.error := to_jsonb( _ex );
  _res.level := level;
  return _res;
end;
$$;


--
-- TOC entry 719 (class 1255 OID 16701)
-- Name: res_false(text, jsonb, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.res_false(message text DEFAULT 'error'::text, error jsonb DEFAULT '{}'::jsonb, level integer DEFAULT 0) RETURNS lib.res
    LANGUAGE sql IMMUTABLE
    AS $_$select lib.res( false, $1, null, $2, level )$_$;


--
-- TOC entry 720 (class 1255 OID 16702)
-- Name: res_true(jsonb, text, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.res_true(data jsonb DEFAULT '{}'::jsonb, message text DEFAULT 'success'::text, level integer DEFAULT 1) RETURNS lib.res
    LANGUAGE sql IMMUTABLE
    AS $_$select lib.res( true, $2, $1, null, level )$_$;


--
-- TOC entry 589 (class 1255 OID 16703)
-- Name: result(boolean); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result(result boolean) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para devolver um resultado
   */
  _res lib.result;
begin
  _res.result := result;
  return _res;
end;
$$;


--
-- TOC entry 721 (class 1255 OID 16704)
-- Name: result(boolean, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result(result boolean, message jsonb) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para devolver um resultado contumizado a medido do programador que fara uso
   */
  _res lib.result;
begin
  _res.result = result ;
  _res.message = message;
  return _res;
end;
$$;


--
-- TOC entry 522 (class 1255 OID 16705)
-- Name: result(boolean, text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result(result boolean, text text DEFAULT NULL::text) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _res lib.result;
begin
  _res.result := result;
  _res.message := jsonb_build_object( 'text', text );
  return _res;
end;
$$;


--
-- TOC entry 552 (class 1255 OID 16706)
-- Name: result_catch(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_catch(message text) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** converter a caputra do SQLERRM em um result
  */
  _res lib.result;
begin
  _res := message::lib.result;
  return _res;

  exception when others then
    _res := lib.result_false( message::text );
    return _res;
end;
$$;


--
-- TOC entry 723 (class 1255 OID 16707)
-- Name: result_catch(character varying, text, text, text, text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_catch(errocode character varying DEFAULT NULL::character varying, message text DEFAULT NULL::text, hint text DEFAULT NULL::text, detail text DEFAULT NULL::text, context text DEFAULT NULL::text) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para criar uma instancia exception
   */
  _ex lib.exception;
  _res lib.result;
begin
  _ex.errcode :=  errocode;
  _ex.message := message;
  _ex.hint := hint;
  _ex.detail := detail;
  _ex.context := context;
  _ex.exception := true;

  _res.result := false;
  _res.message := to_jsonb( _ex ) || jsonb_build_object( 'text', _ex.message );
  return _res;
end;
$$;


--
-- TOC entry 411 (class 1255 OID 16708)
-- Name: result_concat(lib.result, lib.result); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_concat(lib.result, lib.result) RETURNS lib.result
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- This function concat the result message with other result message value
  select $1.result, $1.message||$2.message ;
$_$;


--
-- TOC entry 724 (class 1255 OID 16709)
-- Name: result_concat(lib.result, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_concat(lib.result, jsonb) RETURNS lib.result
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- This function concat the result message with any jsonb value
  select $1.result, $1.message||$2 ;
$_$;


--
-- TOC entry 725 (class 1255 OID 16710)
-- Name: result_exception(text, character varying, text, text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_exception(text text, errcode character varying DEFAULT NULL::character varying, hint text DEFAULT NULL::text, detail text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
  -- base comment here
declare
  /** Essa função serve para criar uma exception
    errcode = R9999
  */
  DEFAULT_ERRCODE varchar default 'R9999';
  _res lib.result;
  _ex lib.exception;
begin
    _res := lib.result_false(
      to_jsonb( lib.exception(
          coalesce( errcode, DEFAULT_ERRCODE ),
          text,
          hint,
          detail
        )
      )
    );

  raise exception using
    errcode = coalesce( errcode, DEFAULT_ERRCODE ),
    message = coalesce( _res::text, '' )
  ;
end;
$$;


--
-- TOC entry 726 (class 1255 OID 16711)
-- Name: result_false(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_false(content jsonb) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _res lib.result;
begin
  _res.result = false ;
  _res.message = content;
  return _res;
end;
$$;


--
-- TOC entry 598 (class 1255 OID 16712)
-- Name: result_false(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_false(message text) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare

begin
  return lib.result_false(
      jsonb_build_object( 'text', message::text)
  );
end;
$$;


--
-- TOC entry 599 (class 1255 OID 16713)
-- Name: result_remove(lib.result, integer); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_remove(lib.result, integer) RETURNS lib.result
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- This function remove a key in result message
  select $1.result, $1.message - $2 ;
$_$;


--
-- TOC entry 600 (class 1255 OID 16714)
-- Name: result_remove(lib.result, text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_remove(lib.result, text) RETURNS lib.result
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- This function remove a key in result message
  select $1.result, $1.message - $2 ;
$_$;


--
-- TOC entry 601 (class 1255 OID 16715)
-- Name: result_true(); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_true() RETURNS lib.result
    LANGUAGE sql IMMUTABLE
    AS $$
-- result_true
select lib.result_true( 'true'  );
$$;


--
-- TOC entry 609 (class 1255 OID 16716)
-- Name: result_true(jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_true(content jsonb) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
begin
  return lib.result(
      true,
      content
  );
end;
$$;


--
-- TOC entry 615 (class 1255 OID 16717)
-- Name: result_true(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.result_true(message text) RETURNS lib.result
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para devolver um resultado verdadeiro acompanhado com a sua mensagem de texto
   */
begin
  return lib.result_true( jsonb_build_object( 'text', message::text) );
end;
$$;


--
-- TOC entry 727 (class 1255 OID 16718)
-- Name: sets(anyelement, jsonb, text[], jsonb, text, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets(_row anyelement, replacer jsonb DEFAULT NULL::jsonb, defaults text[] DEFAULT NULL::text[], ref jsonb DEFAULT NULL::jsonb, t_where text DEFAULT NULL::text, "with" jsonb DEFAULT NULL::jsonb) RETURNS TABLE("returning" anyelement, action integer, operation text)
    LANGUAGE plpgsql
    AS $_$
declare
  _regclass regclass default pg_typeof( _row )::text::regclass;
  _document jsonb;
begin
  select
      coalesce( jsonb_object_agg( e.key, e.value ), jsonb_build_object() ) into _document
    from jsonb_each( to_jsonb( _row ) ) e
    where jsonb_typeof( e.value ) != 'null'
  ;

  _document := _document || coalesce( replacer, jsonb_build_object() );

  --language=PostgreSQL
  return query execute format('
    select
        cast( iu.sets as %s ),
        iu.action,
        iu.operation
      from lib.sets_doc( $1, $2, $3, $4, $5, $6 ) iu
    ', _regclass) using _regclass, _document, defaults, ref, t_where, "with";
end
$_$;


--
-- TOC entry 728 (class 1255 OID 16719)
-- Name: sets_defaults(anyelement, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_defaults(anyelement, replacer jsonb DEFAULT NULL::jsonb) RETURNS anyelement
    LANGUAGE plpgsql
    AS $_$
declare
  _doc jsonb;
begin
  _doc := (
      select coalesce( jsonb_object_agg(e.key, e.value ), jsonb_build_object())
      from jsonb_each( to_jsonb($1) )e
      where jsonb_typeof( e.value ) != 'null'
  );
  _doc := _doc || coalesce( $2, '{}' );

  return jsonb_populate_record( $1, lib.sets_defaults( pg_typeof( $1 )::text::regclass, _doc) );
end
$_$;


--
-- TOC entry 722 (class 1255 OID 16720)
-- Name: sets_defaults(regclass, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_defaults(regclass, replacer jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $_$
declare
  _doc jsonb;
begin
  select jsonb_object_agg(
      col.column_name,
      lib.eval( col.column_default::text )
    ) into _doc
  from information_schema.columns col
           inner join pg_class c on c.relname = col.table_name
      and col.table_schema::regnamespace = c.relnamespace
  where col.column_default is not null
    and c.oid = $1;

  if replacer is not null then
    _doc := _doc || replacer;
  end if;
  return _doc;
end;
$_$;


--
-- TOC entry 729 (class 1255 OID 16721)
-- Name: sets_doc(regclass, jsonb, name[], jsonb, text, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_doc(regclass, doc jsonb DEFAULT NULL::jsonb, defaults name[] DEFAULT NULL::name[], ref jsonb DEFAULT NULL::jsonb, t_where text DEFAULT NULL::text, "with" jsonb DEFAULT NULL::jsonb) RETURNS TABLE(sets text, action integer, rows bigint, operation text)
    LANGUAGE plpgsql
    AS $_$
declare
  _result record;
begin
  -- Try update first
  select array_agg( up.sets ) as sets, count( * ) as rows into _result
    from lib.sets_doc_up( $1, doc, defaults, ref, t_where, "with" ) up( sets )
  ;

  if _result.rows > 0 then
    return query
      select
          n.doc,
          0::int,
          _result.rows,
          'update'
        from unnest( _result.sets ) n( doc );
  else
    return query
      select
          ins.sets,
          1::int,
          _result.rows,
          'insert'
        from lib.sets_doc_in( $1, doc, "with" ) ins ( sets );
  end if;
end
$_$;


--
-- TOC entry 730 (class 1255 OID 16722)
-- Name: sets_doc_in(regclass, jsonb, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_doc_in(regclass, doc jsonb DEFAULT '{}'::jsonb, "with" jsonb DEFAULT NULL::jsonb) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
declare
  alias text default "with"->>'alias';
begin
  doc := coalesce( doc, '{}'::jsonb );
  alias := coalesce( nullif( trim( alias), '' ), 't' );

  return query execute(
    with __columns as (
        select
          col.column_name,
          format_type( pt.oid, atttypmod ) column_type,
          col.data_type = 'ARRAY' as is_array,
          col.column_default,
          col.is_generated = 'ALWAYS' as is_generated
        from information_schema.columns col
          inner join pg_class c on c.relname = col.table_name
            and col.table_schema::regnamespace = c.relnamespace
          inner join pg_attribute att on col.column_name = att.attname
            and att.attrelid = format( '%s.%s', col.table_schema, col.table_name )::regclass::oid
          inner join pg_type pt on att.atttypid = pt.oid
        where c.oid = $1

    ), __values as (
      select
          c.*,
          case
            when e.key is null and c.column_default is not null then 'default'
            when e.key is not null and jsonb_typeof( e.value ) = 'null' then format( 'null::%s', c.column_type )
            when e.key is not null then format( '%s::%s', case
              when c.column_type in ( 'json', 'jsonb' ) then e.literal_json
              else e.literal_text
            end, c.column_type )
            else 'null'
          end as value
        from __columns c
          left join lib.each( doc ) e on c.column_name = e.name
    ), __prepare as (
        select
            string_agg( quote_ident( v.column_name ), ', ' ) filter ( where not  v.is_generated ) as prepare_columns,
            string_agg( v.value, ', ' ) filter ( where not  v.is_generated ) as prepare_values
          from __values v
          where v.value is not null
    ) select
        case
          when p.prepare_columns is not null then
            --language=PostgreSQL
            format('insert into %s as %I ( %s ) values( %s ) returning ( %I.* )::text', $1, alias, p.prepare_columns, p.prepare_values, alias )
            --language=PostgreSQL
          else format( 'insert into %s as %I default values returning ( %I.* )::text', alias, alias )
        end
      from __prepare p
  );
end;
$_$;


--
-- TOC entry 731 (class 1255 OID 16723)
-- Name: sets_doc_up(regclass, jsonb, text[], jsonb, text, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_doc_up(regclass, doc jsonb DEFAULT '{}'::jsonb, defaults text[] DEFAULT ARRAY[]::name[], ref jsonb DEFAULT NULL::jsonb, t_where text DEFAULT NULL::text, "with" jsonb DEFAULT NULL::jsonb) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
declare
  /**
    extension:[
      switch = lib.switch
    ]
   */
  _ref jsonb;
  statement text;
  _data record;
  _use_where text default '';
  "security" boolean default "with"->>'security';
  alias text default "with"->>'alias';
  lib_switch boolean default false;
  lib_switch_column text[] default array[]::text[];

begin
  "security" := coalesce( security, true );
  _ref := lib.sets_ref( $1, doc );
  _ref := coalesce( ref, _ref );

  if jsonb_typeof( "with"->'lib.switch' ) = 'boolean' then
    lib_switch := "with"->>'lib.switch';
  elseif jsonb_typeof( "with"->'lib.switch' ) = 'array' then
    lib_switch_column :=  array( select text from  lib.each( "with"->'lib.switch' ) where text is not null );
  end if;
  lib_switch := coalesce( lib_switch, false );

  if security and ( _ref is null or lib.jsonb_object_length( _ref ) = 0 ) then
    return;
  end if;

  defaults := coalesce( defaults, array[]::name[] );
  alias := coalesce( nullif( trim( alias ), '' ), 't' );
  doc := coalesce( doc, '{}'::jsonb );

  with __columns as (
      select
        col.column_name,
        format_type( pt.oid, atttypmod ) column_type,
        col.data_type = 'ARRAY' as is_array,
        col.column_default,
        col.is_generated = 'ALWAYS' as is_generated

      from information_schema.columns col
             inner join pg_class c on c.relname = col.table_name
        and col.table_schema::regnamespace = c.relnamespace
             inner join pg_attribute att on col.column_name = att.attname
        and att.attrelid = format( '%s.%s', col.table_schema, col.table_name )::regclass::oid
             inner join pg_type pt on att.atttypid = pt.oid
      where c.oid = $1
  ), __values as (
    select
        c.column_name,
        c.column_type,
        c.is_generated,
        r.name is not null as _in_ref,
        case
          when c.column_default is not null and d.name is not null then 'default'
          when e.key is not null and jsonb_typeof( e.value ) = 'null' then 'null'
          when e.key is not null and c.column_type in ( 'json', 'jsonb' ) then e.literal_json
          else e.literal_text
        end as value,
        jsonb_typeof( e.value ) = 'array' and not c.is_array and
          true in ( lib_switch, c.column_name = any( lib_switch_column ) )
        as use_swith,
        case
          when r.name is not null and c.column_type in ( 'json', 'jsonb' ) then r.literal_json::text
          when r.name is not null then r.literal_text
        end as ref_value
      from __columns c
        left join lib.each( doc ) e on c.column_name = e.name
        left join lib.each( _ref ) r on c.column_name = r.name
        left join unnest( defaults ) d( name ) on c.column_name = d.name
  ), __sets as (
    select
        v.*,
        v.value is not null as _in_value,
        case
          when not use_swith then format( '%I = %s::%s', v.column_name, v.value, v.column_type )
          else format( '%I = %s::%s', v.column_name, format( 'lib.switch( %I, variadic %s::%s[] )', v.column_name, v.value, v.column_type ), v.column_type )
        end as set
      from __values v
  )
  select
      count( * ) filter ( where s._in_ref ) as _keys,
      string_agg( format( e'   %I = %s::%s\n', s.column_name, s.ref_value, s.column_type ),  e' and ' ) filter ( where s._in_ref ) as _where,

      count( * ) filter ( where s._in_value and not s.is_generated ) as _changes,
      string_agg( format( '    %s', s.set ),          e',\n' ) filter ( where s._in_value and not s.is_generated ) as prepare_sets
      into _data
    from __sets s
    where true in ( s._in_ref, s._in_value )
  ;
  if _data._changes > 0 and ( _data._keys > 0 or not security ) then
    _use_where := case
      when _data._keys > 0 and t_where is null   then  format( e'  where\n %s', _data._where )
      when t_where is not null and  not security then  format( e'  where %s', t_where )
      else                                              format( e'  where false' ) -- don't update anything
    end;

    statement := format( e'update %s as %I set\n %s\n  %s\n  returning ( %I.* )::text', $1, alias, _data.prepare_sets, _use_where, alias );
    return query execute statement;
  end if;
end
$_$;


--
-- TOC entry 732 (class 1255 OID 16725)
-- Name: sets_in(anyelement, jsonb, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_in(_row anyelement, replacer jsonb DEFAULT NULL::jsonb, "with" jsonb DEFAULT NULL::jsonb) RETURNS TABLE("returning" anyelement, action integer, operation text)
    LANGUAGE plpgsql
    AS $_$
declare
  _regclass regclass default pg_typeof( _row )::text::regclass;
  _document jsonb;
begin
  select
      coalesce( jsonb_object_agg( e.key, e.value ), jsonb_build_object() ) into _document
    from jsonb_each( to_jsonb( _row ) ) e
    where jsonb_typeof( e.value ) != 'null'
  ;

  _document := _document || coalesce( replacer, jsonb_build_object() );

  --language=PostgreSQL
  return query execute format( $sql$
    select
        cast( iu.sets as %s ),
        1,
        'insert'
      from lib.sets_doc_in( $1,  $2, $3 ) iu ( sets )
    ;$sql$, _regclass ) using _regclass, _document, "with";
end
$_$;


--
-- TOC entry 716 (class 1255 OID 16726)
-- Name: sets_pks(regclass); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_pks(regclass) RETURNS TABLE(column_name name, column_type regtype)
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select
      pg_attribute.attname,
      format_type(pg_attribute.atttypid, pg_attribute.atttypmod)::regtype
    from pg_index, pg_class, pg_attribute, pg_namespace
    where pg_class.oid = $1
      and indrelid = pg_class.oid
      and pg_class.relnamespace = pg_namespace.oid
      and pg_attribute.attrelid = pg_class.oid
      and pg_attribute.attnum = any( pg_index.indkey )
      and indisprimary
$_$;


--
-- TOC entry 717 (class 1255 OID 16727)
-- Name: sets_pks_array(regclass); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_pks_array(regclass) RETURNS name[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select array(
    select
        pg_attribute.attname
      from pg_index, pg_class, pg_attribute, pg_namespace
      where pg_class.oid = $1
        and indrelid = pg_class.oid
        and pg_class.relnamespace = pg_namespace.oid
        and pg_attribute.attrelid = pg_class.oid
        and pg_attribute.attnum = any( pg_index.indkey )
        and indisprimary
  )
$_$;


--
-- TOC entry 412 (class 1255 OID 16728)
-- Name: sets_ref(anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_ref(_record anyelement) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
select jsonb_object_agg( column_name, to_jsonb( $1 )->column_name )
from lib.sets_pks( pg_typeof( $1 )::text::regclass );
$_$;


--
-- TOC entry 413 (class 1255 OID 16729)
-- Name: sets_ref(jsonb, name[]); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_ref(jsonb, name[]) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select jsonb_object_agg( r.name, to_jsonb( $1 )->( r.name ) )
    from unnest( $2 ) r( name );
$_$;


--
-- TOC entry 553 (class 1255 OID 16730)
-- Name: sets_ref(regclass, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_ref("table" regclass, document jsonb) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select jsonb_object_agg( column_name, $2->column_name )
  from lib.sets_pks( $1 );
$_$;


--
-- TOC entry 414 (class 1255 OID 16731)
-- Name: sets_ref_clean(regclass, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_ref_clean("table" regclass, document jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $_$
declare
  _data record;
begin
  with __doc_each as (
    select
        edoc.key,
        edoc.value,
        edoc.text,
        edoc.type
      from lib.each( document ) edoc
  )
  select
      jsonb_object_agg( pk.column_name , lib.eval( format('to_jsonb((%L)::%s)', e.text, pk.column_type ) )::jsonb ) as reference,
      count( * ) filter ( where e.value is null or e.type = 'null') as invalids
      into _data
    from lib.sets_pks( $1 ) pk
      left join __doc_each e on pk.column_name = e.key
  ;

  if _data.invalids = 0 then
    return _data.reference;
  end if;
  return null;
end;
$_$;


--
-- TOC entry 415 (class 1255 OID 16732)
-- Name: sets_up(anyelement, jsonb, text[], jsonb, text, jsonb); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.sets_up(_row anyelement, replacer jsonb DEFAULT NULL::jsonb, defaults text[] DEFAULT NULL::text[], ref jsonb DEFAULT NULL::jsonb, t_where text DEFAULT NULL::text, "with" jsonb DEFAULT NULL::jsonb) RETURNS TABLE("returning" anyelement, action integer, operation text)
    LANGUAGE plpgsql
    AS $_$
declare
  _regclass regclass default pg_typeof( _row )::text::regclass;
  _document jsonb;
begin
  select
      coalesce( jsonb_object_agg( e.key, e.value ), jsonb_build_object() ) into _document
    from jsonb_each( to_jsonb( _row ) ) e
    where jsonb_typeof( e.value ) != 'null'
  ;

  _document := _document || coalesce( replacer, jsonb_build_object() );

  --language=PostgreSQL
  return query execute format($sql$
    select
        iu.sets::%s ,
        0,
        'update'
      from lib.sets_doc_up( $1, $2, $3, $4, $5, $6 ) iu( sets )
    $sql$, _regclass ) using _regclass, _document, defaults, ref, t_where, "with";
end
$_$;


--
-- TOC entry 416 (class 1255 OID 16733)
-- Name: str_is_numeric_sequence(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.str_is_numeric_sequence(argment text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para verificar se uma string é uma sequencia numerica inteira
   */
  list character [] default regexp_split_to_array( argment, '');
  nums character [] default regexp_split_to_array( '0123456789', '');
  c character;

begin
  foreach c in array list loop
    -- quando do carracter for diferente de todos os algarismos expressos no array
    if  c != all ( nums ) then
      return false;
    end if;
  end loop;

  return true;
end;

$$;


--
-- TOC entry 422 (class 1255 OID 16734)
-- Name: str_nospace(text); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.str_nospace(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
/**
  Essa função serve para remover todos os espaçõs em uma string
 */
select lib.str_normalize( replace( $1, ' ', '' ) )
$_$;


--
-- TOC entry 417 (class 1255 OID 16735)
-- Name: switch(anyelement, anyarray); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.switch(anyelement, VARIADIC list anyarray) RETURNS anyelement
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
  _element record;
begin

  -- List na posição 1 é o valor atual por isso não pode ser nulo
  if $1 is null then return null; end if;

  with __clean as (
    select v.value,
        mode() within group ( order by index ) as findex
      from  unnest( list ) with ordinality v( value, index)
      where value is not null
      group by v.value
  ) select array_agg( value order by findex ) into list from __clean;

  if list is null then return $1; end if;
  
  if array_length( list, 1 ) = 0 then
    return $1;
  end if;

  -- Quando a lista tiver apenas um unico elemento
  if array_length( list, 1 ) = 1 then
    return list[ 1 ];
  end if;

  -- Para lista de mais de um elemento
  for i in 1 .. array_length( list, 1 ) loop

    if $1 = list[ i ] and i = array_length( list, 1 ) then
      return list[ 1 ];
    elseif $1 = list[ i ] then
      return list [ i+1 ];
    end if;
  end loop;

  return null;
end;
$_$;


--
-- TOC entry 418 (class 1255 OID 16736)
-- Name: swith(anyarray); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.swith(VARIADIC list anyarray) RETURNS anyelement
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  _element record;
begin

  -- List na posição 1 é o valor atual por isso não pode ser nulo
  if list[ 1 ] is null then return null; end if;

  -- distinct elements and clean null
  for _element in
    select *
      from unnest( list ) with ordinality li( element, index )
      where li.element is not null
  loop
    if _element.element = any ( list ) then continue;
    else list := list || _element.element;
    end if;
  end loop;

  -- Quando a lista tiver apenas um unico elemento
  if array_length( list, 1 ) = 2 and list[ 1 ] = list[ 2 ] then
    return list[ 1 ];
  elseif array_length( list, 1 ) = 2 then
    return null;
  end if;

  -- Para lista de mais de um elemento
  for i in 2 .. array_length( list, 1 ) loop

    if list[ i ] = list[ 1 ] and i = array_length( list, 1 ) then
      return list[ 2 ];
    elseif list[ i ] = list[ 1 ] then
      return list [ i+1 ];
    end if;
  end loop;

  return null;
end;
$$;


--
-- TOC entry 423 (class 1255 OID 16737)
-- Name: version(); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib.version() RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
select 'v1-uuid.3.7::0 - 2019.04.09'
$$;


--
-- TOC entry 419 (class 1255 OID 16738)
-- Name: when(boolean, anyelement, anyelement); Type: FUNCTION; Schema: lib; Owner: -
--

CREATE FUNCTION lib."when"(boolean, _then anyelement, _else anyelement DEFAULT NULL::unknown) RETURNS anyelement
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ select case when $1 then $2 else $3 end $_$;


--
-- TOC entry 420 (class 1255 OID 16739)
-- Name: api_change_entryset(jsonb); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.api_change_entryset(args jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    essa funcao server para editar uma entrada editavel
   */
  name name default args->>'name';
  value varchar default args->>'value';
  label varchar default args->>'label';
  domain varchar default args->>'domain';
begin
  return libdom.set( name, value, label, domain, false );
end;
$$;


--
-- TOC entry 421 (class 1255 OID 16740)
-- Name: api_load_entryset(jsonb); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.api_load_entryset(args jsonb) RETURNS SETOF jsonb
    LANGUAGE sql
    AS $$
  select to_jsonb( e )
    from libdom.entryset e
    where e.editable
    order by e.domain nulls last,
      e.label,
      e.name,
      e.value

$$;


--
-- TOC entry 424 (class 1255 OID 16741)
-- Name: columns(regclass); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.columns(regclass) RETURNS TABLE(name character varying, type character varying, defaults text, isarray boolean, isgenerated boolean)
    LANGUAGE sql IMMUTABLE STRICT PARALLEL SAFE
    AS $_$
with __columns as (
  select
    col.column_name,
    format_type( pt.oid, atttypmod )::varchar column_type,
    col.column_default,
    col.data_type = 'ARRAY' as is_array,
    col.is_generated = 'ALWAYS' as is_generated
  from information_schema.columns col
         inner join pg_class c on c.relname = col.table_name
    and col.table_schema::regnamespace = c.relnamespace
         inner join pg_attribute att on col.column_name = att.attname
    and att.attrelid = format( '%s.%s', col.table_schema, col.table_name )::regclass::oid
         inner join pg_type pt on att.atttypid = pt.oid
  where c.oid = $1
) select *
from __columns _c
$_$;


--
-- TOC entry 425 (class 1255 OID 16742)
-- Name: constant(character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.constant(VARIADIC prefix character varying[] DEFAULT '{}'::character varying[]) RETURNS libdom.constant
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
  /**
    Essa função serve para carregar os valores das constante e inicia-la
   */
  select jsonb_populate_record( null::libdom.constant, libdom.constant_document( variadic prefix ));
$$;


--
-- TOC entry 426 (class 1255 OID 16743)
-- Name: constant_document(character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.constant_document(VARIADIC prefix character varying[] DEFAULT '{}'::character varying[]) RETURNS jsonb
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
  -- Devolver o mapeamento dos estados
   select
      jsonb_object_agg( cv.name, cv.value )
    from libdom.prefix( variadic prefix ) cv
;
$$;


--
-- TOC entry 427 (class 1255 OID 16744)
-- Name: describe(character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.describe(VARIADIC prefix character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(declaration text, name name, type regtype, value text, domain character varying, label character varying, editable boolean, comment character varying, "default" character varying)
    LANGUAGE sql IMMUTABLE
    AS $$
-- Devolver o mapeamento dos estados
  select
      format( '%I %s default %L::%s;', cv.name, cv.type, cv.value, cv.type ),
      cv.*,
      format( 'libdom.get(%L::name)::%s', cv.name, cv.type )
    from libdom.prefix(  variadic prefix ) cv
$$;


--
-- TOC entry 428 (class 1255 OID 16745)
-- Name: domain(character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.domain(VARIADIC prefix character varying[] DEFAULT '{}'::character varying[]) RETURNS libdom.domain
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
      /**
        Essa função serve para carregar os valores das constante e inicia-la
       */
  select jsonb_populate_record( null::libdom.domain, libdom.domain_document( variadic prefix ));
$$;


--
-- TOC entry 429 (class 1255 OID 16746)
-- Name: domain_document(character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.domain_document(VARIADIC prefix character varying[] DEFAULT '{}'::character varying[]) RETURNS jsonb
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
  -- Devolver o mapeamento dos estados
  select
      jsonb_object_agg( cv.name, cv.label )
    from libdom.prefix( variadic prefix ) cv
  ;
$$;


--
-- TOC entry 430 (class 1255 OID 16747)
-- Name: domain_of(name); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.domain_of(name name) RETURNS text
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$

  /**
      Essa função serve para devolver o valor especifico de uma constante
   */
  select cv.label
    from libdom.entryset cv
    where cv.name = domain_of.name;
$$;


--
-- TOC entry 431 (class 1255 OID 16748)
-- Name: domain_of(character varying, text); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.domain_of(domain character varying, value text) RETURNS text
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$

  /**
      Essa função serve para devolver o valor especifico de uma constante
   */
  select cv.label
    from libdom.entryset cv
    where cv.name = domain_of.domain
      and cv.value = domain_of.value;
$$;


--
-- TOC entry 579 (class 1255 OID 123448)
-- Name: domset(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.domset(_class character varying, _column character varying, _domain character varying, _comment character varying DEFAULT NULL::character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**doc

   doc*/
  _data record;
begin
    update libdom.domsync
      set domain = _domain,
          comment = _comment
    where classname = _class
      and columnname = _column
    returning * into _data
  ;

  if _data.classname is null then
    insert into libdom.domsync(
      classname,
      columnname,
      domain,
      comment
    ) values (
      _class,
      _column,
      _domain,
      _comment
    );
  end if;
  return true;
end;
$$;


--
-- TOC entry 432 (class 1255 OID 16749)
-- Name: domsync(character varying, character varying, character varying); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.domsync(classname character varying, columnname character varying, domain character varying) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
declare
  _comment record;
  _domsync record;
  _command text;
begin
  for _domsync in
    with __column_comment as (
      select
          ds.classname,
          ds.columnname,
          array_agg( ds.domain ) as _domain,
          format( '<ul>%s</ul>',
            string_agg( format( '<li>%s ->> %s</li>', ds.domain, ds.comment ), e'\n' ) filter ( where ds.comment is not null )
          ) as comment
        from libdom.domsync ds
          inner join libdom.columns( ds.classname::regclass ) c on ds.columnname = c.name
        where ds.classname = coalesce ( $1, ds.classname )
          and ds.columnname = coalesce( $2, ds.columnname )
          and ds.domain = coalesce( $3, ds.domain )
        group by ds.classname, ds.columnname
    ) select *
        from __column_comment cc
        where domsync.domain = any ( cc._domain ) or domsync.domain is null
  loop
      select
          format( '<table><tr><th>lable</th><th>value</th><th>domain</th><th>name</th></tr>%s</table>', string_agg( format( '<tr>%s %s %s %s </tr>',
            format( '<td>%s</td>', es.label ),
            format( '<td>%s</td>', es.value ),
            format( '<td>%s</td>', es.domain ),
            format( '<td>%s</td>', es.name )
          ), e'\n' ) ) as comment
          into _comment
        from libdom.entryset es
        where es.domain = any ( _domsync._domain );

      _command := format( 'comment on column %s.%I is $comment$ %s $comment$;', _domsync.classname, _domsync.columnname, format( e'<html><style>
table, th, td {
  border:1px solid black;
}
</style><body><div>%s\n%s</div></body></html>', _domsync.comment, _comment.comment ) );
      execute _command;
      return next _command;
  end loop;
end
$_$;


--
-- TOC entry 433 (class 1255 OID 16750)
-- Name: entry(name, regtype, anyelement, character varying, character varying, boolean, character varying, boolean); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.entry(name name, type regtype, val anyelement, domain character varying DEFAULT NULL::character varying, label character varying DEFAULT NULL::character varying, editable boolean DEFAULT false, comment character varying DEFAULT NULL::character varying, force boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**
    * Essa função serve para registrar o valor de uma constante na base de dados
    * Se a constante já tiver o valor definido esse valor pode ser subistituido
      pelo novo desde que o parametro arg_entryset_replace estiver verdadeiro
    * Caso existir sem o parametro arg_entryset_replace verdadeiro uma excessão sera lançada
   */
  _entryset libdom.entryset;

begin

  editable := coalesce( editable, false );

  if domain is null and exists(
    select *
      from libdom.entryset e
      where e.domain = entry.domain
        and e.name != entry.name
        and e.value = val::text
  ) and not force then
    raise exception 'Já existe um dominio com o mesmo valor para este grupo!';
  end if;

  select * into _entryset
    from libdom.entryset const
    where const.name = entry.name
  ;


  -- Deletar o valor de constante
  delete from libdom.entryset e where e.name = entry.name;

  -- Recriar o valor de constante
  insert into libdom.entryset(
    name,
    type,
    value,
    editable,
    label,
    comment,
    domain
  ) values (
     entry.name,
     entry.type,
     entry.val,
     entry.editable,
     entry.label,
     entry.comment,
     entry.domain
   ) returning * into _entryset;
  return true;
end;
$$;


--
-- TOC entry 434 (class 1255 OID 16751)
-- Name: entry_drop(name, boolean); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.entry_drop(arg_name name, arg_dropforce boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**
    * Essa função serve para registrar o valor de uma constante na base de dados
    * Se a constante já tiver o valor definido esse valor pode ser subistituido
      pelo novo desde que o parametro arg_entryset_replace estiver verdadeiro
    * Caso existir sem o parametro arg_entryset_replace verdadeiro uma excessão sera lançada
   */
  _entryset libdom.entryset;
  command text;
  arg_entryset_continer regtype := 'libdom.constant'::regtype;
begin
  arg_dropforce := coalesce( arg_dropforce, false );
  select * into _entryset
    from libdom.entryset const
    where const.name = arg_name
  ;

  -- Destruir a constante casao existir
  if arg_dropforce then
    command := format( 'alter type %s drop attribute if exists %I cascade;', arg_entryset_continer, arg_name );
  else
    command := format( 'alter type %s drop attribute if exists %I;', arg_entryset_continer, arg_name );
  end if;
  execute command;

  -- Deletar o valor de constante
  delete from libdom.entryset where name = arg_name;

  return true;
end;
$$;


--
-- TOC entry 435 (class 1255 OID 16752)
-- Name: entry_list(jsonb); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.entry_list(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _name character varying default args->>'name';
  _value character varying default args->>'value';
  _domain character varying default args->>'domain';
  _label character varying default args->>'label';
begin
  return query
    with __entry as (
      select
          es.name,
          es.type,
          es.value,
          es.domain,
          es.label
        from libdom.entryset es
        where es.name = coalesce( _name, es.name )
          and es.value = coalesce( _value, es.value )
          and coalesce( es.domain, '' ) = coalesce( _domain, es.domain, '' )
          and coalesce( es.label, '' ) = coalesce( _label, es.label, '' )
      ) select to_jsonb( _e )
          from __entry _e
          order by _e.domain,
            _e.label,
            _e.name,
            _e.value
  ;
end;
$$;


--
-- TOC entry 436 (class 1255 OID 16753)
-- Name: exports(character varying, character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.exports(schema_name character varying DEFAULT 'libdom'::character varying, VARIADIC name character varying[] DEFAULT ARRAY[]::character varying[]) RETURNS TABLE(name character varying, type regtype, value text, declaration text)
    LANGUAGE sql
    AS $_$
with names as (
  select array_agg( distinct coalesce( un, '')||'%' ) as list
  from unnest( $2 ) un
)
  select
    cv.name,
    cv.type,
    cv.value,
    format( 'select %I.entry(name := %L, type := %L::regtype, val := %L::text, domain := %L::varchar, label := %L, editable := %L, comment := %L );',
            schema_name,
            cv.name,
            cv.type,
            cv.value,
            cv.domain,
            cv.label,
            cv.editable,
            cv.comment
      )
  from libdom.entryset cv inner join names na on true
  where cv.name like any( na.list )
$_$;


--
-- TOC entry 437 (class 1255 OID 16754)
-- Name: get(name); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.get(arg_name name) RETURNS text
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$

  /**
      Essa função serve para devolver o valor especifico de uma constante
   */
  select cv.value
    from libdom.entryset cv
    where cv.name = arg_name;
$$;


--
-- TOC entry 242 (class 1259 OID 16755)
-- Name: entryset; Type: TABLE; Schema: libdom; Owner: -
--

CREATE TABLE libdom.entryset (
    name name NOT NULL,
    type regtype NOT NULL,
    value text NOT NULL,
    domain character varying,
    label character varying,
    editable boolean DEFAULT false NOT NULL,
    comment character varying
);


--
-- TOC entry 5799 (class 0 OID 0)
-- Dependencies: 242
-- Name: TABLE entryset; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON TABLE libdom.entryset IS 'Essa entidade serve para armazenar os valores das constantes';


--
-- TOC entry 5800 (class 0 OID 0)
-- Dependencies: 242
-- Name: COLUMN entryset.name; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON COLUMN libdom.entryset.name IS 'Corresponde ao nome da constante';


--
-- TOC entry 5801 (class 0 OID 0)
-- Dependencies: 242
-- Name: COLUMN entryset.type; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON COLUMN libdom.entryset.type IS 'Corresponde ao tipo da constante';


--
-- TOC entry 5802 (class 0 OID 0)
-- Dependencies: 242
-- Name: COLUMN entryset.value; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON COLUMN libdom.entryset.value IS 'Corresponde ao valor da constante';


--
-- TOC entry 5803 (class 0 OID 0)
-- Dependencies: 242
-- Name: COLUMN entryset.label; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON COLUMN libdom.entryset.label IS 'Corresponde a descrição da constante';


--
-- TOC entry 5804 (class 0 OID 0)
-- Dependencies: 242
-- Name: COLUMN entryset.editable; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON COLUMN libdom.entryset.editable IS 'Esse atributo indica se a constante pode ser editavel';


--
-- TOC entry 5805 (class 0 OID 0)
-- Dependencies: 242
-- Name: COLUMN entryset.comment; Type: COMMENT; Schema: libdom; Owner: -
--

COMMENT ON COLUMN libdom.entryset.comment IS 'Commentario para a constante';


--
-- TOC entry 438 (class 1255 OID 16761)
-- Name: prefix(character varying[]); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.prefix(VARIADIC prefix character varying[] DEFAULT '{}'::character varying[]) RETURNS SETOF libdom.entryset
    LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE
    AS $$
declare
  _prefix varchar[];
  _length int default coalesce( array_length( prefix, 1), 0 );
begin
  select array_agg( format( '%s%%', e.element ) ) into _prefix
  from unnest( coalesce( prefix, '{}'::text[] ) ) e ( element );

  return query
    select e.*
    from libdom.entryset e
    where e.name like any( _prefix )
       or _length = 0
  ;
end;
$$;


--
-- TOC entry 439 (class 1255 OID 16762)
-- Name: rebuild(boolean); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.rebuild(clean boolean) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
declare
  _data record;
  _const libdom.constant;
  _dom libdom.domain;
  command text;
  constant_class regtype default 'libdom.constant'::regtype;
  domain_class regtype default 'libdom.domain'::regtype;
begin

  -- Lipar todos os atributos atual nas classe de dominio e de constant
  if clean then
    for _data in
      select *
        from jsonb_each (to_jsonb( _const ))
    loop
      command := format( 'alter type %s drop attribute if exists %I', _data.key, constant_class );
      execute command;
    end loop;

    for _data in
      select *
        from jsonb_each (to_jsonb( _dom ))
    loop
      command := format( 'alter type %s drop attribute if exists %I', _data.key, domain_class);
      execute command;
    end loop;

  end if;

  -- Recriar todos os atributos para a classe de dominio e de constant
  for _data in
    select *
      from libdom.entryset e
  loop
    return next to_jsonb( _data )::text;
    return query select * from libdom.sync_entry( _data.name, 'libdom.constant' );
    return query select * from libdom.sync_entry( _data.name, 'libdom.domain' );
  end loop;
  
  return query select * from libdom.domsync( null, null, null );
end;
$$;


--
-- TOC entry 440 (class 1255 OID 16763)
-- Name: set(name, character varying, character varying, character varying, boolean); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.set(name name, value character varying DEFAULT NULL::character varying, label character varying DEFAULT NULL::character varying, domain character varying DEFAULT NULL::character varying, force boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
      Essa função serve para atualizar o valor de uma constante
   */
  _entryset libdom.entryset;
begin

  if domain is null and exists(
      select *
      from libdom.entryset e
      where e.domain = set.domain
        and e.name != set.name
        and e.value = set.value::text
    ) and not force then
    return jsonb_build_object(
      'result', false,
      'message', 'Já existe um dominio com o mesmo valor para este grupo!'
    );
  end if;

  if !exists(
    select *
      from libdom.entryset e
      where e.name = set.name
        and e.editable
  ) then
    return jsonb_build_object(
        'result', false,
        'message', 'Não existe uma entrada editavel com este nome!'
      );
  end if;

  update libdom.entryset
    set ( value, label, domain ) = ( value, label, domain )
    where name = name
    returning * into _entryset
  ;

  return jsonb_build_object(
    'result', true,
    'data', jsonb_build_object(
      'entryset', _entryset
    )
  );
end;
$$;


--
-- TOC entry 441 (class 1255 OID 16764)
-- Name: sync_drop(name, regtype); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.sync_drop(name name, classtype regtype) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
declare
  command text;
begin
  command := format( 'alter type %s drop attribute if exists %I', classtype, name );
  execute command;
end;
$$;


--
-- TOC entry 442 (class 1255 OID 16765)
-- Name: sync_entry(name, regtype); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.sync_entry(name name, classtype regtype) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Syncronizar uma entry em na calsse expecificada
   */
  command text;
  _entry libdom.entryset;
  _type regtype default 'text'::regtype;
begin

  select * into _entry
    from libdom.entryset e
    where e.name = sync_entry.name;

  if classtype = 'libdom.constant'::regtype then
    _type := _entry.type;
  end if;

  -- Destruir a constante casao existir
  command := format( 'alter type %s drop attribute if exists %I;', classtype, name );
  execute command;
  return next command;

  -- Recriar a constante novamente
  command := format( 'alter type %s add attribute %I %s;', classtype, name, _type );
  execute command;
  return next command;

  if _entry.comment is not null then
    command := format( 'comment on column %s.%I is %L;', classtype, name, _entry.comment );
    execute command;
    return next command;
  end if;
end;
$$;


--
-- TOC entry 443 (class 1255 OID 16766)
-- Name: trigger_sync_domsync(); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.trigger_sync_domsync() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new libdom.domsync;
  _old libdom.domsync;
begin
  if tg_op in ( 'UPDATE', 'INSERT' ) then
    perform libdom.domsync( _new.classname, _new.columnname, _new.domain );
  end if;
  return null;
end;
$$;


--
-- TOC entry 444 (class 1255 OID 16767)
-- Name: trigger_sync_entry(); Type: FUNCTION; Schema: libdom; Owner: -
--

CREATE FUNCTION libdom.trigger_sync_entry() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new libdom.entryset;
  _old libdom.entryset;
begin
  _new := new;
  _old := old;


  if tg_op = 'UPDATE' and _new.name != _old.name then
    perform libdom.sync_drop( _old.name, 'libdom.constant' );
    perform libdom.sync_drop( _old.name, 'libdom.domain' );
  end if;

  if tg_op in ( 'INSERT', 'UPDATE' ) and (
    coalesce( _new.name::text, '' ) != coalesce( _old.name::text, '' )
    or coalesce( _new.type::text, '' ) != coalesce( _old.type::text, '' )
    or coalesce( _new.comment::text, '' ) != coalesce( _old.comment::text, '' )
  ) then
    perform libdom.sync_entry( _new.name, 'libdom.constant' );
    perform libdom.sync_entry( _new.name, 'libdom.domain' );
    perform libdom.domsync( null, null, _new.domain );
  end if;

  if tg_op in ( 'DELETE'  ) then
    perform libdom.sync_drop( _old.name, 'libdom.constant' );
    perform libdom.sync_drop( _old.name, 'libdom.domain' );
    return null;
  end if;


  if tg_op in ( 'INSERT', 'UPDATE' ) then
    return _new;
  end if;
end;
$$;


--
-- TOC entry 472 (class 1255 OID 16768)
-- Name: any_equal(anyelement, name[]); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.any_equal(anyelement, VARIADIC name name[]) RETURNS boolean
    LANGUAGE sql
    AS $_$
select $1 = any( map.array( $1, variadic $2 ) );
$_$;


--
-- TOC entry 473 (class 1255 OID 16769)
-- Name: array(anyelement, name[]); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map."array"(anyelement, VARIADIC name name[]) RETURNS anyarray
    LANGUAGE plpgsql
    AS $_$
declare
begin
  return array(
    select kv.constvalue_value
      from map.constvalue kv
      where kv.constvalue_name = any( $2 )
  );
end
$_$;


--
-- TOC entry 591 (class 1255 OID 16770)
-- Name: as_json(); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.as_json() RETURNS jsonb
    LANGUAGE sql
    AS $$
  --
  select to_jsonb( map.constant() );
$$;


--
-- TOC entry 733 (class 1255 OID 16771)
-- Name: constant(name, regtype, anyelement, character varying, boolean, character varying); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constant(name name, type regtype, val anyelement, description character varying DEFAULT NULL::character varying, editable boolean DEFAULT false, comment character varying DEFAULT NULL::character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**
    * Essa função serve para registrar o valor de uma constante na base de dados
    * Se a constante já tiver o valor definido esse valor pode ser subistituido
      pelo novo desde que o parametro arg_constant_replace estiver verdadeiro
    * Caso existir sem o parametro arg_constant_replace verdadeiro uma excessão sera lançada
   */
  _constvalue map.constvalue;
  command text;
  arg_constant_continer regtype := 'map.constant'::regtype;
begin

  editable := coalesce( editable, false );

  select * into _constvalue
  from map.constvalue const
  where const.constvalue_name = name
  ;

  -- Destruir a constante casao existir
  command := format( 'alter type %s drop attribute if exists %I;', arg_constant_continer, name );
  execute command;

  -- Recriar a constante novamente
  command := format( 'alter type %s add attribute %I %s;', arg_constant_continer, name, type );
  execute command;

  if comment is not null then
    command := format( 'comment on column %s.%I is %L;', arg_constant_continer, name, comment );
  end if;

  -- Deletar o valor de constante
  delete from map.constvalue where constvalue_name = name;

  -- Recriar o valor de constante
  insert into map.constvalue(
    constvalue_name,
    constvalue_type,
    constvalue_value,
    constvalue_editable,
    constvalue_descrision,
    constvalue_comment
  ) values (
     name,
     type,
     val,
     editable,
     description,
     comment
   ) returning * into _constvalue;

  return false;
end;
$$;


--
-- TOC entry 471 (class 1255 OID 16772)
-- Name: constant_list(character varying[]); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constant_list(VARIADIC name character varying[] DEFAULT NULL::character varying[]) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
begin
  $1 := coalesce( $1, array[ '' ]::text[] );
  -- Devolver o mapeamento dos estados
  return (
    with names as (
      select array_agg( distinct coalesce( un, '')||'%' ) as list
        from unnest( $1 ) un
    )
    select jsonb_object_agg( cv.constvalue_name, cv.constvalue_value )
      from map.constvalue cv
        inner join names na on true
      where cv.constvalue_name like any( na.list )
  );
end;
$_$;


--
-- TOC entry 734 (class 1255 OID 16773)
-- Name: constant_list(character varying); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constant_list(name character varying DEFAULT NULL::character varying) RETURNS jsonb
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- Devolver o mapeamento dos estados
  select jsonb_object_agg( cv.constvalue_name, cv.constvalue_value )
    from map.constvalue cv
    where cv.constvalue_name like coalesce( $1, '')||'%';
$_$;


--
-- TOC entry 446 (class 1255 OID 16774)
-- Name: constant_rename(name, name, boolean); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constant_rename(name name, newname name, force boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**
    * Essa função serve para registrar o valor de uma constante na base de dados
    * Se a constante já tiver o valor definido esse valor pode ser subistituido
      pelo novo desde que o parametro arg_constant_replace estiver verdadeiro
    * Caso existir sem o parametro arg_constant_replace verdadeiro uma excessão sera lançada
   */
  _constvalue map.constvalue;

begin


  select * into _constvalue
    from map.constvalue const
    where const.constvalue_name = name
  ;

  if _constvalue.constvalue_name is null then return false; end if;
  perform map.constantdrop(name, force );
  return map.constant(
    newname,
    _constvalue.constvalue_type,
    _constvalue.constvalue_value,
    _constvalue.constvalue_descrision,
    _constvalue.constvalue_editable,
    _constvalue.constvalue_comment
  );
end;
$$;


--
-- TOC entry 735 (class 1255 OID 16775)
-- Name: constantdrop(name, boolean); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constantdrop(arg_constant_name name, arg_dropforce boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  /**
    * Essa função serve para registrar o valor de uma constante na base de dados
    * Se a constante já tiver o valor definido esse valor pode ser subistituido
      pelo novo desde que o parametro arg_constant_replace estiver verdadeiro
    * Caso existir sem o parametro arg_constant_replace verdadeiro uma excessão sera lançada
   */
  _constvalue map.constvalue;
  command text;
  arg_constant_continer regtype := 'map.constant'::regtype;
begin
  arg_dropforce := coalesce( arg_dropforce, false );
  select * into _constvalue
    from map.constvalue const
    where const.constvalue_name = arg_constant_name
  ;

  -- Destruir a constante casao existir
  if arg_dropforce then
    command := format( 'alter type %s drop attribute if exists %I cascade;', arg_constant_continer, arg_constant_name );
  else
    command := format( 'alter type %s drop attribute if exists %I;', arg_constant_continer, arg_constant_name );
  end if;
  execute command;

  -- Deletar o valor de constante
  delete from map.constvalue where constvalue_name = arg_constant_name;

  return true;
end;
$$;


--
-- TOC entry 447 (class 1255 OID 16776)
-- Name: constants(character varying); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.constants(name character varying DEFAULT NULL::character varying) RETURNS jsonb
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- Devolver o mapeamento dos estados
  select jsonb_object_agg( cv.constvalue_name, cv.constvalue_value )
    from map.constvalue cv
    where cv.constvalue_name like coalesce( $1, '')||'%';
$_$;


--
-- TOC entry 736 (class 1255 OID 16777)
-- Name: describe(character varying[]); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.describe(VARIADIC name character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(name name, type regtype, value text, editable boolean, descrision character varying, comment character varying)
    LANGUAGE sql IMMUTABLE
    AS $_$
  -- Devolver o mapeamento dos estados
  with names as (
    select array_agg( distinct coalesce( un, '')||'%' ) as list
      from unnest( $1 ) un
  )
  select cv.*
    from map.constvalue cv
      inner join names na on true
    where cv.constvalue_name like any( na.list ) ;
$_$;


--
-- TOC entry 737 (class 1255 OID 16778)
-- Name: funct_change_constvalue(jsonb); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.funct_change_constvalue(arg jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
      Essa função serve para atualizar o valor de uma constante
   */
  arg_constvalue_name name default arg->>'constvalue_name';
  arg_constvalue_value name default arg->>'constvalue_value';
  _constvalue map.constvalue;
begin
  select * into _constvalue
  from map.constvalue const
  where const.constvalue_name = arg_constvalue_name
  ;

  if not _constvalue.constvalue_editable then
    return lib.result_false( 'map.constvalue.editable-false' );
  end if;

  update map.constvalue
  set constvalue_value = arg_constvalue_value
  where constvalue_name = arg_constvalue_name
        returning * into _constvalue
  ;

  return lib.result_true(
    jsonb_build_object(
      'constvalue', _constvalue
    )
  );
end;
$$;


--
-- TOC entry 738 (class 1255 OID 16779)
-- Name: funct_load_constvalue(jsonb); Type: FUNCTION; Schema: map; Owner: -
--

CREATE FUNCTION map.funct_load_constvalue(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(constvalue_name name, constvalue_type regtype, constvalue_value text, constvalue_editable boolean, constvalue_descrision character varying, constvalue_comment character varying)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  /**
    Essa função serve para listar todas as constante que o valor poder ser atualizada
      == Listagem dos parametros
   */
begin
  return query
    select *
    from map.constvalue cons
    where cons.constvalue_editable;
end;
$$;


--
-- TOC entry 515 (class 1255 OID 169522)
-- Name: create_raw(text); Type: FUNCTION; Schema: patch; Owner: -
--

CREATE FUNCTION patch.create_raw(text text) RETURNS TABLE(raw_uid uuid, raw_math text, raw_text text)
    LANGUAGE plpgsql
    AS $$
  declare
    _data record;
    _raw patch.raw;
  begin
    select * into _data from /**/ patch . /**/ raw_of( text );
    create_raw.raw_text := _data.raw_text;
    create_raw.raw_math := _data.raw_math;
    create_raw.raw_uid := _data.raw_uid;
    
    if create_raw.raw_uid is null then
      insert into patch.raw ( raw_text, raw_match ) values ( _data.raw_text, _data.raw_math )
      returning * into _raw;
      create_raw.raw_uid := _raw.raw_uid;
    end if;
    
    return next;
  end;
$$;


--
-- TOC entry 513 (class 1255 OID 169521)
-- Name: raw_of(text); Type: FUNCTION; Schema: patch; Owner: -
--

CREATE FUNCTION patch.raw_of(text text) RETURNS TABLE(raw_uid uuid, raw_math text, raw_text text)
    LANGUAGE plpgsql
    AS $$
  declare
    _data patch.raw;
  begin
    raw_of.raw_math :=  lib.str_normalize( text );
    raw_of.raw_text := text;
    select * into _data
      from patch.raw r
      where r.raw_match = raw_of.raw_math;
    
    raw_of.raw_uid := _data.raw_uid;
    return next;
  end;
$$;


--
-- TOC entry 537 (class 1255 OID 16782)
-- Name: ref(character varying, character varying); Type: FUNCTION; Schema: patch; Owner: -
--

CREATE FUNCTION patch.ref(file character varying, identifier character varying) RETURNS character varying
    LANGUAGE sql IMMUTABLE
    AS $$
  select 'ref:'||file||'//'||identifier
$$;


--
-- TOC entry 496 (class 1255 OID 16783)
-- Name: revision(jsonb); Type: FUNCTION; Schema: patch; Owner: -
--

CREATE FUNCTION patch.revision(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
  <<sys>>
  declare
    _file character varying default args->>'file';
    _identifier character varying default args->>'identifier';
    _ref character varying default patch.ref(  _file, _identifier );
    _raw text not null default args->>'raw';
    _flags text[] default array( select lower( e.text ) from jsonb_array_elements_text( args->'flags' ) e( text ) );
    _configs jsonb default coalesce( args->'configs', jsonb_build_object() );
    _connection character varying default "current_user"();
    _patches patch.revision;
    _error jsonb;
    _force boolean default '@force' = any( _flags );
    _force_number int default 0;
    _last record;
    _raw_instance record;
  begin
    raise notice '%', args;
    select * into _patches
      from patch.revision p
      where p.ref = sys._ref
    order by
      p.seq desc
    limit 1;

    if _patches.ref is not null and '@unique' = any( _patches.flags ) and not _force then return lib.res_false('unique applied' ); end if;
    
    select * into _raw_instance from /* */ patch . /* */ raw_of( _raw);
    
    select * into _last
        from patch.revision p
        where p.ref = _ref
          order by p.version desc,  p.seq desc
        ;

    if _last.ref is not null and _raw_instance.raw_uid is not null and _last._raw_uid = _raw_instance.raw_uid and not _force then return lib.res_false('no changes' );
    elseif _last.ref is not null and _raw_instance.raw_uid is not null and _last._raw_uid = _raw_instance.raw_uid then
      _force_number := _last.force +1;

    end if;
    
    select * into _raw_instance
      from /* */ patch . /* */ create_raw( _raw );

    
    insert into patch.revision(
      file,
      identifier,
      _raw_uid,
      flags,
      configs,
      status,
      connection,
      version,
      force
    ) values (
     _file,
     _identifier,
     _raw_instance.raw_uid,
     _flags,
     _configs,
     1,
     _connection,
     coalesce( _patches.version, 0 ) +1,
     _force_number
   ) returning * into _patches;

    begin
      execute _raw_instance.raw_text;
    exception when others then
      <<_ex>>
      declare
        e text; m text; d text; h text; c text;
      begin
        get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
        _error := jsonb_build_object(
          'state', e,
          'message', m
        );
      end;
    end;

    return lib.res_true( jsonb_build_object(
      'patches', _patches,
      'error', _error
    ));
  end;
$$;


--
-- TOC entry 511 (class 1255 OID 157463)
-- Name: consts(text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.consts(VARIADIC consts text[]) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
declare
begin
end;
$$;


--
-- TOC entry 739 (class 1255 OID 94091)
-- Name: regula(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.regula(_cred_id integer) RETURNS TABLE(cred_id integer, deb_id integer, deb double precision, excedente double precision, faltando double precision, regula double precision)
    LANGUAGE plpgsql
    AS $_$
declare
  _data record;
begin
  for _data in
    with __corrent as  (
      select
          l.id,
          l.cred,
          l.deb,
          sum( l.cred ) over ( order by l.id ) as scred,
          sum( l.deb ) over ( order by l.id ) as sdeb
        from public.lancamento l
    ) select
          _c.id,
          _c.cred,
          _c.scred,
          _d.id as d_id,
          _d.deb,
          _d.sdeb,
          sum( _d.deb ) over ( partition by _c.id ) as alldeb,
          max( _d.sdeb ) over ( partition by _c.id ) as maxsdeb,
          count( * ) over ( partition by _c.id ) as count,
          rank() over ( partition by _c.id order by _d.id) as rank
        from __corrent _c
          left join __corrent _d on ( _c.deb = 0 and _d.cred = 0  )
            and _d.sdeb-_d.deb < _c.scred
            and _d.sdeb > _c.scred - _c.cred
        where _c.id = coalesce( $1, _c.id )
          and _c.cred > 0 and _c.deb = 0
        order by _c.id, _d.id
  loop
    regula.cred_id := _data.id;
    regula.deb_id := _data.d_id;
    regula.deb := _data.deb;
    regula.regula := _data.deb;
    regula.excedente := _data.maxsdeb - _data.scred;
    regula.faltando := (_data.alldeb - _data.cred) - (_data.maxsdeb - _data.scred);

    -- O primeiro debito em que o credito ira se aplicar
    if _data.rank = 1 then
      regula.regula := regula.regula - regula.faltando;
    end if;

    -- O ultimo debito em que o credito ira se aplicar
    if _data.rank = _data.count then
      regula.regula := regula.regula - regula.excedente;
    end if;

    return next;
  end loop;
end;
$_$;


--
-- TOC entry 571 (class 1255 OID 94092)
-- Name: regula_v2(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.regula_v2(_cred_id integer) RETURNS TABLE(cred_id integer, deb_id integer, deb double precision, regula double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
    with cte__lancamento as (
      select l.*,
--           sum( l.cred ) over ( order by l.id ) as scred,
--           sum( l.deb ) over ( order by l.id ) as sdeb,
          sum( l.cred ) over ( order by l.id ) -
          sum( l.deb ) over ( order by l.id ) as saldo
        from lancamento l
    )
    SELECT
      _cred.id AS cred_id,
      _deb.id AS deb_id,
      _deb.deb,
      LEAST(_cred.cred, _deb.saldo) AS regula
    FROM (
           SELECT id, cred FROM cte__lancamento WHERE id = COALESCE(_cred_id, id) AND cred > 0
         ) _cred
           JOIN (
      SELECT id, deb, saldo FROM cte__lancamento WHERE deb > 0
    ) _deb ON _cred.id >= _deb.id
    ORDER BY _cred.id, _deb.id;
END;
$$;


--
-- TOC entry 572 (class 1255 OID 94098)
-- Name: regula_v3(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.regula_v3(_cred_id integer) RETURNS TABLE(cred_id integer, deb_id integer, deb_value numeric, regula numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
    SELECT
      c.id AS cred_id,
      d.id AS deb_id,
      d.deb,
      LEAST(c.cred, d.saldo) AS regula
    FROM (
           SELECT id, cred FROM public.lancamento WHERE id = COALESCE(_cred_id, id) AND cred > 0
         ) c
           JOIN (
      SELECT id, deb, deb - COALESCE(SUM(deb) OVER (ORDER BY id), 0) AS saldo
      FROM public.lancamento WHERE deb > 0
    ) d ON c.id >= d.id
    ORDER BY c.id, d.id;
END;
$$;


--
-- TOC entry 449 (class 1255 OID 16784)
-- Name: 3x(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report."3x"(report jsonb) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $_$
declare
  /**
    args := {
      row_column: column
      row_order: asc|desc (default asc)
      column_column: column
      column_order asc|desc (default asc)
      aggregation:RENAME
    }
   */
  statement text;
  _columns record;
  _row_column text default report->>'row_column';
  _row_order text default report->>'row_order';
  _column_column text default report->>'column_column';
  _column_order text default report->>'column_order';
  _aggregation text default report->>'aggregation';
  _row_reduce text;
  _column_reduce text;
  _sources record;
  _limit int8 default report->>'limit';
  _offset int8 default report->>'offset';
begin
  report := report - 'limit' - 'offset';

  select * into _columns
    from report.__prepare_column( report );

  raise notice '%', to_jsonb( _columns );

  if _row_column = any( _columns.reduces ) then _row_reduce := _columns.reduces_map->>( _row_column ); end if;
  if _column_column = any( _columns.reduces ) then _column_reduce := _columns.reduces_map->>( _column_column ); end if;

  _row_reduce := coalesce( _row_reduce, _row_column );
  _column_reduce := coalesce( _column_reduce, _column_column );

  raise notice '_row_reduce: %', _row_reduce;
  raise notice '_column_reduce: %', _column_reduce;

  select jsonb_object_agg( c.column_name, jsonb_build_object(
      'type', c.column_type,
      'basetype', c.column_basetype,
      'default', c.column_default,
      'is_array', c.is_array,
      'is_generated', c.is_generated
    )) as maps into _sources
    from report.columns( (report->>'source')::text::regclass ) c;

-- $1 => report
-- $2 => row_column
-- $3 => row_reduce
-- $4 => column_column
-- $5 => column_reduce
-- $6 => aggregation

--language=sql
statement := $sql$
  with __source as (
    select e.data::text::jsonb as data
      from report.engine( $1 ) e( data )
  ), __xxx as (
    select
        _s.data->>$2 as "($rowColumnName)",
        json_object_agg( _s.data ->> $4, (_s.data-> $6) order by (_s.data ->> $5)::"($columnColumnType)" "($columnOrder)" nulls last ) as "($columnColumnName)"
      from __source _s
      group by
        _s.data->>$2,
        _s.data->>$3
      order by (_s.data->>$3)::"($rowColumnType)" "($rowOrder)" nulls last
  ), __xxx_header as (
    select
        distinct _s.data ->> $4 as header_representation,
        ( _s.data ->> $5)::"($columnColumnType)" as header_reduce
      from __source _s
  ), __result as  (
    select json_agg( _xh.header_representation order by _xh.header_reduce "($columnOrder)" nulls last )  as data
      from __xxx_header _xh
    union all
      select to_json( _x )
        from __xxx _x
  ) select data
      from __result
      limit $7
      offset $8

$sql$;

  statement := replace( statement, '"($rowColumnName)"', format( '%I', _row_column ) );
  statement := replace( statement, '"($columnColumnType)"', _sources.maps->( _column_column )->>'type' );
  statement := replace( statement, '"($columnColumnName)"', format( '%I', _column_column ) );
  statement := replace( statement, '"($columnOrder)"', coalesce( _column_order, 'asc' ) );
  statement := replace( statement, '"($rowColumnType)"', _sources.maps->( _row_column )->>'type' );
  statement := replace( statement, '"($rowOrder)"', coalesce( _row_order, 'asc' ) );

  raise notice  '%', statement;

  return query execute statement using
    report,
    _row_column,
    _row_reduce,
    _column_column,
    _column_reduce,
    _aggregation,
    _limit,
    _offset
  ;
end;
$_$;


--
-- TOC entry 453 (class 1255 OID 16785)
-- Name: ____tg_report_format(); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.____tg_report_format() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _source record;
  _repcoll report.vcolumn;
  _report report.report;
begin
  if pg_typeof( new )::text::regclass = 'report.report'::regclass then
    _report := new;
    select * into _source
    from report.source_map( _report.report_source::regclass );
    _report.report_source := _source.source_format;
    return _report;
  elsif pg_typeof( new )::text::regclass = 'report.vcolumn'::regclass then
    _repcoll := new;
    select * into _source
    from report.source_map( _repcoll.source::regclass );
    _repcoll.source := _source.source_format;
    return _repcoll;
  end if;
  return new;
end;
$$;


--
-- TOC entry 450 (class 1255 OID 16786)
-- Name: __formattable(); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__formattable() RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $$
  select array_agg( distinct te.name )
    from report.talias ta
      inner join unnest(( ta.alias|| ta.type) ) te( name ) on true
    where ( ta.alias|| ta.type) && array[ 'date', 'timestamp', 'timestamptz' ]::text[];
$$;


--
-- TOC entry 451 (class 1255 OID 16787)
-- Name: __mask(anyelement, text, text, boolean); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__mask(anyelement, type text, format text, representation boolean DEFAULT false) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
<<func>>
declare
  _format report.mask;
  mouth_group double precision;
  base int;
begin
  representation := coalesce( representation, false );
  select * into _format
    from report.mask rf
    where rf.mask = __mask.format
      and __mask.type = any( rf.type );

  if _format.mask is null then return null; end if;

  -- to_char
  if lower( _format.function ) = 'to_char' then
    return to_char( $1, case
      when representation then _format.representation
      else _format.mask
    end);
  end if;

  if lower( _format.function ) = 'mouth_group' then
    mouth_group := extract( months from $1 ) / ( 12.0 / _format.mask::double precision);
    base := case
      when mouth_group::int < mouth_group then  mouth_group::int+1
      else mouth_group::int
    end;
    return to_char( $1,
      case when representation then format( '%I%I"º" YYYY', _format.representation, base )
           else format( 'YYYY %I%I', _format.representation, base )
      end);
  end if;
end;
$_$;


--
-- TOC entry 452 (class 1255 OID 16788)
-- Name: __mask_reduce(anyelement, text, text); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__mask_reduce(anyelement, type text, format text) RETURNS anyelement
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
<<func>>
declare
  _format report.mask;
  _types record;
  mouth_group double precision;
  base int;
  _month int;
  _year int;
begin
  select * into _format
    from report.mask rf
    where rf.mask = __mask_reduce.format
      and __mask_reduce.type = any( rf.type );

  select * into _types
    from report.talias ta
    where __mask_reduce.type = any( ta.alias )
  ;

  if _format.mask is null then return null; end if;

  -- to_char
  if lower( _format.function ) = 'to_char' then
    case
      when 'date' = any( _types.alias ) then return to_date( to_char( $1, _format.mask ), _format.mask );
      when 'timestamp' = any( _types.alias ) then return to_timestamp( to_char( $1, _format.mask ), _format.mask );
      when 'timestamptz' = any( _types.alias ) then return to_timestamp( to_char( $1, _format.mask ), _format.mask )::timestamptz;
      else return $1;
    end case;
  end if;

  if lower( _format.function ) = 'mouth_group' then
    mouth_group := extract( months from $1 ) / ( 12.0 / _format.mask::double precision);
    base := case
      when mouth_group::int < mouth_group then  mouth_group::int+1
      else mouth_group::int
    end;
    _month := base * ( 12.0 / _format.mask::double precision )-( 12.0 / _format.mask::double precision)+1;
    _year := extract( year from $1 );
    case
      when 'date' = any( _types.alias ) then return make_date( _year, _month, 1 );
      when 'timestamp' = any( _types.alias ) then return make_timestamp( _year, _month, 1, 0, 0, 0 );
      when 'timestamptz' = any( _types.alias ) then return make_timestamptz( _year, _month, 1, 0, 0, 0, to_char( $1, 'tz' ) );
    end case;
  end if;
end;
$_$;


--
-- TOC entry 454 (class 1255 OID 16789)
-- Name: __prepare(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare(report jsonb) RETURNS SETOF text
    LANGUAGE plpgsql IMMUTABLE
    AS $_X$
declare
  /**
    report := {
      source: view|table
      _branch_uid: BRANCH-UID
      windows_function_key: [sum | avg | max | min | count | count::distinct],
      with_reduce?:boolean
      with_column_row_number?:boolean
      orders: [{
        *column: "COLUMN" value para coluna | "RENAME" value para o grupo,
        orientation?: "asc" | "desc" (default "first",
        nulls?: "last" | "first" (default "last" ),
        priority? number-level
      }],

      columns: [{
        column:COLUMN,
        format?: YYYY | YYYY-MM | YYYY-MM-DD | YYYY-MM-DD HH:MI
      }]
      filters: [{
        column: src.COL-NAME,
        opr: =|<|>|<=|>=|like
        mode?: default|right
        value: VALUE-FILTER
      }],
      groups:[{
        column: src.COL-NAME
        func: count|sum|max|min|avg
        rename: NEW-NAME
      }]
    }
   */
  _orders record;
  _columns record;
  _rownumber record;
  _aggregate record;
  _windows record;
  _statement text;
  _where record;
  _source record;
  _formattable record;
begin
  select * into _source from report.source_map( (report->>'source' )::regclass );
  select * into _formattable from report.__formattable() f( types );
  select * into _columns from report.__prepare_column( report );
  select * into _aggregate from report.__prepare_aggregate( report );
  select * into _rownumber from report.__prepare_row_number( report );
  select * into _where from report.__prepare_where( report );
  select * into _windows from report.__prepare_wf( report );
  select * into _orders from report.__prepare_order( report, _columns.selected, _aggregate.selected );

  --language=PostgreSQL
  _statement := $sql$
    with 
    __report_fixe ( "$_*_fixed") as (
      values(1)
    ), __report_engine as (
      select
          '(__$report__columns_expression)'
          '(__$report_aggregate_expression)'
        from '(select * from __$report_source)'
        where _branch_uid = $1
          and '(__$report_where)'
        group by '(__$report_group_by)'
    ), __distinct as (
      select pr.*, '(__$report_row_number_expression)' as "$ROW-NUMBER"
        from __report_engine pr
    ), __windows as (
        select _re.*,
          jsonb_build_object(
            '(__$report_windows_functions)'
          ) as "*_$"
          from __report_fixe _rf
            left join __distinct _re on true
          order by '(__$report_order_by)'
          limit $2
          offset $3
    ) select to_json( _w )
        from __windows _w
  $sql$;


  _statement := replace( _statement, $$'(select * from __$report_source)'$$, _source.source_format );
  if _columns.counts > 0 then
    _statement := replace( _statement, $$'(__$report__columns_expression)'$$, format( '%s', _columns.expression ) );
  else
    _statement := replace( _statement, $$'(__$report__columns_expression)'$$, '' );
  end if;

  if _columns.counts > 0 and _aggregate.counts >0 then
    _statement := replace( _statement, $$'(__$report_aggregate_expression)'$$, format( ', %s', _aggregate.expression ) );
  elsif _aggregate.counts > 0 then
    _statement := replace( _statement, $$'(__$report_aggregate_expression)'$$, format( '%s', _aggregate.expression ) );
  else
    _statement := replace( _statement, $$'(__$report_aggregate_expression)'$$, format( '%s', '' ) );
  end if;


  if _where.counts > 0 then
    _statement := replace( _statement, $$'(__$report_where)'$$, _where.expression );
  else
    _statement := replace( _statement, $$and '(__$report_where)'$$, '' );
  end if;

  if _rownumber.expression is null then
    raise exception 'Row Number Is NUll';
  end if;

  if _rownumber.counts > 0 then
    _statement := replace( _statement, $$'(__$report_row_number_expression)' as "$ROW-NUMBER"$$, _rownumber.expression );
  else
    _statement := replace( _statement, $$, '(__$report_row_number_expression)' as "$ROW-NUMBER"$$, '' );
  end if;

  if _columns.counts > 0 and _aggregate.counts > 0 then
    _statement := replace( _statement, $$'(__$report_group_by)'$$, _columns.groupby_expression );
  else
    _statement := replace( _statement, $$group by '(__$report_group_by)'$$, '' );
  end if;

  if _orders.counts > 0 then
    _statement := replace( _statement, $$'(__$report_order_by)'$$, _orders.expression );
  else
    _statement := replace( _statement, $$order by '(__$report_order_by)'$$, '' );
  end if;

  if _windows.counts > 0 then
    _statement := replace( _statement, $s$'(__$report_windows_functions)'$s$, _windows.expression );
  else
    _statement := replace( _statement, $s$'(__$report_windows_functions)'$s$, '' );
  end if;

  select string_agg( e.line, e'
' ) into _statement
    from regexp_split_to_table( _statement, e'
' ) e( line )
    where length( trim( e.line ) ) > 0
  ;
  _statement := trim( _statement );
  return next _statement;
end;
$_X$;


--
-- TOC entry 455 (class 1255 OID 16790)
-- Name: __prepare_aggregate(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare_aggregate(report jsonb) RETURNS TABLE(counts bigint, expression text, selected jsonb[], exports_expression text, exports_rename text[])
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _source record;
  _aggregate record;
  _selected jsonb[];
begin
  select * into _source from report.source_map( (report->>'source' )::regclass );

  select array_agg( coalesce( rc.element, jsonb_build_object() ) || e.doc ) into _selected
    from jsonb_array_elements( report->'groups' ) with ordinality e( doc )
      left join report.vcolumns( report ) rc( element ) on rc.element->>'column' = e.doc->>'column'
        and rc.element->>'key' = e.doc->>'key'
        and rc.element->>'type' = 'group'
  ;

  with  __group as (
    select
        e.doc->>'column' as group_column,
        e.doc->>'mode' as group_mode,
        e.doc->>'func' as group_func,
        e.doc->>'rename' as group_rename,
        e.doc->>'expression' as group_expression,
        e.doc->>'column_position' as column_position,
        e.doc->>'priority' as group_priority
      from unnest( _selected ) e( doc )
  ), __prepare_group as (
    select
      g.*
      from __group g
      where g.group_func is not null
  ), __prepare_group_by as (
    select
        _sc.*,
        _g.*
      from report.columns( _source.source_class ) _sc
        inner join __prepare_group _g on _sc.column_name = _g.group_column
  ) select
        count( * ) as counts,
        string_agg( agg.group_expression, e',
          ' order by agg.column_position desc nulls last, agg.group_priority ) as expression,
        string_agg( format( '%I', agg.group_rename ), ', ' ) as exports_expression,
        array_agg( agg.group_rename ) as exports_rename

        into _aggregate
      from __prepare_group_by agg
  ;

  __prepare_aggregate.counts := _aggregate.counts;
  __prepare_aggregate.expression := _aggregate.expression;
  __prepare_aggregate.selected := _selected;
  __prepare_aggregate.exports_rename := _aggregate.exports_rename;
  __prepare_aggregate.exports_expression := _aggregate.exports_expression;
  return next;
end;
$$;


--
-- TOC entry 456 (class 1255 OID 16791)
-- Name: __prepare_column(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare_column(report jsonb) RETURNS TABLE(expression text, expression_map jsonb, counts bigint, selected jsonb[], reduces text[], reduces_counts bigint, reduces_map jsonb, reduces_expression text, groupby_expression text, exports text[], exports_reduce text[], exports_representation text[], exports_expression text)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  __selected jsonb[];
  _formattable record;
  _columns record;
  _source record;
begin
  select * into _source from report.source_map( (report->>'source' )::regclass );

  select * into _formattable from report.__formattable() f( types );

  select array_agg( coalesce( rc.element, jsonb_build_object() ) || e.doc || jsonb_build_object(
      '_reduce_name',  report.reduce_name( rc.element->>'column' )
    )) into __selected
    from jsonb_array_elements( report->'columns' ) with ordinality e( doc )
      inner join report.vcolumns( report ) rc( element ) on rc.element->>'column' = e.doc->>'column'
        and rc.element->>'key' = e.doc->>'key'
        and rc.element->>'type' = 'column'
  ;

  -- COLUMNS
  with __representation as (
    select *,
        true as representation,
        false as reduce
       from report.columns( _source.source_class )
    union all
      select *,
          false as representation,
          true as reduce
         from report.columns( _source.source_class )
  ), __columns as (
    select
        e.doc->>'column' as column_name,
        e.doc->>'order' as column_order,
        e.doc->>'mask' as column_mask,
        e.doc->>'format' as column_formattype,
        e.doc->>'_reduce_name' as _reduce_name,
        e.ordinality
      from unnest( __selected ) with ordinality e( doc )
  ), __prepare_columns as (
    select
        _rp.column_name as _original_column_name,
        format( '%I', _rp.column_name ) as column_name,
         format( '%I', _c._reduce_name ) as column_reduce,
        _c._reduce_name,
        _rp.reduce,
        _rp.representation,
        case
          when _rp.reduce then 2
          else 1
        end as ___priority,
        case
          when _rp.column_type = any( _formattable.types ) and _c.column_mask is not null and _rp.reduce then format( 'report.__mask_reduce( %I::%s, %L, %L )',  _rp.column_name, _rp.column_type, column_formattype, _c.column_mask )
          when _rp.column_type = any( _formattable.types ) and _c.column_mask is not null and _rp.representation then format( 'report.__mask( %I::%s, %L, %L, %L )', _rp.column_name, _rp.column_type, column_formattype, _c.column_mask, _rp.representation )
          else format( '%I', _rp.column_name )
        end as expression,
        _c.ordinality
      from __representation _rp
        inner join __columns _c on _rp.column_name = _c.column_name
  ) select
      count( pc.column_name ) as counts,
      string_agg( format( '%s', pc.expression ), e',
          'order by pc.___priority, pc.ordinality ) as columns,
      string_agg( pc.column_reduce, ', '  ) filter ( where pc.reduce ) reduces_expression,
      array_agg( pc._original_column_name ) filter ( where pc.reduce ) reduces,
      jsonb_object_agg( pc._original_column_name, pc._reduce_name  ) filter ( where pc.reduce ) reduces_map,

      count( * )  filter ( where pc.reduce ) reduces_counts,
      string_agg( format( '%s as %s', pc.expression,
        case
          when pc.reduce then pc.column_reduce
          else pc.column_name
        end ), e',
          ' order by pc.___priority, pc.ordinality ) as expression,
      jsonb_object_agg( case when pc.reduce then pc._reduce_name else pc._original_column_name end, jsonb_build_object(
        'expression', pc.expression,
        'reduce', pc.reduce,
        'representation', pc.representation,
        'reduce_name', pc._reduce_name,
        'column_name', pc._original_column_name
      )) as expression_map,
      array_agg( case when pc.reduce then pc._reduce_name else pc._original_column_name end ) as exports,
      array_agg( pc._reduce_name ) filter ( where pc.reduce )as exports_reduce,
      array_agg( pc._original_column_name ) filter ( where pc.representation )as exports_representation,
      string_agg( case when pc.reduce then pc.column_reduce else pc.column_name end, ', ') as exports_expresssion,
      string_agg( format( '%s', pc.expression ), e',
          ' order by pc.___priority, pc.ordinality ) filter ( where true in ( pc.reduce, pc.representation) ) as groupby_expression
      into _columns
    from __prepare_columns pc
  ;

  __prepare_column.selected := __selected;
  __prepare_column.counts := _columns.counts;
  __prepare_column.expression := _columns.expression;
  __prepare_column.expression_map := _columns.expression_map;
  __prepare_column.reduces := _columns.reduces;
  __prepare_column.reduces_map := _columns.reduces_map;
  __prepare_column.reduces_counts := _columns.reduces_counts;
  __prepare_column.reduces_expression := _columns.reduces_expression;
  __prepare_column.groupby_expression := _columns.groupby_expression;
  __prepare_column.exports := _columns.exports;
  __prepare_column.exports_reduce := _columns.exports_reduce;
  __prepare_column.exports_representation := _columns.exports_representation;
  __prepare_column.exports_expression := _columns.exports_expresssion;
  return next;
end;
$$;


--
-- TOC entry 457 (class 1255 OID 16792)
-- Name: __prepare_order(jsonb, jsonb[], jsonb[]); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare_order(report jsonb, columns jsonb[], aggregates jsonb[]) RETURNS TABLE(counts bigint, expression text, selected jsonb[])
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _orders record;
  _source record;
  _selected jsonb[];
  _formattable record;
begin
  select * into _source from report.source_map( (report->>'source' )::regclass );
  select * into _formattable from report.__formattable() f( types );

  with __orders as (
    select
      e.element,
      ( e.element->>'priority' )::int as priority,
      e.ordinality as ordinality
    from jsonb_array_elements( report->'orders' ) with ordinality e( element )
  ) select array_agg( e.element order by e.priority desc nulls last, e.ordinality ) as orders into _selected
      from __orders e
  ;

  if( coalesce( array_length( _selected, 1 ), 0 ) ) = 0 then
    with __columns as (
    select
        e.element->>'column' as "column",
        e.element->>'rename' as rename,
        e.element->>'type' as "type",
        e.ordinality,
        -- Prioridade igual a ordem reverva, quanto maoir for a ordem posicional menor a prioridade
        e.ordinality * -1 as priority
      from unnest( columns || aggregates ) with ordinality e ( element )
    ), __orders as (
      select
          case
            when cc.type = 'group' then cc.rename
            when cc.type = 'column' then cc.column
          end as "column",
          'asc' as "orientation",
          'last' as "nulls",
          cc.ordinality,
          cc.priority
        from __columns cc
        order by cc.ordinality
    ) select array_agg( to_jsonb( o ) order by o.priority desc nulls last, o.ordinality) as orders into _selected
        from __orders o
        where o."column" is not null
    ;
  end if;

  with __orders as (
    select
        case
          when ( sc."column"->>'mask' ) is not null and c.column_type = any( _formattable.types ) then format( '\:%s', c.column_name )
          else c.column_name
        end as "column",
        (o."order"->>'priority')::int as "priority",
        coalesce( lib.str_normalize( o."order"->>'orientation' ), 'asc' ) as "orientation",
        coalesce( lib.str_normalize( o."order"->>'nulls' ), 'last' ) as "nulls",
        o.ordinality
      from report.columns( _source.source_class ) c
        inner join unnest( _selected ) with ordinality o( "order" ) on c.column_name = o."order"->>'column'
        inner join unnest( columns ) sc( "column" ) on o."order"->>'column' = sc."column"->>'column' and sc."column"->>'column' = c.column_name
  ) select
        string_agg( format( '%I %s nulls %s', o."column", o.orientation, o.nulls ), e',
            '
          order by o.priority desc nulls last, o.ordinality
        ) as expression,
        count( * ) as counts
        into _orders
      from __orders o
      where o.orientation in ( 'asc', 'desc')
        and o.nulls in ( 'last', 'first' )
  ;

  __prepare_order.counts := _orders.counts;
  __prepare_order.expression := _orders.expression;
  __prepare_order.selected := _selected;
  return next;
end;
$$;


--
-- TOC entry 458 (class 1255 OID 16793)
-- Name: __prepare_row_number(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare_row_number(report jsonb) RETURNS TABLE(counts bigint, expression text, exports_expression text, exports_rownumber text[])
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _columns record;
  _aggregate record;
  _rn record;
begin
  select * into _aggregate
    from report.__prepare_aggregate( report );

  select * into _columns
    from report.__prepare_column( report );

  with __exports as (
    select
        e.export,
        report.__rownumber_of( e.export ) as row_numbername,
        format( 'row_number() over ( partition by %I )', e.export ) as row_expression
      from unnest( _columns.exports_reduce || _aggregate.exports_rename ) e( export )
  ) select
        count( * ) as counts,
        string_agg( format( '%s as %I', row_expression, row_numbername), e',
            ' ) as expression,
        array_agg( row_numbername ) as exports_rownumber,
        string_agg( format('%I', row_numbername ), ', ') as exports_expression
        into _rn
      from __exports;

  __prepare_row_number.expression := _rn.expression;
  __prepare_row_number.counts := _rn.counts;
  __prepare_row_number.exports_rownumber := _rn.exports_rownumber;
  __prepare_row_number.exports_expression := _rn.exports_expression;
  return next;
end;
$$;


--
-- TOC entry 459 (class 1255 OID 16794)
-- Name: __prepare_wf(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare_wf(report jsonb) RETURNS TABLE(counts bigint, expression text)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _columns record;
  _aggregates record;
  _wfunction record;
  _wf_keys text[] default array( select e.text from jsonb_array_elements_text( report->'windows_function_key' )e( text));
begin

  if coalesce( array_length( _wf_keys, 1 ), 0 ) = 0  then
    _wf_keys := array [ 'sum' ]::text[];
  end if;
  select * into _columns from report.__prepare_column( report );
  select * into _aggregates from report.__prepare_aggregate( report );

  -- WINDOWS FUNCTIONS
  with  __columns as (
      select
        e.element->>'format' as format,
        coalesce( e.element->>'rename', e.element->>'_reduce_name' ) as "rename"
      from unnest( _columns.selected || _aggregates.selected || jsonb_build_object(
        'rename', '*',
        'format', '*'
      )) e( element )
  ), __expression as (
      select
        format( '%s:%s', _c.rename, _wf.key ) as name,
        format( _wf.over, case when _c.rename = '*' then '*' else format( '%I', _c.rename ) end, report.__rownumber_of( _c.rename ) ) as expression
        from __columns _c
          inner join report.agg _wf on _c.format = any( _wf.types )
            and true in ( _wf.key = any( _wf_keys ), _c.rename = '*' )
            and _wf.over is not null
  )  select
        string_agg( format( '%L, %s', _exp.name, _exp.expression ), e',
            ' ) as expression,
        count( * ) as counts
        into _wfunction
      from __expression _exp
  ;

  __prepare_wf.counts := _wfunction.counts;
  __prepare_wf.expression := _wfunction.expression;
  return next ;
end;
$$;


--
-- TOC entry 460 (class 1255 OID 16795)
-- Name: __prepare_where(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__prepare_where(report jsonb) RETURNS TABLE(counts bigint, expression text, selected jsonb[])
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
  _source record;
  _where record;
  _selected jsonb[];
begin
  select * into _source from report.source_map( (report->>'source' )::regclass );

  select array_agg( coalesce( rc.element, jsonb_build_object() ) || e.doc ) into _selected
    from jsonb_array_elements( report->'filters' ) with ordinality e( doc )
      left join report.vcolumns( report ) rc( element ) on rc.element->>'column' = e.doc->>'column'
        and rc.element->>'key' = e.doc->>'key'
        and rc.element->>'type' = 'filter'
  ;


  -- FILTERS
  with __filters as (
    select
        e.doc->>'column' as filter_column,
        coalesce( e.doc->>'opr', '=' ) as filter_opr,
        coalesce( e.doc->>'mode', 'default' ) as filter_oprmode,
        e.doc->>'value' as filter_value,
        e.doc->>'key' as filter_key
      from unnest( _selected ) e( doc )
  ), __prepare_filter as (
    select
        _f.filter_column,
        _f.filter_opr,
        _f.filter_oprmode,
        _f.filter_key,
        case
          when lower( _f.filter_opr ) = 'like' and _f.filter_oprmode = 'default' then format( '%s%s%s', '%', lower( _f.filter_value ), '%' )
          when lower( _f.filter_opr ) = 'like' and _f.filter_oprmode = 'right' then format( '%s%s', lower( _f.filter_value ), '%')
          else filter_value
        end as filter_value
      from __filters _f
  ), __prepare_where as (
    select
        case
          when _sc.is_array then format( 'any( %I )', _sc.column_name)
          when _f.filter_opr = 'like' then format( 'lower( %I )::text', _sc.column_name )
          else format( '%I', _sc.column_name )
        end as column_exp,

        case
          when _sc.is_array then format( '(%L)::%s', _f.filter_value, _sc.column_basetype )
          when _f.filter_opr = 'like' then format( '(%L)::text', _f.filter_value )
          else format( '(%L)::%s', _f.filter_value, _sc.column_type )
        end as args,
        _sc.*,
        _f.*

      from report.columns( _source.source_class ) _sc
        inner join __prepare_filter _f on _sc.column_name = _f.filter_column
  ), __group_where as (
    select
        _pr.filter_key,
        string_agg(
            case
              when  _pr.is_array then format( '%s %s %s', args, filter_opr, column_exp )
              else format( '%s %s %s', column_exp, filter_opr, args )
              end, e',
            '
          ) as expression
      from __prepare_where _pr
      group by _pr.filter_key
  ) select
        count( * ) as counts,
        string_agg(
          format( e'true in ( 
%s )', _pr.expression )
          , e'
          and '

        ) as expression
        into _where
      from __group_where _pr
  ;

  __prepare_where.selected := _selected;
  __prepare_where.expression := _where.expression;
  __prepare_where.counts := _where.counts;
  return next;
end;
$$;


--
-- TOC entry 461 (class 1255 OID 16796)
-- Name: __rownumber_of(text); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__rownumber_of(text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$ select format('\:$( %s ):#ROW_NUMBER', $1 ) $_$;


--
-- TOC entry 523 (class 1255 OID 16797)
-- Name: __template_of(jsonb, jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.__template_of(ref jsonb, colconfigs jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $_$
declare
  refname text;
  args jsonb;
  _name text;
  _type text;
begin
  if ref is null then return null; end if;
  if jsonb_typeof( ref ) = 'object' then return ref; end if;
  if jsonb_typeof( ref ) = 'string' then refname = ref->>0;
  elseif jsonb_typeof( ref ) = 'array' then
    refname := ref->>0;
    args := ref->1;
  end if;

  if args is not null and jsonb_typeof( args ) != 'object' then raise exception 'args is not object, %', args ; end if;
  _type := (regexp_split_to_array( refname, '\.' ))[1];
  _name := (
    select string_agg( u.text, '.' )
    from  unnest( ( regexp_split_to_array( refname, '\.' ))[2:] ) u( text)
  );

--  raise exception 'type: %, _name: %, LENGTH: %', _type, _name, array_length (regexp_split_to_array( refname, '\.' ), 1);

  if _type is null or _name is null or array_length(regexp_split_to_array( refname, '\.' ), 1)  < 2 then
    raise exception 'Type or name indeterminated %: ', ref;
  end if;

  declare
    _template record;
    _i record;
    _j record;
    _obj jsonb default jsonb_build_object();
    _conversion text;
    _value jsonb;
  begin
    select * into _template
    from report.template t
    where type = _type
      and t.name = _name;

    if _template.name is null then raise exception 'Template not found with ref: % | type: % | name: %', ref, _type, _name; end if;
    for _i in
      select
        e.key,
        e.value,
        jsonb_typeof( e.value ) as type,
        case
          when jsonb_typeof( e.value ) in ( 'object', 'array' ) then e.value::text
          else e.value->>0
          end as text
      from jsonb_each( _template.configs ) e
      loop
        if _i.type in ( 'string', 'boolean', 'null', 'number' ) then _value := _i.value;
        elsif _i.type = 'object' and (_i.value->>'$template')::boolean then
          _conversion := _i.value->>'$structure';
          if _conversion is null then raise exception 'Null AQUI 452739'; end if;
          for _j in
            select
              e.key,
              e.value,
              jsonb_typeof( e.value ) as type,
              case
                when jsonb_typeof( e.value ) in ( 'object', 'array' ) then e.value::text
                else e.value->>0
                end as text
            from jsonb_each( colConfigs ) e
            loop
              _conversion := replace( _conversion, format( '${%s}', _j.key ), coalesce( _j.text, '' ) );
              if _conversion is null then raise exception 'Null AQUI 77736'; end if;
            end loop;

          for _j in
            select
              e.key,
              e.value,
              jsonb_typeof( e.value ) as type,
              case
                when jsonb_typeof( e.value ) in ( 'object', 'array' ) then e.value::text
                else e.value->>0
                end as text
            from jsonb_each( args ) e
            loop
              _conversion := replace( _conversion, format( '${args.%s}', _j.key ), coalesce( _j.text, '' ) );
              if _conversion is null then raise exception 'Null AQUI kjskdhs'; end if;
            end loop;

          _conversion := coalesce( _conversion, _i.value->>'$default', _i.value->>'$defaults' );
          if _conversion is null then raise exception '#C001 Conversion is null template: %; key: %; value %; args <= %', _template.name , _j.key, _j.value, args; end if;
          if _conversion = _i.value->>'$structure' then _conversion := coalesce(  _i.value->>'$default', _i.value->>'$defaults' ); end if;
          if _conversion is null then raise exception '#C002 Conversion is null template: %; key: %; value %; args <= %', _template.name , _j.key, _j.value, args;  end if;

          if _i.value->>'$type' in ( 'string', 'text', 'varchar', 'character varying' ) then
            _value := to_jsonb( _conversion );
          elseif _i.value->>'$type' in ( 'number', 'numeric', 'int', 'integer', 'double', 'double precision' ) then
            _value := to_jsonb( _conversion::numeric );

          elseif _i.value->>'$type' in ( 'bool', 'boolean' ) then
            _value := to_jsonb( _conversion::boolean );
          else
            _value := to_jsonb( _conversion );
          end if;
        else _value := _i.value;
        end if;

        _obj := _obj || jsonb_build_object(
          _i.key,
          _value
          );

        if _obj is null then raise exception 'Object is null in {%:%} args: % base: %', _i.key, _i.value, args, colConfigs; end if;
        if _value is null then raise exception 'Object.value is null in {%:%} args: % base: %', _i.key, _i.value, args, colConfigs; end if;
        if jsonb_typeof(_value) = 'null' then raise exception 'Type Object.value is null in {%:%} args: % base: %', _i.key, _i.value, args, colConfigs; end if;
      end loop;
    return _obj;
  end;
end
$_$;


--
-- TOC entry 567 (class 1255 OID 16798)
-- Name: columns(regclass); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.columns(regclass) RETURNS TABLE(column_name text, column_type text, column_basetype text, column_default text, is_array boolean, is_generated boolean)
    LANGUAGE sql STRICT
    AS $_$
select
    col.column_name::text,
    format_type( pt.oid, atttypmod )::text column_type,
    case
      when col.data_type = 'ARRAY' then format_type( pt.typelem, atttypmod )
      else format_type( pt.oid, atttypmod )
    end as column_basetype,
    col.column_default::text,
    col.data_type = 'ARRAY' as is_array,
    col.is_generated = 'ALWAYS' as is_generated
  from information_schema.columns col
         inner join report.source_map( $1 ) c on c.source_name = col.table_name
    and col.table_schema::regnamespace = c.source_schema::regnamespace
         inner join pg_attribute att on col.column_name = att.attname
    and att.attrelid = format( '%s.%s', col.table_schema, col.table_name )::regclass::oid
         inner join pg_type pt on att.atttypid = pt.oid
  where format('%s.%s', c.source_schema, c.source_name)::regclass = $1
$_$;


--
-- TOC entry 551 (class 1255 OID 16799)
-- Name: configs(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.configs(args jsonb) RETURNS SETOF jsonb
    LANGUAGE sql
    AS $$
with __report as (
      select
        r.*,
        jsonb_agg( conf.doc  ) as configs
      from report.report r
        inner join report.vcolumns( jsonb_build_object('source', r.report_source ) ) conf ( doc ) on true
      where r.report_active
      group by r.report_source
    ) select to_jsonb( _r )
        from __report _r
        order by _r.report_priority desc nulls last,
          _r.report_name nulls last
$$;


--
-- TOC entry 462 (class 1255 OID 16800)
-- Name: engine(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.engine(report jsonb) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare
  /**
    report := {
      _branch_uid: BRANCH
      limit?: int
      offset?: int
      source: view|table
      columns: [ COL1, COL2, COL3 ]
      filters: [{
        column: src.COL-NAME,
        opr: =|<|>|<=|>=|like
        mode?: default|right
        value: VALUE-FILTER
      }],
      groups:[{
        column: src.COL-NAME
        func: count|sum|max|min|avg
        rename: NEW-NAME
      }]
    }
   */
  _limit int8 default report->>'limit';
  _offset int8 default report->>'offset';
  ___branch uuid default report->>'_branch_uid';
  _next record;
begin
  for _next in select * from report.__prepare( report ) n( statement ) loop
      raise notice 'REPORT %', report;
      raise notice e'REPORT:STATEMENT 
%', _next.statement;
      return query execute _next.statement using ___branch, _limit, _offset;
  end loop;
end;
$$;


--
-- TOC entry 544 (class 1255 OID 152295)
-- Name: eval(text, anyelement); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.eval(expression text, args anyelement) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
declare
  result text;
  statement text;
begin
  statement := format( 'select to_jsonb((%s))', expression );
  raise notice 'eval: %', statement;
  execute statement using args into result;
  return result;
end
$$;


--
-- TOC entry 578 (class 1255 OID 126991)
-- Name: funct_load_report_parametrized(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.funct_load_report_parametrized(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**doc
    args := {
      _branch:text
      _user_id: text
      _workspace: text,
      _grants: text
    }
   doc*/
    _branch text default args->>'_branch';
    _user_id text default args->>'_user_id';
    _workspace text default args->>'_workspace';
    _grants text default args->>'_grants';
begin
  return query 
    with __parametrized_report as (
      select *
        from report.parametrized p
        where p._branch_uid = _branch
          and _workspace = any ( p.parametrized_grants )
          and ( _grants is null or _grants = any ( p.parametrized_grants ) )  
    )  select to_jsonb( _pr )
          from __parametrized_report _pr;
end;
$$;


--
-- TOC entry 504 (class 1255 OID 127207)
-- Name: funct_load_report_parametrized_filter(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.funct_load_report_parametrized_filter(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**doc
    args := {
      _branch:text
      _user_id: text
      _workspace: text
      _parametrized_uid
    }
   doc*/
  _branch text default args->>'_branch';
  _user_id text default args->>'_user_id';
  _workspace text default args->>'_workspace';
  _parametrized_uid uuid default args->>'_parametrized_uid';

  _filter record;
  _const libdom.constant;
  _is_date boolean;
  _is_timestamp boolean;
  _use_value text;
begin
  _const := libdom.constant();
  for _filter in 
    select *
      from report.filter f
      where f._branch_uid = _branch
        and f.filter_parametrized_uid = _parametrized_uid
  loop
    _use_value := null;
      _is_date := _filter.filter_type::regtype in (
        'date'::regtype
      );
    
      _is_timestamp := _filter.filter_type::regtype in (
        'timestamp'::regtype,
        'timestamptz'::regtype
      );
      
      if (_is_date or _is_timestamp) and  _filter.filter_valuemode = _const.report_filter_filter_valuemode_daterelative  then
        _use_value := _filter.filter_basevalue::timestamptz + (_filter.filter_increment)::interval;
      elsif ( _is_date or _is_timestamp ) and _filter.filter_valuemode = _const.report_filter_filter_valuemode_dateprocess then
        _use_value := now();
      elsif _filter.filter_valuemode = _const.report_filter_filter_valuemode_samevalue then 
        _use_value := _filter.filter_basevalue;
      end if;
    
      if _use_value is not null and _is_date then 
          _use_value := _use_value::date;
      end if;
    
      return next to_jsonb( _filter )|| jsonb_build_object(
        'filter_value', _use_value
      );
    
  end loop;
end;
$$;


--
-- TOC entry 445 (class 1255 OID 16802)
-- Name: reduce_name(text); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.reduce_name(text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
  select format( '\:%s', $1 )
$_$;


--
-- TOC entry 584 (class 1255 OID 123551)
-- Name: sets_parametrized_report(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.sets_parametrized_report(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
  declare
    /**doc
      args := {
        _user_id character varying not null,
        _espaco_auth character varying not null,
        _branch  character varying not null

        parametrized_uid uuid primary key not null default gen_random_uuid(),
        parametrized_name character varying not null,
        parametrized_source character varying not null,
        parametrized_columns jsonb not null default jsonb_build_array(),
        parametrized_groups jsonb not null default jsonb_build_array(),
        parametrized_props jsonb not null default jsonb_build_object(),
        parametrized_grants character varying[] not null,

        filters:[{
          filter_uid uuid not null primary key default gen_random_uuid(),
          filter_name character varying not null,
          filter_props jsonb not null default jsonb_build_object(),
          filter_require boolean not null default false,
          filter_column character varying not null,
          filter_type character varying not null,
          filter_opr character varying not null,
          filter_basevalue character varying default null,
          filter_valuemode int not null default libdom.get( 'report_filter_filter_valuemode_raw' )::int2,
          filter_increment character varying default null,
          filter_espaco_destino character varying[] not null
        }]
      }
     doc*/
    _filters_id uuid[] default array( select (e.doc->>'filter_uid')::uuid from jsonb_array_elements( args->'filters' ) e( doc ));
    _parametrized report.parametrized;
    _user_id character varying default args->>'_user_id';
    _branch character varying default args->>'_branch';
    _espaco_auth character varying default args->>'_espaco_auth';
    _const libdom.constant;
    _filter report.filter;
  begin
    _parametrized := jsonb_populate_record( _parametrized, args );
    _const := libdom.constant();
    
    -- Garantir que o nome do retatorio não se duplique
    if _parametrized.parametrized_uid is null and exists(
      select *
        from report.parametrized 
        where trim( lower( parametrized_name ) ) = lower( trim( _parametrized.parametrized_name ) )
          and _branch_uid = _branch
    ) then 
      return next jsonb_build_object(
        'result', false,
        'message', 'Já existe uma relatorio parametizado com o nome'
      );
      return;
    end if;
    
    if _parametrized.parametrized_uid is null then
      _parametrized.parametrized_user_id := _user_id;
      _parametrized._branch_uid := _branch;
      _parametrized.parametrized_espaco_auth := _espaco_auth;
    else
      _parametrized.parametrized_user_update := _user_id;
      _parametrized.parametrized_update := clock_timestamp();
    end if;
    
    if _user_id != all( _parametrized.parametrized_grants ) then 
        _parametrized.parametrized_grants := _parametrized.parametrized_grants || _user_id;
    end if;
    if _espaco_auth != all( _parametrized.parametrized_grants ) then 
        _parametrized.parametrized_grants := _parametrized.parametrized_grants || _espaco_auth;
    end if;

    select ( "returning" ).* into _parametrized
      from lib.sets( _parametrized )
    ;

    return next jsonb_build_object(
      'result', true
    )||jsonb_build_object( 'type', 'result');

    return next to_jsonb( _parametrized )
      ||jsonb_build_object( 'type', 'report.parametrized');


    update report.filter
      set filter_state = _const.report_filter_state_active,
          filter_update  = clock_timestamp()
      where filter_parametrized_uid = _parametrized.parametrized_uid
        and filter_state = _const.report_filter_state_active
        and filter_uid != all ( _filters_id )
    ;


    for _filter in
      select f.*
        from jsonb_array_elements( args->'filters' ) e( doc )
          inner join jsonb_populate_record( null::report.filter, e.doc ) f on true
    loop
      if _filter.filter_uid is null then
        _filter.filter_user_id := _user_id;
        _filter._branch_uid := _branch;
        _filter.filter_espaco_auth := _user_id;
        _filter.filter_parametrized_uid := _parametrized.parametrized_uid;
      else
        _filter.filter_user_update := _user_id;
        _filter.filter_update := clock_timestamp();
      end if;

      if _user_id != all( _filter.filter_grants ) then
          _filter.filter_grants := _filter.filter_grants || _user_id;
      end if;
      if _espaco_auth != all( _filter.filter_grants ) then
          _filter.filter_grants := _filter.filter_grants || _espaco_auth;
      end if;
      
      if _filter.filter_type::regtype in ( 
        'date'::regtype,
        'timestamp'::regtype,
        'timestamptz'::regtype
      ) and _filter.filter_valuemode = _const.report_filter_filter_valuemode_daterelative then
        _filter.filter_increment := clock_timestamp() - ( _filter.filter_basevalue::timestamptz );
      end if;
      
      select ("returning").* into _filter
        from lib.sets( _filter )
      ;
      return next to_jsonb( _filter )
          ||jsonb_build_object( 'type', 'filter');
    end loop;
    
  end
$$;


--
-- TOC entry 507 (class 1255 OID 16803)
-- Name: source_filter(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.source_filter(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    _source text default args->>'source';
    _user uuid default args->>'user';
    _space uuid default args->>'space';
    _branch uuid default args->>'branch';
    _const map.constant;
  begin
    _const := map.constant();

    if _source = 'tweeks.posto' then
      return query
        with __posto as (
          select
              s.posto_id as id,
              s.posto_designacao as label
            from tweeks.posto s
            where s._branch_uid = _branch
        ) select to_jsonb( _p )
          from __posto _p;
    end if;

    if _source = 'auth.colaborador' then
      return query
        with __posto as (
          select
            s.colaborador_id as id,
            s.colaborador_nome as label
          from auth.colaborador s
          where s._branch_uid = _branch
        ) select to_jsonb( _p )
        from __posto _p;
    end if;

    if _source = 'tweeks.espaco' then
      return query
        with __posto as (
          select
            s.espaco_id as id,
            s.espaco_nome as label
          from tweeks.espaco s
          where s.espaco_branch_uid = _branch
        ) select to_jsonb( _p )
        from __posto _p;
    end if;

    if _source = 'geoinfo.currency' then
      return query
        with __posto as (
          select
            s.currency_id as id,
            s.currency_code as label
          from geoinfo.currency s
          where currency_code in ( 'STN', 'EUR', 'USD' )
        ) select to_jsonb( _p )
        from __posto _p;
    end if;

    if _source = 'tweeks.artigo' then
      return query
        with __posto as (
          select
            s.artigo_id as id,
            s.artigo_nome as label
          from tweeks.artigo s
          where s._branch_uid = _branch
          order by s.artigo_nome
        ) select to_jsonb( _p )
        from __posto _p;
    end if;
    
    if _source = 'boolean|Y/N' then
      return query
        with __yes_no ( id, label ) as (
          values ( true, 'SIM' )
          union all values ( false, 'NÃO')
        ) select to_jsonb( _p )
        from __yes_no _p;
    end if;

    if _source = 'boolean|ON/OFF' then
      return query
        with __yes_no ( id, label ) as (
          values ( true, 'ATIVO' )
          union all values ( false, 'DESATIVO')
        ) select to_jsonb( _p )
        from __yes_no _p;
    end if;

    if _source = 'STATUS' then
      return query
        with __yes_no ( id, label ) as (
          values ( 0, 'DESATIVO' )
          union all values ( 1, 'ATIVO' )
          union all values ( 2, 'PENDENTE' )
          union all values ( -1, 'ANULADO' )
        ) select to_jsonb( _p )
        from __yes_no _p;
    end if;

    if _source = 'tweeks.toperacao' then
      return query
        with __posto as (
          select
            s.toperacao_id as id,
            s.toperacao_designacao as label
          from tweeks.toperacao s
        ) select to_jsonb( _p )
        from __posto _p;
    end if;


    if _source = 'tweeks.tgroup' then
      return query
        with __tgroup as (
          select
            s.tgrupo_id as id,
            s.tgrupo_desc as label
          from tweeks.tgrupo s
        ) select to_jsonb( _p )
        from __tgroup _p;
    end if;

    if _source = 'tweeks.tpaga' then
      return query
        with __posto as (
          select
            s.tpaga_id as id,
            s.tpaga_designacao as label
          from tweeks.tpaga s
        ) select to_jsonb( _p )
        from __posto _p;
    end if;

    if _source = 'tweeks.cliente' then
      return query
        with __posto as (
          select
            s.cliente_id as id,
            s.cliente_titular as label
          from tweeks.cliente s
          where s._branch_uid = _branch
        ) select to_jsonb( _p )
        from __posto _p;
    end if;

    if _source = 'tweeks.fornecedor' then
      return query
        with __posto as (
          select
            s.fornecedor_id as id,
            s.fornecedor_nome as label
          from tweeks.fornecedor s
          where s._branch_uid = _branch
        ) select to_jsonb( _p )
        from __posto _p;
    end if;

    if _source = 'tweeks.tipoimposto' then
      return query
        with __source as (
          select
            s.tipoimposto_id as id,
            s.tipoimposto_codigo as label
          from tweeks.tipoimposto s
          where s._branch_uid = _branch
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.serie' then
      return query
        with __source as (
          select
            s.serie_id as id,
            format( '%s (%s)', ts.tserie_desc,  s.serie_numero) as label
          from tweeks.serie s
            inner join tweeks.tserie ts on s.serie_tserie_id = ts.tserie_id
          where s._branch_uid = _branch
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.tserie' then
      return query
        with __source as (
          select
            s.tserie_id as id,
            s.tserie_desc as label
          from tweeks.tserie s
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.tserie::venda' then
      return query
        with __source as (
          select
            s.tserie_id as id,
            s.tserie_desc as label
          from tweeks.tserie s
          where tserie_id in (
            _const.maguita_tserie_fatura,
            _const.maguita_tserie_faturarecibo
          )
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.caixa::estado' then
      return query
        with __source( id, label ) as (
          values ( _const.maguita_caixa_estado_ativo, 'ABERTA' )
          union all values ( _const.maguita_caixa_estado_fechado, 'FECHADA' )
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.lancamento::mode' then
      return query
        with __source( id, label ) as (
          values ( _const.maguita_lancamento_mode_automatic, 'AUTOMATICO' )
          union all values ( _const.maguita_lancamento_mode_manual, 'MANUAL' )
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.tlancamento' then
      return query
        with __source( id, label ) as (
          select tlancamento_id, tlancamento_desc
            from tweeks.tlancamento
        ) select to_jsonb( _s )
        from __source _s;
    end if;

    if _source = 'tweeks.tmovimento' then
      return query
        with __source( id, label ) as (
          select tmovimento_multiplo, tmovimento_designacao
            from tweeks.tmovimento
        ) select to_jsonb( _s )
        from __source _s;
    end if;
    
    if _source = 'tweeks.classe' then
      return query
        with __source( id, label ) as (
          select classe_id, classe_nome
            from tweeks.classe
        ) select to_jsonb( _s )
        from __source _s
        order by _s.label
      ;
    end if;
    
    if _source = 'tweeks.caixa' then
      return query 
        with __caixa as (
            select
              caixa_id as id,
              to_char( cx.caixa_dataatualizacao, 'YYYY-MM-DD HH24:MI') fecho,
              coalesce( cx.caixa_dataatualizacao, cx.caixa_dataregistro ) as date,
              p.posto_designacao,
              cx.caixa_estado,
              max(coalesce( cx.caixa_dataatualizacao, cx.caixa_dataregistro )) filter ( where cx.caixa_estado = (map.constant()).maguita_caixa_estado_fechado ) over ( partition by cx.caixa_posto_id ) last
              from tweeks.caixa cx
                inner join tweeks.posto p on cx.caixa_posto_id = p.posto_id
              where cx._branch_uid = _branch
              order by cx.caixa_dataatualizacao desc nulls first, cx.caixa_dataregistro desc
          ), __source( id, label ) as (
             select
                cx.id,
                format( '%s %s %s', cx.posto_designacao, cx.fecho,
                  case
                    when cx.caixa_estado = (map.constant()).maguita_caixa_estado_ativo then '(aberta)'
                    when cx.date = cx.last then '(ultima fechada)'
                  end
                ) as label
              from __caixa cx
          ) select to_jsonb( _s )
        from __source _s
      ;
    end if;
  end;
$$;


--
-- TOC entry 566 (class 1255 OID 16804)
-- Name: source_map(regclass); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.source_map(regclass) RETURNS TABLE(source_name character varying, source_schema character varying, source_class regclass, source_format character varying, type text)
    LANGUAGE sql
    AS $_$
with __class as (
  select
         pc.tablename::text,
         pc.schemaname::text,
         format( '%s.%s', pc.schemaname::regnamespace::text, pc.tablename )::regclass,
         format( '%s.%s', pc.schemaname::regnamespace::text, pc.tablename ),
         'table'
  from pg_tables pc
  where (format( '%s.%s', pc.schemaname::regnamespace::text, pc.tablename )::regclass = $1)
  union all
  select pv.viewname::text,
         pv.schemaname::text,
         format( '%s.%s', pv.schemaname::regnamespace::text, pv.viewname )::regclass,
         format( '%s.%s', pv.schemaname::regnamespace::text, pv.viewname ),
         'view'
  from pg_views pv
  where (format( '%s.%s', pv.schemaname::regnamespace::text, pv.viewname )::regclass = $1)
) select *
from __class
$_$;


--
-- TOC entry 545 (class 1255 OID 152303)
-- Name: sync(regclass, text, integer, boolean); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.sync(regclass, name text DEFAULT NULL::text, priority integer DEFAULT NULL::integer, active boolean DEFAULT true) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $_$
declare
  _rec record;
  _report report.report;
  _source record;
begin
  select * into _source
  from report.source_map( $1 );

  active := coalesce( active, true );

  with __columns as (
    select
      col.column_name,
      format_type( pt.oid, atttypmod ) column_type,
      col.data_type = 'ARRAY' as is_array,
      col.column_default,
      col.is_generated = 'ALWAYS' as is_generated
    from information_schema.columns col
           inner join report.source_map( _source.source_class ) c on c.source_name = col.table_name
      and col.table_schema::regnamespace = c.source_schema::regnamespace
           inner join pg_attribute att on col.column_name = att.attname
      and att.attrelid = format( '%s.%s', col.table_schema, col.table_name )::regclass::oid
           inner join pg_type pt on att.atttypid = pt.oid
    where format('%s.%s', c.source_schema, c.source_name)::regclass = _source.source_class
  )

  select array_agg( to_jsonb( c ) ) as configs,
         array_agg(c.column_name ) as columns
  into _rec
  from __columns c
  ;

  select * into _report
  from report.report r
  where r.report_source = cluster.__format( $1 )
  ;
  _report.report_name := coalesce( name, _report.report_name, cluster.__format( $1 ) );
  _report.report_source := _source.source_format;
  _report.report_columns := _rec.columns;
  _report.report_priority := priority;
  _report.report_active := active;

  select  ("returning").* into _report
  from lib.sets( _report );

  return next to_json( _report );


  delete from report.vcolumn r
    where r.name != all ( _rec.columns )
      and source = _source.source_format
  ;


  with __news as (
    select
      n.doc->>'column_name' as name,
      n.doc->>'column_type' as type
    from unnest( _rec.configs ) n ( doc )
      left join report.vcolumn rc on n.doc->>'column_name' = rc.name
        and rc.source = _source.source_format
    where rc.name is null
  )
  insert into report.vcolumn (
    source,
    name,
    filter,
    agg,
    type
  ) select
      _report.report_source,
      _n.name,
      jsonb_build_array(),
      jsonb_build_array(),
      _n.type
  from __news _n;

  with __updates as  (
    select
      n.doc->>'column_name' as name,
      n.doc->>'column_type' as type
    from unnest( _rec.configs ) n ( doc )
  ) update report.vcolumn c
  set
    type = _up.type
  from __updates _up
  where c.name = _up.name
    and c.source = _source.source_format
  ;

  return query
    select  to_json( rc )
      from report.vcolumn rc
      where rc.source = _report.report_source
  ;
end;
$_$;


--
-- TOC entry 550 (class 1255 OID 16806)
-- Name: vars(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.vars(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      var_key: [key, key, key],
      arg_colaborador_id::UID
      arg_espaco_id::UID
      source::(report-source)
    }
   */
  _var_key text[] default array( select e.text from jsonb_array_elements_text( args->'var_key') e ( text ) );
begin
  if coalesce( array_length(_var_key, 1), 0 ) = 0 then
    select array_agg( var_key ) into  _var_key
      from report.var v;
  end if;

  return query
    with __vars as (
      select vk.*,
        report.eval( format( 'select (%s)::%s', vk.var_expression, vk.var_type ), '{}'::jsonb ) as value
      from report.var vk
      where vk.var_key = any( _var_key )
    ) select to_jsonb( _vk )
    from __vars _vk
  ;
end;
$$;


--
-- TOC entry 510 (class 1255 OID 16807)
-- Name: vcolumns(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.vcolumns(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args: {
      "source":"REPORT_SOURCE"
    },
   */
  _src character varying default args->>'source';
  _source record;
begin
  select * into _source
  from report.source_map( _src );

  -- COLUMNS
  return query
    select
      jsonb_build_object(
          'key', format( 'column|%s.%s', _src, rc.name ),
          'column', rc.name,
          'name', coalesce( rc.rename, rc.name ),
          'type', 'column',
          'format', rc.format,
          'dataType', rc.type,
          'init', rc.init
        )
    from report.vcolumn rc
    where rc.source = _source.source_format
      and rc.show
    order by rc.position desc
      nulls last,
             coalesce( rc.rename, rc.name )
  ;

  -- FILTER
  return query
    with __filters as (
      select rc.*, f.ordinality, report.__template_of( f.doc, to_jsonb( rc ) || to_jsonb( _source ) || to_jsonb( r ) ) as doc
      from report.vcolumn rc
         inner join report.report r on rc.source = r.report_source
         inner join jsonb_array_elements( rc.filter ) with ordinality f( doc ) on true
      where rc.source = _source.source_format
        and jsonb_array_length( rc.filter ) > 0
    ) select f.doc || jsonb_build_object(
        'key', format( 'filter|%s.%s::#%s', _src, f.name, f.ordinality ),
        'opr', f.doc->'opr',
        'column', f.name,
        'dataType', f.type,
        'name', f.doc->'name',
        'mode', f.doc->'mode',
        'source', f.doc->'source',
        'src', f.doc->'src',
        'format', f.doc->'format',
        'type', 'filter'
      ) from __filters  f
    order by
      coalesce( ( f.doc->>'position')::int2, f.position ) desc
      nulls last,
      f.ordinality,
      coalesce( f.doc->>'name', f.name )
  ;

  -- GROUP
  return query
    with __filters as (
      select rc.*,
             agg.function as agg_function,
             agg.label as agg_label,
             agg.key as agg_key,
             agg.priority as agg_priority,
             lib.str_normalize( format( agg.name, rc.name ) ) as agg_name,
             agg.format as agg_format,
             lib.str_normalize( format( agg.rename, rc.name ) ) as agg_rename,
             agg.simple as agg_simple,
             agg.expression as agg_expresion,
             agg.over as agg_over,
             agg.types as agg_types,
             format( '%I', rc.name ) as agg_usecolumn,
             lib.str_normalize( format( agg.rename, rc.name ) ) as agg_userename
      from report.vcolumn rc
             inner join report.report r on rc.source = r.report_source
             inner join report.agg agg on rc.format = any( agg.types )

      where rc.source = _source.source_format
        and rc.show
    ) select jsonb_build_object(
                 'key', format( 'aggregation|%s.%s::#%s', _src, f.name, f.agg_key ),
                 'column', f.name,
                 'name',  f.agg_name,
                 'func', f.agg_function,  -- f.doc -> 'func',
                 'format', coalesce( f.agg_format, f.format ), -- f.doc -> 'format',
                 'rename', f.agg_rename,
                 'type', 'group',
                 'label', f.agg_label,
                 'init', false,
                 'dataType', f.type,
                 'simple', format( f.agg_simple,  f.agg_usecolumn ),
                 'expression', format( f.agg_expresion, f.agg_usecolumn, f.agg_rename ),
                 'priority', f.agg_priority,
                 'column_position', f.position,
                 'over', format( f.agg_over, f.agg_usecolumn, format( '\\\\:%s:#ROW_NUMBER', f.name  ) )
               ) from __filters  f
    order by
      f.position desc nulls last,
      f.name,
      f.agg_priority nulls last;

  -- INDEPENDENT AGGREGATION
  return query
    with __vcolumn as (
      select
        rc.*,
        agg.function,
        agg.label,
        agg.key,
        agg.priority,
        agg.simple,
        agg.expression,
        agg.over,
        agg.types,
        agg.format _agg_format,
        lib.str_normalize( format( agg.name, rc.name ) ) as _agg_name,
        lib.str_normalize( format( agg.rename, rc.name ) ) as _agg_rename

        from report.vcolumn rc
          inner join report.report r on rc.source = r.report_source
          inner join report.agg agg on rc.format = any( agg.types )



    ),  __filters as (
      select rc.*,
             rc.function as agg_function,
             rc.label as agg_label,
             rc.key as agg_key,
             rc.priority as agg_priority,
             coalesce( e.doc->>'name', rc._agg_name ) as agg_name,
             coalesce( e.doc->>'format', rc._agg_format, rc.format ) as agg_format,
             coalesce( e.doc->>'rename', rc._agg_rename, e.doc->>'name', rc._agg_name ) as agg_rename,
             rc.simple as agg_simple,
             rc.expression as agg_expresion,
             rc.over as agg_over,
             rc.types as agg_types,
             format( '%I', rc.name )  as agg_usecolumn,
             format( '%I', coalesce( e.doc->>'rename', rc._agg_rename, e.doc->>'name', rc._agg_name, rc.name ) ) as agg_userename
      from __vcolumn rc
             inner join jsonb_array_elements( rc.agg ) with ordinality e( doc ) on true
               and ( e.doc->>'func' ) = rc.key
      where rc.source = _source.source_format
        and jsonb_array_length( rc.agg ) > 0
    ) select jsonb_build_object(
                 'key', format( 'aggregation|%s.%s::#%s', _src, f.name, f.agg_key ),
                 'column', f.name,
                 'dataType', f.type,
                 'name',  f.agg_name,
                 'func', f.agg_function,
                 'format', agg_format,
                 'rename', f.agg_rename,
                 'type', 'group',
                 'label', f.agg_label,
                 'init', false,
                 'simple', format( f.agg_simple,  f.agg_usecolumn ),
                 'expression', format( f.agg_expresion, f.agg_usecolumn, f.agg_rename ),
                 'priority', f.agg_priority,
                 'column_position', f.position,
                 'over', format( f.agg_over, f.agg_usecolumn, format( '\\\\:%s:#ROW_NUMBER', f.name  ) )
               ) from __filters  f
    order by
      f.position desc nulls last,
      f.name,
      f.agg_priority nulls last;
end
$$;


--
-- TOC entry 497 (class 1255 OID 16808)
-- Name: vreport_imposto_financas(jsonb); Type: FUNCTION; Schema: report; Owner: -
--

CREATE FUNCTION report.vreport_imposto_financas(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /*
    args := {
      arg_colaborador_id: UID
      arg_espaco_auth: UID
      arg_datainicio
      arg_datafim
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_datainicio date default args->>'arg_datainicio';
  arg_datafim date default args->>'arg_datafim';
  arg_branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;

begin
  _const := map.constant();
  return query
    with __declaracao as (
      select
         se.serie_sequencia as documento_numero,
         se.serie_numero as documento_serie,
         ct.conta_data as documento_data,
         coalesce( ct.conta_titularnif, cli.cliente_nif) as nif_consumidor,
         abs( ve.venda_montantesemimposto::numeric(100,6) ) as total_valor_itens,
         tx.taxa_percentagem as taxa_aplicavel_itens,
         coalesce( ve.venda_codigoimposto, ar.artigo_codigoimposto) as codigo_isento,
         abs( ve.venda_quantidade ) quant_itens,
         coalesce( ve.venda_descricao, ar.artigo_nome ) desc_itens,
         ctorigin.conta_numerofatura numero_documento_origem,
         ctorigin.conta_data data_documento_origem,
         tsorigin.tserie_code as tipo_documento_origem,
         ts.tserie_code,
         ct.conta_id,
         ve.venda_id,
         cli.cliente_id,
         tx.taxa_id,
         se.serie_id,
         ar.artigo_id,
         ct.conta_conta_docorigin,
         ct._branch_uid
         
      from tweeks.conta ct
        inner join json_populate_record( null::tweeks.serie, ct.conta_serie ) se on true
        inner join tweeks.serie _se on se.serie_id = _se.serie_id
        inner join tweeks.tserie ts on _se.serie_tserie_id = ts.tserie_id
        inner join tweeks.venda ve on ct.conta_id = ve.venda_conta_id
          and ve.venda_estado = _const.maguita_venda_estado_fechado
          and ve.venda_venda_id is null
        inner join tweeks.taxa tx on tx.taxa_id = any( ve.venda_taxas )
        inner join tweeks.artigo ar on ve.venda_artigo_id = ar.artigo_id
        left join tweeks.conta ctorigin on ct.conta_conta_docorigin = ctorigin.conta_id
        left join json_populate_record( null::tweeks.serie, ctorigin.conta_serie ) seorign on true
        left join tweeks.serie _seorign on seorign.serie_id = _seorign.serie_id
        left join tweeks.tserie tsorigin on _seorign.serie_tserie_id = tsorigin.tserie_id
        left join tweeks.cliente cli on ct.conta_cliente_id = cli.cliente_id

      where ve._branch_uid = arg_branch_uid
        and ct._branch_uid = arg_branch_uid
        and ct.conta_estado = _const.maguita_conta_estado_fechado
        and ve.venda_estado = _const.maguita_venda_estado_fechado
        and ct.conta_datafecho >= coalesce( arg_datainicio, ct.conta_data )
        and ct.conta_datafecho <= coalesce( arg_datafim, ct.conta_data )
        and ts.tserie_id in (
          _const.maguita_tserie_fatura,  
          _const.maguita_tserie_faturarecibo,  
          _const.maguita_tserie_notacredito  
        )
    ) select to_jsonb( _de ) from __declaracao _de
  ;
end;
$$;


--
-- TOC entry 487 (class 1255 OID 16809)
-- Name: artigo_generate_nextcodigo(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.artigo_generate_nextcodigo(arg_classe_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _classe tweeks.classe;
begin
  update tweeks.classe
    set classe_lastcodigo = classe.classe_lastcodigo +1
    where classe_id = arg_classe_id
    returning * into _classe
  ;

  return lib.str_nospace( format('%s%s', _classe.classe_codigo, to_char( _classe.classe_lastcodigo, '0000' ) ) );
end;
$$;


--
-- TOC entry 488 (class 1255 OID 16810)
-- Name: artigo_has_open_account(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.artigo_has_open_account(arg_artigo_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  -- Essa função serve para verificar se existe contas aberta com um artigo
  _const map.constant;
begin
  _const := map.constant();
  return (
    select count( * ) > 0
      from tweeks.venda vd
      where vd.venda_estado = _const.venda_estado_aberto
        and vd.venda_artigo_id = arg_artigo_id
  );
end
$$;


--
-- TOC entry 474 (class 1255 OID 16811)
-- Name: artigo_referencia(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.artigo_referencia(arg_artigo_id uuid) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  select jsonb_build_object( 'artigo_id', arg_artigo_id );
$$;


--
-- TOC entry 489 (class 1255 OID 16812)
-- Name: calculate_cost(double precision, double precision, double precision); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.calculate_cost(arg_precario_quantidade double precision, arg_precario_custo double precision, arg_quantidade double precision) RETURNS double precision
    LANGUAGE sql
    AS $_$
  /** Essa função calcula o custo x quantidade de uma compra
    arg_precario_quantidade ----> arg_precario_custo
    arg_quantidade  ------------> $x
    $x = arg_quantidade * arg_precario_custo / arg_precario_quantidade
    */
  select arg_quantidade * arg_precario_custo / arg_precario_quantidade
$_$;


--
-- TOC entry 490 (class 1255 OID 16813)
-- Name: classe_referencia(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.classe_referencia(arg_classe_id uuid) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
select jsonb_build_object( 'classe_id', arg_classe_id );
$$;


--
-- TOC entry 491 (class 1255 OID 16814)
-- Name: constant(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.constant() RETURNS map.constant
    LANGUAGE sql IMMUTABLE
    AS $$ select map.constant()$$;


--
-- TOC entry 492 (class 1255 OID 16815)
-- Name: espaco_get_childrens(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.espaco_get_childrens(arg_espaco_id uuid DEFAULT NULL::uuid) RETURNS uuid[]
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função devolve os espaços afilhado a um espaco
    arg_espaco_id := id do espaço
   */
begin
  if arg_espaco_id is null then
    return array( select esp.espaco_id from tweeks.espaco esp );
  else
    return array(
      with recursive __parent as (
        select e.espaco_id from tweeks.espaco e where e.espaco_id = arg_espaco_id
        union all
        select e.espaco_id
          from __parent l
            inner join tweeks.espaco e on l.espaco_id = e.espaco_espaco_id
      ) select l.espaco_id
        from __parent l
    );
  end if;
end;
$$;


--
-- TOC entry 493 (class 1255 OID 16816)
-- Name: espaco_get_childrens_static(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.espaco_get_childrens_static(arg_espaco_id uuid DEFAULT NULL::uuid) RETURNS uuid[]
    LANGUAGE sql IMMUTABLE
    AS $$select * from rule.espaco_get_childrens( arg_espaco_id );$$;


--
-- TOC entry 494 (class 1255 OID 16817)
-- Name: espaco_get_parent(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.espaco_get_parent(arg_espaco_id uuid) RETURNS smallint[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função devolve os espaços afilhado a um espaco
    arg_espaco_id := id do espaço
    arg_tespaco_id := o tipo do espaço
   */
begin
    return array(
      with recursive list as (
        select e.espaco_id, e.espaco_espaco_id from tweeks.espaco e where e.espaco_id = arg_espaco_id
        union all
        select e.espaco_id, e.espaco_espaco_id
          from list l
            inner join tweeks.espaco e on l.espaco_espaco_id = e.espaco_id
      ) select l.espaco_id
        from list l
    );
end;
$$;


--
-- TOC entry 758 (class 1255 OID 16818)
-- Name: __space_branch_level(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__space_branch_level(_espaco_id uuid) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
with recursive __espaco as (
  select
    e.espaco_id,
    e.espaco_espaco_id,
    0 as _espaco_nivel
  from tweeks.espaco e
  where e.espaco_espaco_id is null
  union all
  select
    e2.espaco_id,
    e2.espaco_espaco_id,
    e3._espaco_nivel +1
  from tweeks.espaco e2
         inner join __espaco e3  on e2.espaco_espaco_id = e3.espaco_id
) select e._espaco_nivel
from __espaco e
where e.espaco_id = $1
$_$;


--
-- TOC entry 243 (class 1259 OID 16819)
-- Name: espaco; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.espaco (
    espaco_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    espaco_vender character varying,
    espaco_espaco_id uuid,
    espaco_colaborador_id uuid NOT NULL,
    espaco_colaborador_atualizaco uuid,
    espaco_nome character varying,
    espaco_descricao character varying,
    espaco_estado smallint DEFAULT (map.get('espaco_estado_ativo'::name))::smallint NOT NULL,
    espaco_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    espaco_dataatualizacao timestamp with time zone,
    espaco_gerarfatura boolean DEFAULT true NOT NULL,
    espaco_configurar boolean DEFAULT true NOT NULL,
    espaco_codigo character varying NOT NULL,
    espaco_faturaano smallint DEFAULT date_part('year'::text, CURRENT_DATE) NOT NULL,
    espaco_seriefatura integer DEFAULT 0 NOT NULL,
    espaco_serieconta integer DEFAULT 0 NOT NULL,
    espaco_configuracao jsonb,
    espaco_seriedeposito bigint DEFAULT 0 NOT NULL,
    espaco_branch_uid uuid,
    espaco_espaco_auth uuid,
    espaco_nivel smallint GENERATED ALWAYS AS ((COALESCE(tweeks.__space_branch_level(espaco_espaco_id), '-1'::integer) + 1)) STORED NOT NULL,
    espaco_posto_admin uuid,
    _branch_uid uuid GENERATED ALWAYS AS (espaco_branch_uid) STORED,
    CONSTRAINT ck_esoaco_descricao_normalized CHECK (lib.str_is_normalized((espaco_descricao)::text)),
    CONSTRAINT ck_esoaco_nome_normalized CHECK (lib.str_is_normalized((espaco_nome)::text))
);


--
-- TOC entry 5831 (class 0 OID 0)
-- Dependencies: 243
-- Name: TABLE espaco; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.espaco IS '#Espaço - Essa entidade serve para armazenar os espaços do stock';


--
-- TOC entry 5832 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_id IS 'Identificador único do espaço';


--
-- TOC entry 5833 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_vender; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_vender IS 'Esse campo indica em qual dos nucleo o espaço deve permitir a venda';


--
-- TOC entry 5834 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_colaborador_id IS 'Identificador do colaborador responsável pelo registro do espaço';


--
-- TOC entry 5835 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_colaborador_atualizaco; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_colaborador_atualizaco IS 'Identificador do último colaborador responsavél pela atualização do espaço';


--
-- TOC entry 5836 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_nome; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_nome IS 'Corresponde ao nome do espaço';


--
-- TOC entry 5837 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_descricao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_descricao IS 'Corresponde a descrição do espaço';


--
-- TOC entry 5838 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_estado IS '
  Estado do espaco
  <ul>
    <li> 1 - Ativo </li>
    <li> 0 - Fechado </li>
  </ul>
';


--
-- TOC entry 5839 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_dataregistro IS 'Corresponde ao instante em que o espaço foi registrado no sistema';


--
-- TOC entry 5840 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN espaco.espaco_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.espaco.espaco_dataatualizacao IS 'Corresponde ao instante em que o espaço foi atualizado pelo última vez';


--
-- TOC entry 742 (class 1255 OID 16837)
-- Name: espaco_get_serializer(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.espaco_get_serializer(arg_espaco_id uuid) RETURNS tweeks.espaco
    LANGUAGE plpgsql STRICT
    AS $$
declare
  /**
    Essa função serve para devolver o espaço onde deve ser processado a fatura
    arg_espaco_id := id do espaço
   */
  _espaco tweeks.espaco;
begin

  with recursive parent as (
      select e.* from tweeks.espaco e where e.espaco_id = arg_espaco_id
    union all
      select e.*
        from parent p
          inner join tweeks.espaco e on p.espaco_espaco_id = e.espaco_id
        where not p.espaco_gerarfatura
  ) select l.* into _espaco
    from parent l
    where l.espaco_gerarfatura
  ;

  -- Quando saltar do ano reiniciar a contagem das faturas
  if _espaco.espaco_id is not null and _espaco.espaco_faturaano < extract( year from current_date ) then
    update tweeks.espaco
      set espaco_faturaano = extract( year from current_date ),
          espaco_seriefatura  = 0
      where espaco_id = _espaco.espaco_id
      returning  * into _espaco;
  end if;

  return _espaco;
end;
$$;


--
-- TOC entry 244 (class 1259 OID 16838)
-- Name: movimento; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.movimento (
    movimento_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    movimento_stock_id uuid NOT NULL,
    movimento_movimento_reference uuid,
    movimento_toperacao_id smallint NOT NULL,
    movimento_tmovimento_id smallint NOT NULL,
    movimento_espaco_auth uuid NOT NULL,
    movimento_colaborador_id uuid NOT NULL,
    movimento_colaborador_atualizacao uuid,
    movimento_referencia jsonb,
    movimento_data date,
    movimento_documento character varying,
    movimento_quantidade double precision,
    movimento_quantidadeinicia double precision,
    movimento_quantidadefinal double precision,
    movimento_observacao character varying,
    movimento_estado smallint DEFAULT (map.get('movimento_estado_ativo'::name))::smallint NOT NULL,
    movimento_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    movimento_dataatualizacao timestamp with time zone,
    movimento_artigo_in uuid,
    movimento_artigo_out uuid,
    movimento_espaco_in uuid,
    movimento_espaco_out uuid,
    movimento_valorin double precision,
    movimento_valorout double precision,
    movimento_valorstock double precision,
    movimento_regclass regclass,
    movimento_refuid uuid,
    _branch_uid uuid
);


--
-- TOC entry 5843 (class 0 OID 0)
-- Dependencies: 244
-- Name: TABLE movimento; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.movimento IS 'Essa entidade serve para armazenar as movimentações dos artigos feito nos stocks';


--
-- TOC entry 5844 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_id IS 'Corresponde ao identificador único da movimentação';


--
-- TOC entry 5845 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_stock_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_stock_id IS 'Identificador do stock a qual foi moviemntado o artigo';


--
-- TOC entry 5846 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_toperacao_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_toperacao_id IS 'Identificador do timo de movimentação';


--
-- TOC entry 5847 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_tmovimento_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_tmovimento_id IS 'O tipo de operação da movimentação
<ul>
  <li> credito: 1 </li>
  <li> debito: -1 </li>
</ul>
';


--
-- TOC entry 5848 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_colaborador_id IS 'Identificador do colaborador responsável pelo registro da movimentação';


--
-- TOC entry 5849 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização';


--
-- TOC entry 5850 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_referencia; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_referencia IS 'Referencia da operação que criou a movimentação
<ul>
  <li> acreto_id: ID </li>
  <li> entrada_id: ID </li>
  <li> venda_id: ID </li>
  <li> transferencia_id: ID </li>
</ul>';


--
-- TOC entry 5851 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_data; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_data IS 'A data em que a movimentação foi feita';


--
-- TOC entry 5852 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_documento; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_documento IS 'O documento da movimentação';


--
-- TOC entry 5853 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_quantidade; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_quantidade IS 'A quantidade do artigo movimentado';


--
-- TOC entry 5854 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_quantidadeinicia; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_quantidadeinicia IS 'A quantidade inicial do artigo antes da movimentação';


--
-- TOC entry 5855 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_quantidadefinal; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_quantidadefinal IS 'A quantidade final do artigo após a movimentação';


--
-- TOC entry 5856 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_observacao IS 'Corresponde a observação da movimentação';


--
-- TOC entry 5857 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_estado IS 'Corresponde ao estado da movimentação
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Anulado | siginifica que a operação foi anulada (uma operação já confirmada que é anulado) </li>
  <li> -1 - Canselado | significa que a operação foi canselado (o caso de venda quado o produto é removido do carinho) </li>
</ul>';


--
-- TOC entry 5858 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_dataregistro IS 'Corresponde ao instante em que a movimentação foi criada';


--
-- TOC entry 5859 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN movimento.movimento_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.movimento.movimento_dataatualizacao IS 'Corresponde ao instante em que a movimentação foi atualiza pela sua última vez';


--
-- TOC entry 743 (class 1255 OID 16846)
-- Name: movimento_create(uuid, uuid, uuid, smallint, jsonb, double precision, smallint, double precision, date, character varying); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.movimento_create(arg_espaco_auth uuid, arg_colaborador_id uuid, arg_stock_id uuid, arg_toperacao_id smallint, arg_movimento_referencia jsonb, arg_movimento_quantidade double precision, arg_tmovimento_id smallint, arg_movimento_quantidadefinal double precision DEFAULT NULL::double precision, arg_movimento_data date DEFAULT CURRENT_DATE, arg_movimento_documento character varying DEFAULT NULL::character varying) RETURNS tweeks.movimento
    LANGUAGE plpgsql
    AS $$
declare
  /** Registar um novo movimento no stock*/
  arg_operacao_nome varchar;

  _stock tweeks.stock;
  _artigo tweeks.artigo;
  _espaco tweeks.espaco;
  _const map.constant;
  _movimento tweeks.movimento;
  _tmovimento tweeks.tmovimento;
begin

  _const := map.constant();
  if arg_tmovimento_id not in ( _const.tmovimento_credito, _const.tmovimento_debito ) then
    raise exception 'Movimento rejeitado (tipo de movimento desconhecido)';
  end if;

  if arg_movimento_quantidade < 0 then
    raise exception 'Movimento rejeitado (Quantidade negativa)';
  end if;

  _tmovimento := tweeks._get_tmovimento( arg_tmovimento_id );
  _stock := tweeks._get_stock( arg_stock_id );
  _artigo := tweeks._get_artigo( _stock.stock_artigo_id );
  _espaco := tweeks._get_espaco( _stock.stock_espacao_id );


  arg_movimento_quantidadefinal := coalesce( arg_movimento_quantidadefinal, _stock.stock_quantidade + ( arg_movimento_quantidade * _tmovimento.tmovimento_multiplo ) );
  arg_movimento_data := coalesce( arg_movimento_data, current_date );

  if arg_movimento_quantidadefinal < 0  and not _artigo.artigo_stocknegativo then

    arg_operacao_nome := case
      when _tmovimento.tmovimento_id = _const.tmovimento_debito then 'Debito'
      when _tmovimento.tmovimento_id = _const.tmovimento_credito then 'Credito'
    end;
    --                             OPR    ART   ESP
    raise exception '%', format( 'O %s de %s %s em %s não pode ser concluido! Stock disponivél não soficiente para a operação (artigo não aceita stock negativo).',
      arg_operacao_nome,
      arg_movimento_quantidade,
      _artigo.artigo_nome,
      _espaco.espaco_nome
    );
  end if;

  insert into tweeks.movimento(
    movimento_espaco_auth,
    movimento_colaborador_id,
    movimento_stock_id,
    movimento_toperacao_id,
    movimento_referencia,
    movimento_data,
    movimento_quantidade,
    movimento_quantidadeinicia,
    movimento_quantidadefinal,
    movimento_tmovimento_id,
    movimento_documento
  ) values (
    arg_espaco_auth,
    arg_colaborador_id,
    _stock.stock_id,
    arg_toperacao_id,
    arg_movimento_referencia,
    arg_movimento_data,
    arg_movimento_quantidade,
    _stock.stock_quantidade,
    arg_movimento_quantidadefinal,
    arg_tmovimento_id,
    arg_movimento_documento
  ) returning * into _movimento;

  return _movimento;
end;
$$;


--
-- TOC entry 745 (class 1255 OID 16847)
-- Name: movimento_revert(uuid, uuid, smallint, smallint, character varying, text, smallint, character varying); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.movimento_revert(arg_espaco_auth uuid, arg_colaborador_id uuid, arg_toperacao_id smallint, arg_movimento_tmovimento_id smallint, arg_referencia_key character varying, arg_referencia_value text, arg_movimento_estado smallint, arg_movimento_observacao character varying) RETURNS tweeks.movimento
    LANGUAGE plpgsql
    AS $$
declare
  _movimento tweeks.movimento;
  _const map.constant;
begin
  _const := map.constant();

  if arg_movimento_estado not in ( _const.movimento_estado_canselado, _const.movimento_estado_canselado ) then
    raise exception 'Não pode reverter o movimento! estado invalido, code:{key: %, value: %, opr: %, tmv: %, usr: %, rev-mod: % }',
      arg_referencia_key, arg_referencia_value, arg_movimento_tmovimento_id, arg_toperacao_id, arg_colaborador_id, arg_movimento_estado;
  end if;

  select * into _movimento
    from tweeks.movimento mv
    where mv.movimento_referencia ->> ( arg_referencia_key ) = arg_referencia_value
      and mv.movimento_estado = _const.movimento_estado_ativo
      and mv.movimento_toperacao_id = arg_toperacao_id
      and mv.movimento_tmovimento_id = arg_movimento_tmovimento_id
      and mv.movimento_espaco_auth = arg_espaco_auth
    order by mv.movimento_dataregistro desc
  ;

  -- Se encontar alguma movimento que possa ser revertito então reverte
  if _movimento.movimento_id is not null then
    update tweeks.movimento
      set movimento_colaborador_atualizacao = arg_colaborador_id,
        movimento_dataatualizacao = current_timestamp,
        movimento_estado = arg_movimento_estado
      where movimento_id = _movimento.movimento_id
      returning * into _movimento
    ;
  end if;

  return _movimento;
end;
$$;


--
-- TOC entry 245 (class 1259 OID 16848)
-- Name: taxa; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.taxa (
    taxa_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    taxa_tipoimposto_id uuid NOT NULL,
    taxa_espaco_auth uuid NOT NULL,
    taxa_colaborador_id uuid NOT NULL,
    taxa_colaborador_atualizacao uuid,
    taxa_percentagem double precision,
    taxa_taxa double precision,
    taxa_estado smallint DEFAULT (map.get('taxa_estado_ativo'::name))::smallint NOT NULL,
    taxa_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    taxa_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    CONSTRAINT ck_taxa_percentagem_or_value_isnull CHECK (((taxa_percentagem IS NULL) OR (taxa_taxa IS NULL))),
    CONSTRAINT ck_taxa_percentagem_or_value_notnull CHECK (((taxa_percentagem IS NOT NULL) OR (taxa_taxa IS NOT NULL)))
);


--
-- TOC entry 5863 (class 0 OID 0)
-- Dependencies: 245
-- Name: TABLE taxa; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.taxa IS 'Essa entidade serve para registar as taxa de impostos';


--
-- TOC entry 5864 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_id IS 'Identificador único da taxa do imposto';


--
-- TOC entry 5865 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_tipoimposto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_tipoimposto_id IS 'O imposto o qual a taxa pertence';


--
-- TOC entry 5866 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_colaborador_id IS 'Identificador do colaborador responsável pelo registro da taxa';


--
-- TOC entry 5867 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização dat taxa (colaborador que fechou a taxa)';


--
-- TOC entry 5868 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_percentagem; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_percentagem IS 'Corresponde a percentagem da taxa a ser aplicado nos atrigos';


--
-- TOC entry 5869 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_taxa; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_taxa IS 'Corresponde ao valor da taxa (para o caso de imposto em que o valor da taxa não varia)';


--
-- TOC entry 5870 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_estado IS 'Corresponde ao estado da taxa';


--
-- TOC entry 5871 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_dataregistro IS 'Corresponde ao instante em que a taxa foi registrado';


--
-- TOC entry 5872 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxa.taxa_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.taxa.taxa_dataatualizacao IS 'Corresponde ao instante em que a taxa foi atualizado';


--
-- TOC entry 746 (class 1255 OID 16856)
-- Name: taxa_espaco(tweeks.taxa, map.constant, uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.taxa_espaco(_taxa tweeks.taxa, _const map.constant, arg_espaco_auth uuid) RETURNS tweeks.taxa
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para devolver a taxa subscrita em um espaco
   */
  _taxa_over tweeks.taxa;
begin
  -- Quando o espaço que pediu for espaço da taxa então devolver a propria taxa
  if _taxa.taxa_espaco_auth = arg_espaco_auth then return _taxa; end if;

  with recursive parent as (
      select
        e.*,
        tx over_taxa,
        tx.taxa_id is not null self_taxa

      from tweeks.espaco e
        left join tweeks.taxa tx on tx.taxa_espaco_auth = e.espaco_id
          and tx.taxa_tipoimposto_id = _taxa.taxa_tipoimposto_id
          and tx.taxa_estado = _const.taxa_estado_ativo
      where e.espaco_id = arg_espaco_auth

    union all
      select
          e.*,
          tx as over_taxa,
          tx.taxa_id is not null as self_taxa
        from parent p
          inner join tweeks.espaco e on p.espaco_espaco_id = e.espaco_id
          left join tweeks.taxa tx on e.espaco_id = tx.taxa_espaco_auth
            and tx.taxa_estado = _const.taxa_estado_ativo
            and tx.taxa_tipoimposto_id = _taxa.taxa_tipoimposto_id
        where not p.self_taxa --quando o parente não gerar fatura || quando o parente não ter taxa
  ) select (l.over_taxa).* into _taxa_over
  from parent l
    where l.self_taxa
  ;

  raise notice '% %', _taxa_over.taxa_id, _taxa.taxa_id ;
  if _taxa_over.taxa_id is null then
    _taxa_over := _taxa;
  end if;
  return _taxa_over;
end;
$$;


--
-- TOC entry 527 (class 1255 OID 16857)
-- Name: taxa_retirar_percentagem_adicionada(double precision, double precision); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.taxa_retirar_percentagem_adicionada(arg_value double precision, arg_percentagem double precision) RETURNS double precision
    LANGUAGE sql
    AS $$
    select ( arg_value * arg_percentagem ) / ( 100.0 + arg_percentagem );
  $$;


--
-- TOC entry 528 (class 1255 OID 16858)
-- Name: tg_amortizacao_afeter_insert_syncronize_montante(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_amortizacao_afeter_insert_syncronize_montante() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para atualizar o valor do montante em (posto, conta, ... )
   */
  arg_conta_id uuid;

  _new tweeks.amortizacao;
  _conta tweeks.conta;
  _const map.constant;
  _caixa tweeks.caixa;
begin
  _const := map.constant();
  _new := new;
  arg_conta_id := _new.amortizacao_referencia->>'conta_id';
  _caixa := tweeks._get_caixa( _new.amortizacao_caixa_id );

  -- Se o movimentação for de uma conta
  if arg_conta_id is not null then
    _conta := tweeks._get_conta( arg_conta_id );
    _conta.conta_montanteamortizado := _conta.conta_montanteamortizado + _new.amortizacao_montante + _new.amortizacao_montantetroco;
    _conta.conta_montantemoeda := _conta.conta_montantemoeda + _new.amortizacao_montantemoeda;
    _conta.conta_taxacambio := _new.amortizacao_taxacambio;

    -- Calcular o valor do troco
    if _conta.conta_montanteamortizado > ( _conta.conta_montante - _conta.conta_desconto ) then
      _conta.conta_montantetroco := _conta.conta_montanteamortizado - ( _conta.conta_montante - _conta.conta_desconto );
      _conta.conta_montanteamortizado := ( _conta.conta_montante - _conta.conta_desconto );
    end if;

    -- Fechar a conta se o novo montante amortizado pagar o valor da conta
    if _conta.conta_montanteamortizado >= ( _conta.conta_montante - _conta.conta_desconto ) and _conta.conta_estado != _const.conta_estado_pago then
      _conta.conta_estado := _const.conta_estado_pago;
    end if;

    update tweeks.conta
      set conta_montanteamortizado = _conta.conta_montanteamortizado,
          conta_montantemoeda = _conta.conta_montantemoeda,
          conta_taxacambio = _conta.conta_taxacambio,
          conta_caixa_fechopagamento = _caixa.caixa_id,
          conta_montantetroco = _conta.conta_montantetroco,
          conta_estado = _conta.conta_estado,
          conta_dataatualizacao = current_timestamp,
          conta_colaborador_atualizacao = _new.amortizacao_colaborador_id
      where conta_id = _conta.conta_id
    ;
  end if;

  perform rule.transacao_create(
    _new.amortizacao_espaco_auth,
    _caixa.caixa_posto_id,
    _const.toperacao_pagamento,
    _const.tmovimento_credito,
    _new.amortizacao_colaborador_id,
    _new.amortizacao_montante,
    _new.amortizacao_documento,
    jsonb_build_object( 'amortizacao_id', _new.amortizacao_id ),
    false,
    null
  );

  return null;
end;
$$;


--
-- TOC entry 529 (class 1255 OID 16859)
-- Name: tg_caixa_after_insert_abrir_posto(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_caixa_after_insert_abrir_posto() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função deve abrir uma posto depois que for inserido uma nova caixa de posto
   */
  _new tweeks.caixa;
  _const map.constant;
begin
  _new := new;
  _const := map.constant();

  update tweeks.posto cx
    set posto_estado = _const.posto_estado_aberto
    where posto_id = _new.caixa_posto_id
  ;

  return null;
end;
$$;


--
-- TOC entry 530 (class 1255 OID 16860)
-- Name: tg_caixa_after_updade_fechar_posto(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_caixa_after_updade_fechar_posto() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função deve fechar uma posto depois que a sua caixa tiver fechada
   */
  _new tweeks.caixa;
  _old tweeks.caixa;
  _const map.constant;
begin
  _new := new;
  _old := old;
  _const := map.constant();

  -- Quando o estado da caixa for fechado
  if _new.caixa_estado = _const.caixa_estado_fechado
    and _new.caixa_estado != _old.caixa_estado
  then
    update tweeks.posto cx
      set posto_estado = _const.posto_estado_fechado
      where posto_id = _new.caixa_posto_id
    ;
  end if;

  return null;
end;
$$;


--
-- TOC entry 532 (class 1255 OID 16861)
-- Name: tg_conta_after_update_adjust_venda_estado(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_conta_after_update_adjust_venda_estado() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Esse trigger serve para ajustar o montante da caixa depois que uma conta for atualizada
  */
  _new tweeks.conta;
  _old tweeks.conta;
  _const map.constant;

  arg_venda_estado int2;
begin
  _const := map.constant();
  _new := new;
  _old := old;

  /**
    Atualizar o estado das vendas depois que a conta for atualizado
    O montante da caixa sera atualizado no momento que for feito o registro de amortizacao
    É nesse momento que um trigger de amortizacão atualizara tambem a conta{
      +> amortizacao
        => posto
        => conta
    }
   */

  -- prepar o novo estado para avenda
  if _old.conta_estado != _new.conta_estado and _old.conta_estado in (
    _const.conta_estado_aberto,
    _const.conta_estado_fechado
  ) and _new.conta_estado in (
    _const.conta_estado_fechado,
    _const.conta_estado_pago,
    _const.conta_estado_anulado
  ) then
    arg_venda_estado := case
      when _new.conta_estado = _const.conta_estado_fechado then _const.venda_estado_fechado
      when _new.conta_estado = _const.conta_estado_pago    then _const.venda_estado_fechado
      when _new.conta_estado = _const.conta_estado_anulado then _const.venda_estado_anulado
    end;

    -- fechar ou anular a venda da conta
    update tweeks.venda
      set venda_estado = arg_venda_estado
      where venda_conta_id = _old.conta_id
        and venda_estado != arg_venda_estado
        and venda_estado in (
          _const.venda_estado_aberto,
          _const.venda_estado_fechado
        );
  end if;

  return null;
end;
$$;


--
-- TOC entry 747 (class 1255 OID 16862)
-- Name: tg_retalho_after_insert_create_movimento(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_retalho_after_insert_create_movimento() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

declare

    /** Esse trigger deve decrementar o valor do stock depois que um nova venda for registrado
     **/

    _new tweeks.retalho;
    _stock_retalho tweeks.stock;
    _stock_composto tweeks.stock;
    _artigo_retalho tweeks.artigo;
    _artigo_composto tweeks.artigo;
    _const map.constant;

begin

    _const := map.constant();
    _new := new;
    _artigo_retalho := tweeks._get_artigo( _new.retalho_artigo_retalho );
    _artigo_composto := tweeks._get_artigo( _new.retalho_artigo_composto );
    _stock_retalho := tweeks._get_stock( _artigo_retalho.artigo_id, _new.retalho_espaco_auth );
    _stock_composto := tweeks._get_stock( _artigo_composto.artigo_id, _new.retalho_espaco_auth );


    -- Debitar a quantidade a retalhar do artigo composto\
    perform rule.movimento_create(
            _new.retalho_espaco_auth,
            _new.retalho_colaborador_id,
            _stock_composto.stock_id,
            _const.toperacao_retalho,
            jsonb_build_object( 'retalho_id', _new.retalho_id ),
            _new.retalho_compostoquantidade,
            _const.tmovimento_debito,
            null,
            null,
            replace( to_char( _new.retalho_sequence, 'RT-0000-0000-0000/"C"' ), ' ', '' )
        );

    -- Debitar a quantidade a retalhar do artigo composto\
    perform rule.movimento_create(
            _new.retalho_espaco_auth,
            _new.retalho_colaborador_id,
            _stock_retalho.stock_id,
            _const.toperacao_retalho,
            jsonb_build_object( 'retalho_id', _new.retalho_id ),
            _new.retalho_retalhoquantidade,
            _const.tmovimento_credito,
            null,
            null,
            replace( to_char( _new.retalho_sequence, 'RT-0000-0000-0000/"R"' ), ' ', '' )
        );

    return null;
end;
$$;


--
-- TOC entry 748 (class 1255 OID 16863)
-- Name: tg_stock_after_update(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_stock_after_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Esse trigger atualiza o valor do stok total do artigo
   */
  _new tweeks.stock;
  _old tweeks.stock;
  arg_artigo_stock double precision;
  _const map.constant;
begin
  _const := map.constant();
  _new := new;
  _old := old;

  if _new.stock_quantidade != _old.stock_quantidade then
    arg_artigo_stock := (
      select sum( stt.stock_quantidade )
      from tweeks.stock stt
      where stt.stock_artigo_id = _old.stock_artigo_id
        and stt.stock_estado = _const.stock_estado_ativo
    );

    update tweeks.artigo
      set artigo_stock = coalesce( arg_artigo_stock, 0.0 )
      where artigo_id = _old.stock_artigo_id
    ;
  end if;


  return null;
end;
$$;


--
-- TOC entry 749 (class 1255 OID 16864)
-- Name: tg_stock_before_insert_or_update_check_quantidade(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_stock_before_insert_or_update_check_quantidade() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Validadar a nova quantidade do artigo em stock*/
  _new tweeks.stock;
  _artigo tweeks.artigo;
  _espaco tweeks.espaco;
begin

  _new := new;
  _artigo := tweeks._get_artigo( _new.stock_artigo_id );
  _espaco := tweeks._get_espaco( _new.stock_espacao_id );



  if _new.stock_quantidade < 0 and not _artigo.artigo_stocknegativo then
    raise exception 'Operção rejeitada! A nova quantidade em stock do % em % inferior é de %s. Esse artigo não aceita stock negativo!',
      _artigo.artigo_nome,
      _espaco.espaco_nome,
      _new.stock_quantidade
    ;
  end if;

  return _new;
end;
$$;


--
-- TOC entry 592 (class 1255 OID 16865)
-- Name: tg_transacao_after_insert_adjust_posto_montante(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_transacao_after_insert_adjust_posto_montante() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new tweeks.transacao;
begin
  _new := new;

  -- Atualizar o valor no posto
  update tweeks.posto
    set posto_montante = _new.transacao_montantefinal
    where posto_id = _new.transacao_posto_id
  ;

  return null;
end;
$$;


--
-- TOC entry 750 (class 1255 OID 16866)
-- Name: tg_venda_after_insert_create_movimento(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_venda_after_insert_create_movimento() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Esse trigger deve decrementar o valor do stock depois que um nova venda for registrado
   **/
  _new tweeks.venda;
  _stock tweeks.stock;
  _data record;
  _conta tweeks.conta;
  _const map.constant;
begin
  _const := map.constant();
  _new := new;
  _data := tweeks._get_conta( _new.venda_conta_id );
  _stock := tweeks._get_stock( _new.venda_artigo_id, _new.venda_espaco_auth );
  _conta := tweeks._get_conta( _new.venda_conta_id );

  perform rule.movimento_create(
    _new.venda_espaco_auth,
    _new.venda_colaborador_id,
    _stock.stock_id,
    _const.toperacao_venda,
    jsonb_build_object( 'venda_id', _new.venda_id ),
    _new.venda_quantidade,
    _const.tmovimento_debito,
    null,
    null,
    _conta.conta_numerofatura
  );

  return null;
end;
$$;


--
-- TOC entry 531 (class 1255 OID 16867)
-- Name: tg_venda_after_update_adjust_agrega_estado(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_venda_after_update_adjust_agrega_estado() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para ajustar os estados dos item extras agregado a venda depois que a venda for atualizado
  */
  _old tweeks.venda;
  _new tweeks.venda;
  _const map.constant;
  arg_agrega_estado int2;
begin
  _const := map.constant();
  _new:=new;
  _old:=old;

  -- Quando houver mudancas no estado de venda atualizar o estados nos itens agregado
  if _new.venda_estado != _old.venda_estado and _old.venda_estado in (
    _const.maguita_venda_estado_aberto,
    _const.maguita_venda_estado_fechado
  )  and _new.venda_estado in (
    _const.maguita_venda_estado_fechado,
    _const.maguita_venda_estado_anulado,
    _const.maguita_venda_estado_canselado
  ) then

    arg_agrega_estado := case
      when _new.venda_estado = _const.maguita_venda_estado_fechado then _const.maguita_venda_estado_fechado
      when _new.venda_estado = _const.maguita_venda_estado_canselado then _const.maguita_venda_estado_anulado
      when _new.venda_estado = _const.maguita_venda_estado_anulado then _const.maguita_venda_estado_anulado
    end;

    -- Todos os itens agregados a
    update tweeks.venda
      set venda_estado = arg_agrega_estado
      where venda_venda_id = _old.venda_id
        and venda_estado in (
          _const.maguita_venda_estado_fechado,
          _const.maguita_venda_estado_aberto
        );
  end if;

  return null;
end;
$$;


--
-- TOC entry 744 (class 1255 OID 16868)
-- Name: tg_venda_after_update_adjust_conta_montante(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_venda_after_update_adjust_conta_montante() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Esse trigger serve para atualizar o montante de conta */
  _new tweeks.venda;
  _old tweeks.venda;
  _const map.constant;
begin

  _const := map.constant();
  _new := new;
  _old := old;

  -- raise exception 'ola works --11111';

  -- Quando o estada da venda for desativadao decrementar o valor
  if _old.venda_estado != _new.venda_estado and _new.venda_estado = _const.maguita_venda_estado_canselado then

    update tweeks.conta
      set conta_montante = conta_montante - coalesce( _old.venda_montantecomimposto, 0 )
      where conta_id  = _old.venda_conta_id
    ;

  -- Quando o valor do imposto para a venda for determinado então
  elseif _old.venda_montantecomimposto is null and _new.venda_montantecomimposto is not null then

    update tweeks.conta
      set conta_montante = conta_montante + _new.venda_montantecomimposto
      where conta_id = _old.venda_conta_id
    ;

  -- Quando o montante total da venda for atualizado
  elseif _old.venda_montantecomimposto != _new.venda_montantecomimposto then

    update tweeks.conta
      set conta_montante = conta_montante - coalesce( _old.venda_montantecomimposto, 0 ) + coalesce( _new.venda_montantecomimposto, 0 )
      where conta_id = _old.venda_conta_id
    ;
  end if;

  return null;
end;
$$;


--
-- TOC entry 751 (class 1255 OID 16869)
-- Name: tg_venda_after_update_create_or_cansel_movimento(); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tg_venda_after_update_create_or_cansel_movimento() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para ajustar o stock do artigo depois que uma nova venda for inserida
  **/
  _new tweeks.venda;
  _old tweeks.venda;
  _conta tweeks.conta;
  _stock_old tweeks.stock;
  _stock_new tweeks.stock;
  _const map.constant;
begin
  _const := map.constant();
  _new := new;
  _old := old;
  _conta := tweeks._get_conta( _old.venda_conta_id );
  _stock_old := tweeks._get_stock( _old.venda_artigo_id, _old.venda_espaco_auth );
  _stock_new := tweeks._get_stock( _old.venda_artigo_id, _new.venda_espaco_auth );

  -- Se a quantidade de venda for atualizado ou a venda mover do espaço
    -- reverver o movemento do stock anterior e criar um novo movimento do stock
  if _old.venda_quantidade != _new.venda_quantidade
    or _old.venda_espaco_auth != _new.venda_espaco_auth
  then
    perform rule.movimento_revert(
      _old.venda_espaco_auth,
      coalesce( _new.venda_colaborador_atualizacao, _new.venda_colaborador_id ),
      _const.toperacao_venda,
      _const.tmovimento_debito,
      'venda_id',
      _old.venda_id::text,
      _const.movimento_estado_canselado,
      'Arigo removido da venda'
    );

    perform rule.movimento_create(
      _new.venda_espaco_auth,
      coalesce( _new.venda_colaborador_atualizacao, _new.venda_colaborador_id ),
      _stock_new.stock_id,
      _const.toperacao_venda,
      jsonb_build_object( 'venda_id', _new.venda_id ),
      _new.venda_quantidade,
      _const.tmovimento_debito,
      null,
      null,
      _conta.conta_numerofatura
    );
  end if;


  -- Se a venda for canselado da conta então repor o stock do produto inicial
  if _old.venda_estado in ( _const.maguita_venda_estado_fechado, _const.maguita_venda_estado_aberto )
    and _new.venda_estado in ( _const.maguita_venda_estado_canselado, _const.maguita_venda_estado_anulado )
  then
    perform rule.movimento_revert(
      _old.venda_espaco_auth,
      coalesce( _new.venda_colaborador_atualizacao, _new.venda_colaborador_id ),
      _const.toperacao_venda,
      _const.tmovimento_debito,
      'venda_id',
      _old.venda_id::text,
      _const.movimento_estado_canselado,
      'Arigo removido da venda'
    );

  -- Quando a quantidade do produto for atualizado na venda
  -- Canselar o movimento anterior e criar um novo movimento
  end if;

  return null;
end;
$$;


--
-- TOC entry 752 (class 1255 OID 16870)
-- Name: tipoimposto_referencia(uuid); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.tipoimposto_referencia(arg_tipoimposto_id uuid) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
select jsonb_build_object( 'tipoimposto_id', arg_tipoimposto_id );
$$;


--
-- TOC entry 246 (class 1259 OID 16871)
-- Name: transacao; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.transacao (
    transacao_id uuid NOT NULL,
    transacao_posto_id uuid NOT NULL,
    transacao_toperacao_id smallint NOT NULL,
    transacao_tmovimento_id smallint NOT NULL,
    transacao_espaco_auth uuid NOT NULL,
    transacao_colaborador_id uuid NOT NULL,
    transacao_colaborador_atualizacao uuid,
    transacao_referencia jsonb,
    transacao_documento character varying,
    transacao_zerar boolean NOT NULL,
    transacao_montante double precision NOT NULL,
    transacao_montanteinicial double precision NOT NULL,
    transacao_montantefinal double precision NOT NULL,
    transacao_observacao character varying,
    transacao_estado smallint DEFAULT (map.get('transacao_estado_ativo'::name))::smallint NOT NULL,
    transacao_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    transacao_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 5889 (class 0 OID 0)
-- Dependencies: 246
-- Name: TABLE transacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.transacao IS 'Essa entidade serve para registar todas as transações em um posto';


--
-- TOC entry 5890 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_id IS 'Identificador único da transação';


--
-- TOC entry 5891 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_posto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_posto_id IS 'Identificador do posto o qual foi transacionado';


--
-- TOC entry 5892 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_toperacao_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_toperacao_id IS 'Identificador do tipo de operação';


--
-- TOC entry 5893 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_tmovimento_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_tmovimento_id IS 'Identificador do tipo de movimento o qual foi feito na transação';


--
-- TOC entry 5894 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_colaborador_id IS 'Identificador do colaborador responsável pelo registro do transacionamento';


--
-- TOC entry 5895 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_colaborador_atualizacao IS 'Identificador do colaborador responsável pela última atualização da transação';


--
-- TOC entry 5896 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_referencia; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_referencia IS 'Esse atribuito indica a referência da transação
<ul>
  <li> amortizacao_id: ID </li>
</ul>';


--
-- TOC entry 5897 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_documento; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_documento IS 'Corresponde ao documento usado para atranzação';


--
-- TOC entry 5898 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_zerar; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_zerar IS 'Esse atributo indica se a tranzação foi com intuito de zerar ou não';


--
-- TOC entry 5899 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_montante; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_montante IS 'Corresponde ao montante que foi transacionado';


--
-- TOC entry 5900 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_montanteinicial; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_montanteinicial IS 'Corresponde ao montente inicial antes da transação';


--
-- TOC entry 5901 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_montantefinal; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_montantefinal IS 'Corresponde ao montante final depois da transação';


--
-- TOC entry 5902 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_observacao IS 'Corresponde a uma observação para a transação';


--
-- TOC entry 5903 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_estado IS 'Corresponde ao estado da transação';


--
-- TOC entry 5904 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_dataregistro IS 'Corresponde ao instante em que a transação foi resgistrada no sistema';


--
-- TOC entry 5905 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN transacao.transacao_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transacao.transacao_dataatualizacao IS 'Corresponde ao instante em qua atransação foi atualizado pela última vez no sistema';


--
-- TOC entry 753 (class 1255 OID 16878)
-- Name: transacao_create(uuid, uuid, smallint, smallint, integer, double precision, character varying, jsonb, boolean, character varying); Type: FUNCTION; Schema: rule; Owner: -
--

CREATE FUNCTION rule.transacao_create(arg_espaco_auth uuid, arg_posto_id uuid, arg_toperacao_id smallint, arg_tmovimento_id smallint, arg_colaborador_id integer, arg_transacao_montante double precision, arg_transacao_documento character varying, arg_transacao_referencia jsonb DEFAULT NULL::jsonb, arg_transacao_zera boolean DEFAULT false, arg_transacao_observacao character varying DEFAULT NULL::character varying) RETURNS tweeks.transacao
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para registar as transações*/
  arg_transacao_montanteinicial double precision;
  arg_transacao_montantefinal double precision;
  _posto tweeks.posto;
  _const map.constant;
  _tmovimento tweeks.tmovimento;
  _transacao tweeks.transacao;

begin
  _const := map.constant();
  _posto := tweeks._get_posto( arg_posto_id );
  _tmovimento := tweeks._get_tmovimento( arg_tmovimento_id );


  -- Quando for para zerar o posto então o montante a debitar tem que ser o montante do posto
  arg_transacao_zera := coalesce( arg_transacao_zera, false );
  if arg_transacao_zera then
    arg_transacao_montante := _posto.posto_montante;
  end if;

  arg_transacao_montanteinicial := _posto.posto_montante;
  arg_transacao_montantefinal := _posto.posto_montante + ( _tmovimento.tmovimento_multiplo * arg_transacao_montante );

  insert into tweeks.transacao(
    transacao_posto_id,
    transacao_espaco_auth,
    transacao_toperacao_id,
    transacao_tmovimento_id,
    transacao_colaborador_id,
    transacao_referencia,
    transacao_documento,
    transacao_zerar,
    transacao_montante,
    transacao_montanteinicial,
    transacao_montantefinal,
    transacao_observacao
  ) values (
    arg_posto_id,
    arg_espaco_auth,
    arg_toperacao_id,
    arg_tmovimento_id,
    arg_colaborador_id,
    arg_transacao_referencia,
    arg_transacao_documento,
    arg_transacao_zera,
    arg_transacao_montante,
    arg_transacao_montanteinicial,
    arg_transacao_montantefinal,
    arg_transacao_observacao
  ) returning * into _transacao;

  return _transacao;
end;
$$;


--
-- TOC entry 760 (class 1255 OID 16879)
-- Name: ___override_auth_funct_autenticacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.___override_auth_funct_autenticacao(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para autenticar um colaborador
    no final da autenticacao sera devolvido as informacoes basica do colaborador
    args :{
      arg_auth_name: id | nif | email
      arg_auth_value: VALUE_OF_AUTH_NAME,
      arg_auth_method: senha | pin,
      arg_auth_key: VALUE_OF_AUTH_METHOD
    }
 */
  _auth record;
  espacos jsonb;
  ___branch tweeks.branch;
  _const map.constant;
begin
  _const := map.constant();

  select * into _auth
    from auth.funct_autenticacao( args );

  -- Quando o colaborador tiver accesso
  if _auth.colaborador_id is not null then
    ___branch := tweeks.__get_branch( tweeks.__branch_uid(
      _auth.colaborador_id
    ));

    if ___branch.branch_uid is not null then
      _auth.acesso := to_jsonb(array(
        select e.grants
          from auth.funct_load_grants(jsonb_build_object(
            'menus', ___branch.branch_grants->'menu',
            'colaborador_id', _auth.colaborador_id
          )) e( grants )
      ));
    end if;

    return query
      with __trabaha as (
          select array_agg( to_jsonb( tr ) || to_jsonb( es ) ) as espaco_trabalha
            from tweeks.trabalha tr
              inner join tweeks.espaco es on tr.trabalha_espaco_destino = es.espaco_id
                and tr.trabalha_colaborador_proprietario = _auth.colaborador_id
            where tr.trabalha_estado = _const.maguita_trabalha_estado_ativo
              and es.espaco_estado = _const.maguita_espaco_estado_ativo
      ) select jsonb_build_object(
            'auth', _auth,
            'espaco_trabalha', tr.espaco_trabalha
          )
        from __trabaha tr
      ;

    return query with
      __clusters as ( select c.cluster_uid, c.cluster_identifier, c.cluster_name, c.cluster_path  from cluster.cluster c ),
      __branch as (
        select
              b.branch_uid,
              b.branch_path,
              b.branch_clusters,
              b.branch_main_user,
              b.branch_main_workspace,
              b.branch_grants,
              b.branch_name,
              b.branch_licence,
              b.branch_state,
              b.branch_date,
              tb.tbranch_id,
              tb.tbranch_configs,
              tb.tbranch_name,
              e.espaco_id,
              e.espaco_nome,
              e.espaco_nivel,
              e.espaco_codigo,
              cmain.colaborador_id,
              cmain.colaborador_nome,
              cmain.colaborador_apelido,
              cmain.colaborador_email,
              cmain.colaborador_estado,
              cmain.colaborador_accesso,
              cmain.colaborador_tipo,
              array_agg( _clus ) as clusters

          from auth.colaborador cauth
            inner join cluster.branch b on cauth.colaborador_branch_uid = b.branch_uid
            inner join tweeks.tbranch tb on b.branch_tbranch_id = tb.tbranch_id
            inner join tweeks.espaco e on b.branch_uid = e.espaco_branch_uid
              and e.espaco_id = b.branch_main_workspace
            inner join auth.colaborador cmain on b.branch_uid = cmain.colaborador_branch_uid
              and cmain.colaborador_id = b.branch_main_user
            left join __clusters _clus on _clus.cluster_path = b.branch_path
              and ( b.branch_clusters is null or _clus.cluster_identifier = any( b.branch_clusters ) )
          where cauth.colaborador_id = _auth.colaborador_id
          group by
            cauth.colaborador_id,
            b.branch_uid,
            e.espaco_id,
            cmain.colaborador_id,
            tb.tbranch_id
      ) select to_jsonb( _b )
        from __branch _b;
  end if;
end;
$$;


--
-- TOC entry 463 (class 1255 OID 16880)
-- Name: ___override_auth_funct_load_grants(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.___override_auth_funct_load_grants(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    arg_colaborador_id: UID,
    arg_espaco_auth?: UID
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  _branch tweeks.branch;
  _adminMenus jsonb;
begin
  _branch := tweeks.__get_branch( tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth ));

  _adminMenus := _branch.branch_grants->'menu';

  if _branch.branch_uid is null then
    _adminMenus := to_jsonb(array(
      select me.menu_id
        from auth.menu me
        where me.menu_codigo in ( 'maguita.colaboradores', 'maguita.definicao' )
    ));
  end if;

  return query select *
    from auth.funct_load_grants( jsonb_build_object(
      'colaborador_id', arg_colaborador_id,
      'menus', _adminMenus
    ));
end;
$$;


--
-- TOC entry 759 (class 1255 OID 16881)
-- Name: ___override_auth_funct_load_menu(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.___override_auth_funct_load_menu(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_branch_uid: UID
    }
   */
  arg_branch_uid uuid default args->>'arg_branch_uid';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_id uuid default args->>'arg_espaco_id';
  _branch tweeks.branch;
  _menus int2[];
begin
  _branch := tweeks.__get_branch( arg_branch_uid );
  if _branch.branch_uid is null and arg_colaborador_id is not null then
    _branch := tweeks._get_branch_by_colaborador( arg_colaborador_id );
  end if;

  if _branch.branch_uid is null and arg_espaco_id is not null then
    _branch := tweeks._get_branch_by_colaborador( arg_espaco_id );
  end if;

  _menus := array( select e.text from jsonb_array_elements_text( _branch.branch_grants->'menu') e( text ) );

--   raise exception '%', args;

  return query with
                 __menu as (
                   select m.*
                   from auth.funct_load_menu( args ) as m
                   where menu_id = any( _menus )
                      or _branch.branch_uid is null
                 ) select to_jsonb( _m )
               from __menu _m;
end;
$$;


--
-- TOC entry 448 (class 1255 OID 16882)
-- Name: __artigo_has_stock(uuid, uuid, double precision); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__artigo_has_stock(arg_artigo_id uuid, arg_espaco_id uuid, arg_quantidadedebito double precision) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    /** Essa função serve para verificar se existe diponibilidade de um artig em um stock para cobrir uma quantidade de debito
     */
    _artigo tweeks.artigo;
    _stock record;
begin
    _artigo := tweeks._get_artigo( arg_artigo_id );

    -- Aceitar sempre que o artigo for do tipo staock negativo
    if _artigo.artigo_stocknegativo then return true; end if;

    select *
      from tweeks._get_stock( arg_artigo_id, arg_espaco_id )
      into _stock
    ;
    
    return _stock.stock_quantidade >= arg_quantidadedebito;
end;
$$;


--
-- TOC entry 247 (class 1259 OID 16883)
-- Name: menu; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.menu (
    menu_id smallint NOT NULL,
    menu_menu_id smallint,
    menu_codigo character varying NOT NULL,
    menu_raiz character varying NOT NULL,
    menu_nivel smallint NOT NULL,
    menu_icon character varying,
    menu_nome character varying NOT NULL,
    menu_link character varying,
    menu_estado smallint DEFAULT (map.get('menu_estado_ativo'::name))::smallint NOT NULL,
    menu_children smallint DEFAULT 0 NOT NULL,
    menu_maxnode smallint DEFAULT 0 NOT NULL,
    menu_directchildern smallint DEFAULT 0 NOT NULL,
    menu_position smallint DEFAULT 0 NOT NULL
);


--
-- TOC entry 5912 (class 0 OID 0)
-- Dependencies: 247
-- Name: TABLE menu; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.menu IS 'Essa entidade serve para armazenar os menus de acesso';


--
-- TOC entry 5913 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_id IS 'Identificador único do menu do acesso';


--
-- TOC entry 5914 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_menu_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_menu_id IS 'Identificador do menu parente';


--
-- TOC entry 5915 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_codigo; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_codigo IS 'Código único do menu';


--
-- TOC entry 5916 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_raiz; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_raiz IS 'Indica a raiz do menu';


--
-- TOC entry 5917 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_nivel; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_nivel IS 'Corresponde ao nível do menu';


--
-- TOC entry 5918 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_icon; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_icon IS 'Indica o nível do menu (quanto parrente esse menu possui)';


--
-- TOC entry 5919 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_nome; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_nome IS 'Corresponde ao nome do menu';


--
-- TOC entry 5920 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_link; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_link IS 'Corresponde ao link do menu';


--
-- TOC entry 5921 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_estado; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_estado IS 'Corresponde ao estado do menu
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Desativo </li>
</ul>';


--
-- TOC entry 5922 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_children; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_children IS 'Indica a quantidade de submenus esse menu possui';


--
-- TOC entry 5923 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_maxnode; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_maxnode IS 'Indica a quantidade de node (entradas) maximas que se conseguira a partir desse menu
<br>Indica a distacncia dos filhos mais longe';


--
-- TOC entry 5924 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_directchildern; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_directchildern IS 'Indica a quantidade de filhos diretamente ligado a esse menu';


--
-- TOC entry 5925 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN menu.menu_position; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.menu.menu_position IS 'Indica a possição da ordem do menu';


--
-- TOC entry 763 (class 1255 OID 16893)
-- Name: __branch_menu(uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__branch_menu(_branch_uid uuid DEFAULT NULL::uuid, _user uuid DEFAULT NULL::uuid, _espaco uuid DEFAULT NULL::uuid, _force boolean DEFAULT false) RETURNS SETOF auth.menu
    LANGUAGE plpgsql
    AS $$
declare
  _rec record;
  _branch tweeks.branch;
  _menus int[];
begin
  if _force then
    select array_agg( me.menu_id ) into _menus
      from auth.menu me
    ;
  else
    if _branch_uid is null then
      _branch_uid := tweeks.__branch_uid( _user, _espaco );
    end if;

    if _branch_uid is null then
      select
          b.*,
          count( * ) over () as _branchs_count
          into _rec
        from tweeks.branch b;
        if _rec._branchs_count = 1 then _branch_uid := _rec.branch_uid; end if;
    end if;

    _branch := tweeks.__get_branch( _branch_uid );
    _menus := array(
      select e.menu_id::int
        from jsonb_array_elements_text( _branch.branch_grants->'menu' ) e( menu_id )
    );
  end if;

  return query
    select me.*
      from auth.menu me
      where me.menu_id = any( _menus )
  ;
end;
$$;


--
-- TOC entry 764 (class 1255 OID 16894)
-- Name: __branch_uid(uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__branch_uid(_colaborador_uid uuid DEFAULT NULL::uuid, _espaco_uid uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE sql
    AS $$
  select b.branch_uid
    from tweeks.branch b
      left join tweeks.espaco e on b.branch_uid = e.espaco_branch_uid
        and e.espaco_id = _espaco_uid
      left join auth.colaborador c on b.branch_uid = c.colaborador_branch_uid
        and c.colaborador_id = _colaborador_uid
    where coalesce ( _colaborador_uid, _espaco_uid ) is not null
      and ( e.espaco_branch_uid = c.colaborador_branch_uid
        or( _colaborador_uid is null and e.espaco_id is not null )
        or( _espaco_uid is null and c.colaborador_id is not null )
      )
$$;


--
-- TOC entry 765 (class 1255 OID 16895)
-- Name: __check_stock_on_venda(uuid, jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__check_stock_on_venda(_espaco_auth uuid, _vendas jsonb) RETURNS TABLE(stocks boolean, message text, items text, counts text)
    LANGUAGE plpgsql
    AS $$
declare
  _data record;
begin
  -- Garrantir que tenha o stock disponivel para os artigos
  with recursive __venda as (
    select
      ( e.document->>'venda_artigo_id' )::uuid as venda_artigo_id,
      ( e.document->>'venda_quantidade' )::double precision as venda_quantidade,
      ( e.document->>'venda_custounitario' )::double precision as venda_custounitario,
      ( e.document->>'venda_custoquantidade' )::double precision as venda_custoquantidade,
      ( e.document->'arg_itens' ) as itens
    from jsonb_array_elements( _vendas ) e( document )
    union all
      select
         ( e.document->>'venda_artigo_id' )::uuid as venda_artigo_id,
         ( e.document->>'venda_quantidade' )::double precision as venda_quantidade,
         ( e.document->>'venda_custounitario' )::double precision as venda_custounitario,
         ( e.document->>'venda_custoquantidade' )::double precision as venda_custoquantidade,
         ( null )::jsonb as itens
        from __venda v
          inner join jsonb_array_elements( v.itens ) e( document ) on true
        where jsonb_array_length( coalesce( v.itens, jsonb_build_array() ) ) > 0
  ), __venda_group as (
      select
          v.venda_artigo_id,
          sum( v.venda_quantidade ) as venda_quantidade
        from __venda v
        group by v.venda_artigo_id
  ) select
      count( art.artigo_id ) as items_count,
      string_agg( art.artigo_nome, ', ' ) as items
      into _data
    from __venda_group vds
       inner join tweeks.artigo art on  vds.venda_artigo_id = art.artigo_id
       inner join tweeks._get_stock( art.artigo_id, _espaco_auth ) s on true
    where not  art.artigo_stocknegativo
      and not tweeks.__artigo_has_stock( art.artigo_id, _espaco_auth, vds.venda_quantidade )
  ;
  __check_stock_on_venda.stocks := _data.items_count = 0;
  __check_stock_on_venda.counts := _data.items_count;
  __check_stock_on_venda.items := _data.items;
  if _data.items_count > 1 then
    __check_stock_on_venda.message := format( 'Os stock dos produtos (%s) não cobrem a venda para essa conta', _data.items );
  elseif _data.items_count = 1 then
    __check_stock_on_venda.message := format( 'Os stock de %s não cobre a venda para essa conta', _data.items );
  end if;
  return next;
end;
$$;


--
-- TOC entry 766 (class 1255 OID 16896)
-- Name: __cluster_filter_branch(character varying, cluster.object, cluster.collector, cluster.cluster, cluster.cluster); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__cluster_filter_branch(share character varying, _object cluster.object, _collector cluster.collector, _cluster cluster.cluster, _origin cluster.cluster) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  _rec record;
  _branch tweeks.branch;
  _class regclass[] default array[
    'auth.colaborador'::regclass,
    'auth.acesso'::regclass,
    'tweeks.branch'::regclass,
    'tweeks.espaco'::regclass,
    'tweeks.cambio'::regclass,
    'tweeks.trabalha'::regclass
  ]::regclass[];
begin

  if share::regclass != all( _class ) then return true; end if;

  if share::regclass = 'tweeks.branch'::regclass then
    _branch := jsonb_populate_record( _branch, _collector.collector_metadata );

  --- Obter os branch dos registros
  elsif share::regclass = 'auth.colaborador'::regclass then
    _rec := jsonb_populate_record( null::auth.colaborador, _collector.collector_metadata );
    select * into _branch
      from tweeks.branch b
      where b.branch_uid = _rec.colaborador_branch_uid
    ;

  elsif share::regclass = 'auth.acesso'::regclass then
    _rec := jsonb_populate_record( null::auth.acesso, _collector.collector_metadata );
    select b.* into _branch
      from tweeks.branch b
        inner join auth.colaborador co on co.colaborador_branch_uid = b.branch_uid
      where co.colaborador_id = _rec.acesso_colaborador_propetario
    ;

  elsif share::regclass = 'tweeks.espaco'::regclass then
    _rec := jsonb_populate_record( null::tweeks.espaco, _collector.collector_metadata );
    select * into _branch
      from tweeks.branch b
      where b.branch_uid = _rec.espaco_branch_uid
    ;

  elsif share::regclass = 'tweeks.trabalha'::regclass then

    _rec := jsonb_populate_record( null::tweeks.trabalha, _collector.collector_metadata );
    select * into _branch
      from tweeks.branch br
        inner join tweeks.espaco e on br.branch_uid = e.espaco_branch_uid
      where e.espaco_id = _rec.trabalha_espaco_destino
    ;

  elsif share::regclass = 'tweeks.cambio'::regclass then

    _rec := jsonb_populate_record( null::tweeks.cambio, _collector.collector_metadata );
    select * into _branch
      from tweeks.branch br
        inner join tweeks.espaco e on br.branch_uid = e.espaco_branch_uid
      where e.espaco_id = _rec.cambio_espaco_auth
    ;
  end if;

  if share::regclass = 'tweeks.branch'::regclass then

    if _branch.branch_path is null then return false; end if;

    if _branch.branch_path != _cluster.cluster_path
        and not cluster.__is_sub_path( _branch.branch_path, _cluster.cluster_path )
    then return false;

    end if;

    if cluster.__is_sub_path( _cluster.cluster_path, _branch.branch_path ) then return true; end if;
    if cluster.__is_sub_path( _cluster.cluster_path, _branch.branch_path ) then return true; end if;

  end if;
  return true;
end;
$$;


--
-- TOC entry 767 (class 1255 OID 16897)
-- Name: __conta_adjust(uuid, uuid, map.constant); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__conta_adjust(arg_cliente_id uuid, arg_conta_id uuid DEFAULT NULL::uuid, _const map.constant DEFAULT map.constant()) RETURNS TABLE(conta_id uuid, conta_montante double precision, conta_montanteamortizado double precision, conta_montantependente double precision, conta_pago boolean, conta_pagamento smallint)
    LANGUAGE plpgsql
    AS $$
declare
  _balanco record;
begin
  select
      coalesce( sum( d.deposito_montantefinal ), 0.0 ) as deposito_montantefinal
      into _balanco
    from tweeks.deposito d
    where d.deposito_cliente_id = arg_cliente_id
      and d.deposito_estado = _const.maguita_deposito_estado_ativo
  ;

  return query
  with recursive __conta as (
    select
        row_number() over () as conta_posicao,
        ct.conta_id,
        ct.conta_montante,
        ct.conta_datafecho,
        ct.conta_dataregistro
      from tweeks.conta ct
      where ct.conta_cliente_id = arg_cliente_id
        and ct.conta_estado in (
          _const.maguita_conta_estado_fechado
        )
      order by ct.conta_datafecho,
        ct.conta_numero,
        ct.conta_dataregistro
  ), __ajuste as (
    select
      _ct.*,
        _balanco.deposito_montantefinal as deposito_montante,
        arg_conta_id is not null and _ct.conta_id = arg_conta_id as conta_find,
        case
          when _balanco.deposito_montantefinal >= _ct.conta_montante then _ct.conta_montante
          when _balanco.deposito_montantefinal > 0 then _balanco.deposito_montantefinal
          else 0
        end as conta_montanteamortizado,
        case
          when _balanco.deposito_montantefinal >= _ct.conta_montante then _balanco.deposito_montantefinal - _ct.conta_montante
          else 0
        end as deposito_restante
      from __conta _ct
      where _ct.conta_posicao = 1
    union all
      select
          _ct.*,
          _balanco.deposito_montantefinal as deposito_montante,
          arg_conta_id is not null and _ct.conta_id = arg_conta_id as conta_find,
          case
            when _aj.deposito_restante >= _ct.conta_montante then _ct.conta_montante
            when _aj.deposito_restante > 0 then _aj.deposito_restante
            else 0
          end as conta_montanteamortizado,
          case
            when _aj.deposito_restante >= _ct.conta_montante then _aj.deposito_restante - _ct.conta_montante
            else 0
          end as deposito_restante
        from __conta _ct
          inner join __ajuste _aj on _ct.conta_posicao + 1 = _aj.conta_posicao
        where not _aj.conta_find
  ) select
        _aj.conta_id,
        _aj.conta_montante,
        _aj.conta_montanteamortizado,
        _aj.conta_montante - _aj.conta_montanteamortizado,
        _aj.conta_montante = _aj.conta_montanteamortizado,
        case
          when _aj.conta_montanteamortizado = 0 then 2
          when _aj.conta_montanteamortizado > 0 and _aj.conta_montanteamortizado < _aj.conta_montante then 1
          else 0
        end::int2 as conta_pagamento
      from __ajuste _aj
      where _aj.conta_id = coalesce( arg_conta_id, _aj.conta_id )
  ;
end;
$$;


--
-- TOC entry 754 (class 1255 OID 16898)
-- Name: __fluxo_scan(uuid, uuid, boolean, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__fluxo_scan(_artigo_id uuid DEFAULT NULL::uuid, _espaco_id uuid DEFAULT NULL::uuid, _resume boolean DEFAULT true, _branch uuid DEFAULT NULL::uuid) RETURNS TABLE(fluxo_artigo_id uuid, fluxo_espaco_id uuid, fluxo_preview double precision, fluxo_resultado double precision, fluxo_checkmarks uuid, fluxo_check double precision, fluxo_order bigint, fluxo_end bigint, fluxo_resume boolean, fluxo_credito double precision, fluxo_debito double precision, fluxo_calc double precision, fluxo_quantidade double precision, fluxo_id uuid, fluxo_date timestamp with time zone, fluxo_sequencia bigint)
    LANGUAGE sql
    AS $$
with recursive
  __map as ( select maguita_fluxo_estado_ativo, maguita_fluxo_estado_fechado, maguita_fluxo_estado_anulado from map.constant()

  ), __espaco as (
    select a.espaco_id
      from tweeks.espaco a
      where a.espaco_id = coalesce( _espaco_id, a.espaco_id )
      and a._branch_uid = coalesce( _branch, a._branch_uid )
  ), __artigo as (
    select a.artigo_id
      from tweeks.artigo a
      where a.artigo_id = coalesce( _artigo_id, a.artigo_id )
      and a._branch_uid = coalesce( _branch, a._branch_uid )
 ), __stock_point as(
    select
      a.artigo_id,
      e.espaco_id,
      mode() within group ( order by f.fluxo_dataregistro desc ) as point
    from tweeks.fluxo f
      inner join __map _const on f.fluxo_estado = _const.maguita_fluxo_estado_ativo
      inner join __artigo a on a.artigo_id in ( f.fluxo_artigo_in, f.fluxo_artigo_out )
      inner join __espaco e on e.espaco_id in ( f.fluxo_espaco_in, f.fluxo_espaco_out )
    where f.fluxo_checkpoint = 0
      and f._branch_uid = coalesce( _branch, f._branch_uid )
      and f.fluxo_estado = _const.maguita_fluxo_estado_ativo
    group by a.artigo_id,
      e.espaco_id
  ),
  __fluxo as (
    select
      a.artigo_id,
      e.espaco_id,
      f.fluxo_id,
      f.fluxo_dataregistro,
      f.fluxo_sequencia,
      f.fluxo_checkpoint,
      case
        when e.espaco_id = f.fluxo_espaco_in and a.artigo_id = f.fluxo_artigo_in then f.fluxo_quantidadein
        else 0
        end as fluxo_credito,
      case
        when e.espaco_id = f.fluxo_espaco_out and a.artigo_id = f.fluxo_artigo_out then f.fluxo_quantidadeout
        else 0
        end as fluxo_debito,
      case
        when f.fluxo_quantidadefinal is not null then f.fluxo_quantidadefinal
        when e.espaco_id = f.fluxo_espaco_in and a.artigo_id = f.fluxo_artigo_in then f.fluxo_quantidadein * 1
        when e.espaco_id = f.fluxo_espaco_out and a.artigo_id = f.fluxo_artigo_out then f.fluxo_quantidadeout * -1
        end as fluxo_quantidade,
      row_number() over ( partition by a.artigo_id, e.espaco_id ) as fluxo_order,
      count( f.fluxo_id ) over ( partition by a.artigo_id, e.espaco_id ) as fluxo_end

    from tweeks.fluxo f
      inner join __map _const on f.fluxo_estado = _const.maguita_fluxo_estado_ativo
      inner join __artigo a on a.artigo_id in ( f.fluxo_artigo_in, f.fluxo_artigo_out )
      inner join __espaco e on e.espaco_id in ( f.fluxo_espaco_in, f.fluxo_espaco_out )
      left join __stock_point _sp on _sp.artigo_id = a.artigo_id and _sp.espaco_id = e.espaco_id
    where  f.fluxo_dataregistro >= coalesce( _sp.point, f.fluxo_dataregistro )
      and f._branch_uid = coalesce( _branch, f._branch_uid )
    order by a.artigo_id,
      e.espaco_id,
      f.fluxo_dataregistro,
      f.fluxo_sequencia
  ), __fluxo_stock as (
  select
    _f.artigo_id,
    _f.espaco_id,
    _f.fluxo_order,
    _f.fluxo_end,
    _f.fluxo_credito,
    _f.fluxo_debito,
    _f.fluxo_quantidade,
    _f.fluxo_id,
--     _f.fluxo_dataregistro,
--     _f.fluxo_sequencia,

    _f.fluxo_quantidade as fluxo_resultado,
    0.0::double precision as fluxo_preview,
--     _f.fluxo_id as fluxo_checkmarks,
--     _f.fluxo_quantidade as fluxo_checkquant,
    _f.fluxo_order = _f.fluxo_end as fluxo_resume
  from __fluxo _f
    inner join __map _const on true
  where _f.fluxo_order = 1
  union all
  select
    _f.artigo_id,
    _f.espaco_id,
    _f.fluxo_order,
    _f.fluxo_end,
    _f.fluxo_credito,
    _f.fluxo_debito,
    _f.fluxo_quantidade,
    _f.fluxo_id,
--     _f.fluxo_dataregistro,
--     _f.fluxo_sequencia,
    
    ( _fs.fluxo_resultado * _f.fluxo_checkpoint ) + ( _f.fluxo_quantidade ),
    _fs.fluxo_resultado as fluxo_priview,
--     case
--       when _f.fluxo_checkpoint = 0 then _f.fluxo_id
--       else _fs.fluxo_checkmarks
--       end,
--     case
--       when _f.fluxo_checkpoint = 0 then _f.fluxo_quantidade
--       else _fs.fluxo_checkquant
--       end,
    _f.fluxo_order = _f.fluxo_end as fluxo_resume

  from __fluxo_stock _fs
    inner join __fluxo _f on _fs.espaco_id = _f.espaco_id
        and _fs.artigo_id = _f.artigo_id
        and _fs.fluxo_order +1 = _f.fluxo_order
) select
    _fs.artigo_id as stock_artigo_id,
    _fs.espaco_id as stock_espaco_id,
    _fs.fluxo_preview,
    _fs.fluxo_resultado,

    null::uuid as fluxo_checkmarks,--     _fs.fluxo_checkmarks,
    null::double precision as fluxo_checkquant, --     _fs.fluxo_checkquant,
    _fs.fluxo_order,
    _fs.fluxo_end,
    _fs.fluxo_resume,

    _fs.fluxo_credito,
    _fs.fluxo_debito,
    _fs.fluxo_credito - _fs.fluxo_debito,
    _fs.fluxo_quantidade,
    _fs.fluxo_id,
    null::timestamptz, ---_fs.fluxo_dataregistro,
    null::int8 -- _fs.fluxo_sequencia
from __fluxo_stock _fs
where true in (
    coalesce( _resume, true ) = _fs.fluxo_resume,
    not _resume
  )
$$;


--
-- TOC entry 555 (class 1255 OID 92110)
-- Name: __fluxo_stock(uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__fluxo_stock(_artigo_uid uuid DEFAULT NULL::uuid, _espaco_uid uuid DEFAULT NULL::uuid, _classe_uid uuid DEFAULT NULL::uuid, _branch uuid DEFAULT NULL::uuid) RETURNS TABLE(espaco_id uuid, artigo_id uuid, stock_quantidade double precision)
    LANGUAGE sql
    AS $$
    with  __artigo as (
      select a.artigo_id
        from tweeks.artigo a
      where a.artigo_id = coalesce( _artigo_uid, a.artigo_id )
        and a.artigo_classe_id = coalesce( _classe_uid, a.artigo_classe_id )
        and a._branch_uid = coalesce( _branch, a._branch_uid )
        and not a.artigo_stocknegativo
    ), __espaco as (
      select e.espaco_id
        from tweeks.espaco e
        where e.espaco_id = coalesce( _espaco_uid, e.espaco_id )
          and e._branch_uid = coalesce( _branch, e._branch_uid )
    ), __fluxo as (
      select
          a.artigo_id,
          e.espaco_id,
          f.fluxo_id,
          f.fluxo_sequencia,
          f.fluxo_dataregistro,
          f.fluxo_quantidadefinal,
          f.fluxo_quantidadein,
          f.fluxo_quantidadeout,
          f.fluxo_artigo_in as artigo_in,
          f.fluxo_artigo_out as artigo_out,
          f.fluxo_espaco_out as espaco_out,
          f.fluxo_espaco_in as espaco_in,
          f.fluxo_checkpoint
        from tweeks.fluxo f
          inner join __espaco e on e.espaco_id  in ( f.fluxo_espaco_in, f.fluxo_espaco_out)
          inner join __artigo a on a.artigo_id in ( f.fluxo_artigo_in, f.fluxo_artigo_out )
        where f._branch_uid = coalesce( _branch, f._branch_uid )
    ), __check_point as (
      select
          f.artigo_id,
          f.espaco_id,
          f.fluxo_id,
          f.fluxo_dataregistro,
          f.fluxo_quantidadefinal,
          rank() over ( partition by f.artigo_id, f.espaco_id order by f.fluxo_dataregistro desc , f.fluxo_sequencia desc ) as fluxo_rank
        from __fluxo f
        where f.fluxo_checkpoint = 0
    ), __sumary as (
      select
        f.artigo_id,
        f.espaco_id,
        coalesce(
            sum( f.fluxo_quantidadein ) filter ( where f.artigo_id = f.artigo_in and f.espaco_id = f.espaco_in ),
            0
        ) + coalesce( cp.fluxo_quantidadefinal, 0.0 ) as credito,
        coalesce(
            sum( f.fluxo_quantidadeout ) filter ( where f.artigo_id = f.artigo_out and f.espaco_id = f.espaco_out ),
            0
        ) + coalesce( cp.fluxo_quantidadefinal, 0.0 ) as debigo
      from __fluxo f
        left join __check_point cp on  f.artigo_id = cp.artigo_id
          and f.espaco_id = cp.espaco_id
          and cp.fluxo_rank = 1
        where (f.fluxo_dataregistro > cp.fluxo_dataregistro)
           or cp.fluxo_id is null
        group by
          f.artigo_id,
          f.espaco_id,
          cp.fluxo_quantidadefinal
    ) select
          s.espaco_id,
          s.artigo_id,
          s.credito - s.debigo as stock
        from __sumary s
    ;
  $$;


--
-- TOC entry 761 (class 1255 OID 16899)
-- Name: __generate_acerto_code(uuid, uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_acerto_code(brc uuid, user_brc uuid DEFAULT NULL::uuid, space_brc uuid DEFAULT NULL::uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _code character varying;
  _len int default 6;
begin
  _cluster := cluster._get_cluster_local();
  brc := coalesce( brc, tweeks.__branch_uid( user_brc, space_brc ));

  while _code is null loop
      _code := cluster.next( 'acerto.code/seq', sub := brc::text, lpad := _len, lpad_char := '0' );
      if( exists(
          select *
          from tweeks.acerto c
          where c.acerto_codigo = _code
            and c._branch_uid = coalesce( brc, c._branch_uid )
        )) then
        _code := null;
      end if;
    end loop;
  return _code;
end;
$$;


--
-- TOC entry 762 (class 1255 OID 16900)
-- Name: __generate_artigo_code(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_artigo_code(arg_classe_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _classe tweeks.classe;
  _cluster cluster.cluster;
  code character varying;
begin
  _cluster := cluster._get_cluster_local();

  while code is null loop
    update tweeks.classe
      set classe_lastcodigo = classe.classe_lastcodigo +1
      where classe_id = arg_classe_id
      returning * into _classe
    ;

    code := lib.str_nospace( format( '%s%s%s',
      _cluster.cluster_code,
      "right"( _classe.classe_codigo, 2 ),
      greatest( _classe.classe_codigo::text, lpad( _classe.classe_codigo, 2, '0') )
    ));

    if( exists(
      select *
        from tweeks.artigo a
        where a.artigo_codigo = code
          and a._branch_uid = _classe._branch_uid
    )) then code := null; end if;
  end loop;

  return code;
end;
$$;


--
-- TOC entry 770 (class 1255 OID 16901)
-- Name: __generate_caixa_code(uuid, uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_caixa_code(brc uuid, user_brc uuid DEFAULT NULL::uuid, space_brc uuid DEFAULT NULL::uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _code character varying;
  _len int default 6;
begin
  _cluster := cluster._get_cluster_local();
  brc := coalesce( brc, tweeks.__branch_uid( user_brc, space_brc ));

  while _code is null loop
      _code := cluster.next( 'caixa.code/seq', sub := brc::text, lpad := _len, lpad_char := '0' );
      if( exists(
          select *
          from tweeks.caixa c
          where c.caixa_code = _code
            and c._branch_uid = coalesce( brc, c._branch_uid )
        )) then
        _code := null;
      end if;
    end loop;
  return _code;
end;
$$;


--
-- TOC entry 771 (class 1255 OID 16902)
-- Name: __generate_classe_code(uuid, uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_classe_code(brc uuid, user_brc uuid, space_brc uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _code character varying;
  _len int default 3;
begin
  _cluster := cluster._get_cluster_local();
  brc := coalesce( brc, tweeks.__branch_uid( user_brc, space_brc ));

  while _code is null loop
    _code := cluster.next( 'artigo.code/seq', sub := brc::text, lpad := _len, lpad_char := '0' );
    if( exists(
      select *
        from tweeks.classe c
        where c.classe_codigo = _code
          and c._branch_uid = coalesce( brc, c._branch_uid )
    )) then
      _code := null;
    end if;
  end loop;

  return _code;
end;
$$;


--
-- TOC entry 772 (class 1255 OID 16903)
-- Name: __generate_cliente_code(uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_cliente_code(colaborador uuid, espaco uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  code character varying;
  repeate integer default 0;
  codeLen integer default 4;
  _cluster cluster.cluster;
  _branch uuid default tweeks.__branch_uid( colaborador, espaco );
begin
  _cluster := cluster._get_cluster_local();

  while code is null loop
      code := cluster.next( 'client/seq', lpad := codeLen, lpad_char := '0', sub := _branch::text  );
    if exists(
        select *
          from tweeks.cliente c
          where  code = c.cliente_code
    ) then
      code := null;
    end if;
    repeate := repeate +1;
  end loop;
  return code;
end;
$$;


--
-- TOC entry 773 (class 1255 OID 16904)
-- Name: __generate_fornecedor_code(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_fornecedor_code(_branch uuid) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  __fornecedor_code text;
begin
  while __fornecedor_code is null loop
      __fornecedor_code := cluster.next( 'fornecedor/seq', lpad := 2, lpad_char := '0', sub :=  _branch::text );
      if exists(
          select *
          from tweeks.fornecedor f
          where f.fornecedor_code = __fornecedor_code
        ) then
        __fornecedor_code := null;
      end if;
    end loop;

  return  __fornecedor_code;
end;
$$;


--
-- TOC entry 768 (class 1255 OID 16905)
-- Name: __generate_guia_code(uuid, integer); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_guia_code(_branch uuid, toperacao_id integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  __guia_code text;
begin
    while __guia_code is null loop
        __guia_code := cluster.next( format( 'guia|%s', toperacao_id ), sub := _branch::text, lpad := 4, lpad_char := '0' );
        if exists(
            select *
            from tweeks.guia g
            where g.guia_numero = __guia_code
              and g.guia_toperacao_id = toperacao_id
              and g._braunc_uid = _branch
          ) then
          __guia_code := null;
        end if;
      end loop;
    return  __guia_code;
  end;
$$;


--
-- TOC entry 757 (class 1255 OID 16906)
-- Name: __generate_posto_chave(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_posto_chave() RETURNS text
    LANGUAGE plpgsql
    AS $_$
    declare
      chars character varying default 'abcdefghijklmnopqrstuvwxyz'||upper('abcdefghijklmnopqrstuvwxyz')||'0123456789'||'$#%';
      _posto_chave varchar;
    begin
      _posto_chave := lib.dset_random_text( chars, (2^8)::int )::character varying;
      return _posto_chave;
    end;
    $_$;


--
-- TOC entry 774 (class 1255 OID 16907)
-- Name: __generate_retalho_code(uuid, uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__generate_retalho_code(brc uuid, user_brc uuid DEFAULT NULL::uuid, space_brc uuid DEFAULT NULL::uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  _cluster cluster.cluster;
  _code character varying;
  _len int default 6;
begin
  _cluster := cluster._get_cluster_local();
  brc := coalesce( brc, tweeks.__branch_uid( user_brc, space_brc ));

  while _code is null loop
      _code := cluster.next( 'retalho.code/seq', sub := brc::text, lpad := _len, lpad_char := '0' );
      if( exists(
          select *
          from tweeks.retalho c
          where c.retalho_codigo = _code
            and c._branch_uid = coalesce( brc, c._branch_uid )
        )) then
        _code := null;
      end if;
    end loop;
  return _code;
end;
$$;


--
-- TOC entry 248 (class 1259 OID 16908)
-- Name: autorizacao; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.autorizacao (
    autorizacao_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    autorizacao_colaborador_uid uuid NOT NULL,
    autorizacao_colaborador_atualizacao uuid,
    autorizacao_espaco_auth uuid NOT NULL,
    autorizacao_espaco_uid uuid NOT NULL,
    autorizacao_designacao character varying NOT NULL,
    autorizacao_ano integer NOT NULL,
    autorizacao_numero character varying,
    autorizacao_estado smallint DEFAULT (map.get('maguita_autorizacao_estado_ativo'::name))::smallint NOT NULL,
    autorizacao_dataregistro timestamp without time zone DEFAULT now() NOT NULL,
    autorizacao_dataatualizacao timestamp without time zone,
    _branch_uid uuid NOT NULL
);


--
-- TOC entry 775 (class 1255 OID 16916)
-- Name: __get_autorizacao(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__get_autorizacao(uuid) RETURNS tweeks.autorizacao
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    select * from tweeks.autorizacao where autorizacao_uid = $1;
$_$;


--
-- TOC entry 249 (class 1259 OID 16917)
-- Name: branch; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.branch (
    branch_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    branch_tbranch_id smallint NOT NULL,
    branch_name character varying NOT NULL,
    branch_path character varying NOT NULL,
    branch_user jsonb,
    branch_workspace jsonb,
    branch_licence jsonb,
    branch_grants jsonb,
    branch_main_user uuid,
    branch_main_workspace uuid,
    branch_clusters character varying[] NOT NULL,
    branch_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    branch_update timestamp with time zone,
    branch_state smallint,
    _branch_uid uuid GENERATED ALWAYS AS (branch_uid) STORED
);


--
-- TOC entry 776 (class 1255 OID 16925)
-- Name: __get_branch(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__get_branch(uuid) RETURNS cluster.branch
    LANGUAGE sql
    AS $_$select * from tweeks.branch b where b.branch_uid = $1 $_$;


--
-- TOC entry 250 (class 1259 OID 16926)
-- Name: serie; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.serie (
    serie_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    serie_sequencia bigint DEFAULT 0 NOT NULL,
    serie_tserie_id smallint NOT NULL,
    serie_espaco_id uuid NOT NULL,
    serie_espaco_auth uuid NOT NULL,
    serie_colaborador_id uuid NOT NULL,
    serie_colaborador_atualizacao uuid,
    serie_designacao character varying NOT NULL,
    serie_numero character varying NOT NULL,
    serie_quantidade integer NOT NULL,
    serie_estado smallint DEFAULT (map.get('maguita_serie_estado_ativo'::name))::smallint NOT NULL,
    serie_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    serie_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    serie_numatorizacao character varying,
    serie_numcertificacao character varying,
    serie_autorizacao_uid uuid,
    serie_fechoautorizacao boolean DEFAULT false NOT NULL
);


--
-- TOC entry 777 (class 1255 OID 16936)
-- Name: __get_serie_espaco(uuid, integer); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__get_serie_espaco(arg_espaco_auth uuid, arg_tserie integer) RETURNS SETOF tweeks.serie
    LANGUAGE plpgsql STRICT
    AS $$
declare
    _const map.constant;
begin
    return query
    select * from tweeks.serie s
    where s.serie_espaco_id = arg_espaco_auth::uuid
      and s.serie_tserie_id = arg_tserie::int2
    limit 1;
end;
$$;


--
-- TOC entry 778 (class 1255 OID 16937)
-- Name: __infinity_loop(tweeks.espaco); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__infinity_loop(_espaco tweeks.espaco) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
declare
  __loop record;
begin
  with recursive __espaco as (
    select
        e.espaco_id,
        e.espaco_espaco_id,
        e.espaco_nome,
        _espaco.espaco_id as find
      from tweeks.espaco e
  ), __infinite_lop as (
    select e.*, array[]::uuid[] as family from __espaco e
    union all
      select _es.*, _c.family || _es.espaco_id
        from __espaco _es
          inner join __infinite_lop _c on _es.espaco_id = _c.espaco_espaco_id
        where _es.espaco_id != all( _c.family )
  ) select * into __loop
    from __infinite_lop c
    where c.espaco_id  = c.find
      and c.espaco_id = any( c.family )
  ;

  if __loop.espaco_id is null then __loop := null; end if;
  return to_jsonb( __loop );

end;
$$;


--
-- TOC entry 779 (class 1255 OID 16938)
-- Name: __lancamento_regularizacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__lancamento_regularizacao(args jsonb DEFAULT NULL::jsonb) RETURNS TABLE(ordem bigint, ordem_grupo bigint, cd character varying, credito double precision, debito double precision, valor double precision, entrada double precision, saldo double precision, resumo boolean, acomulacao double precision, regula_acumulacao double precision, regula_montante double precision, regula numeric[], regula_id uuid[], regula_refid uuid[], cliente_id uuid, tgrupo_id smallint, lancamento_id uuid, lancamento_refid uuid, lancamento_ref jsonb, lancamento_class character varying, lancamento_doc character varying, lancamento_data date, lancamento_time timestamp with time zone, lancamento_sequencia bigint)
    LANGUAGE plpgsql
    AS $$
declare
    arg_cliente_id uuid default args->>'cliente_id';
    arg_tgropu_id int2 default args->>'tgrupo_id';
    arg_branch_uid uuid default args->>'_braunc_uid';
    arg_resumo boolean default args->>'resumo';
  begin
    arg_resumo := coalesce( arg_resumo, false );
    return query
      with recursive _const as ( select * from map.constant() ),
        __lancamento as (
        select
            row_number() over ( partition by la.lancamento_cliente_id, la._branch_uid, la._tgrupo_id order by la.lancamento_dataregistro, la.lancamento_sequencia ) as ordem,
            count(*) over ( partition by la.lancamento_cliente_id, la._branch_uid, la._tgrupo_id) as counts,
            la.lancamento_valor * la.lancamento_operacao as entrada,
            la.lancamento_valor as valor,
            la.lancamento_credito as credito,
            la.lancamento_debito as debito,
            la.lancamento_cliente_id as cliente,
            la._tgrupo_id as grupo,
            la._branch_uid as branch,
            la.lancamento_id as id,
            la.lancamento_refid as refid,
            case
              when la.lancamento_operacao = -1 then 'D'
              when la.lancamento_operacao = 1 then 'C'
            end::character varying as cd,
            la as _lan
          from tweeks.lancamento la
            inner join _const _c on la.lancamento_estado = _c.maguita_lancamento_estado_ativo
          where la.lancamento_cliente_id = coalesce( arg_cliente_id, la.lancamento_cliente_id )
            and la._branch_uid = coalesce( arg_branch_uid, la._branch_uid )
            and la._tgrupo_id = coalesce( arg_tgropu_id, la._tgrupo_id )
          order by la.lancamento_dataregistro,
            la.lancamento_sequencia
      ), __sequence as (
        select  _l.*,
            _l.entrada as saldo,
            1::int8 as ordem_tipo,
            case
              when _l.cd = 'D' then _l.ordem
              else 0
            end seq_debito,
            case
              when _l.cd = 'C' then _l.ordem
              else 0
            end seq_credito
          from __lancamento _l
          where _l.ordem = 1
          union all
            select _l.*,
               s.saldo + _l.entrada,
               case
                 when _l.cd = 'D' then s.seq_debito +1
                 else s.seq_credito +1
                end,
              case
                when _l.cd = 'D' then s.seq_debito +1
                else s.seq_debito
              end,
              case
                when _l.cd = 'C' then s.seq_credito +1
                else s.seq_credito
              end
              from __sequence s
                inner join __lancamento _l on s.ordem + 1 = _l.ordem
                  and _l.cliente = s.cliente
                  and  _l.branch = s.branch
                  and  _l.grupo = s.grupo
      ), __acomulacao as (
        select s.*,
            0::double precision as previewac,
            s.valor as acomulacao
          from __sequence s
          where s.ordem_tipo = 1
        union all
          select s.*,
            sp.valor + ac.previewac as preview,
            s.valor  + ac.acomulacao
        from __acomulacao ac
          inner join __sequence s on ac.ordem_tipo + 1 = s.ordem_tipo
            and ac.cd = s.cd
            and ac.cliente = s.cliente
            and ac.branch = s.branch
            and ac.grupo = s.grupo
          left join __sequence sp on sp.cd = s.cd
            and s.ordem_tipo - 1 = sp.ordem_tipo
            and s.cliente = sp.cliente
            and s.branch = sp.branch
            and s.grupo = sp.grupo
      ), __regularizacao as (
      select
            array_agg(_reg.valor::numeric order by _reg.ordem ) filter ( where _reg.valor is not null ) regularizacao,
            array_agg(_reg.id order by _reg.ordem ) filter ( where _reg.valor is not null  ) regularizacao_id,
            array_agg(_reg.refid order by _reg.ordem ) filter ( where _reg.valor is not null )  regularizacao_refid,
            max( _reg.acomulacao )  regularizacao_acomulacao,
          _lanc
        from __acomulacao _lanc
          left join __acomulacao _reg on _reg.cd != _lanc.cd
            and _lanc.cliente = _reg.cliente
            and _lanc.branch = _reg.branch
            and _lanc.grupo = _reg.grupo
            and _reg.previewac < _lanc.acomulacao
            and _reg.acomulacao > _lanc.previewac
      group by _lanc
      ) select
          ( _lanc ).ordem,
          ( _lanc ).ordem_tipo,
          ( _lanc ).cd,
          ( _lanc ).credito,
          ( _lanc ).debito,
          ( _lanc ).valor,
          ( _lanc ).entrada,
          ( _lanc ).saldo,
          ( _lanc ).counts = ( _lanc ).ordem as resumo,
           --- AGUI
          ( _lanc ).acomulacao,
          ( coalesce(_reg.regularizacao_acomulacao, lag( _reg.regularizacao_acomulacao , 1 ) over ()) ) as acomulacao,
          case
            when coalesce( regularizacao_acomulacao, lag( regularizacao_acomulacao, 1 ) over () ) - ( _lanc ).acomulacao >= 0 then ( _lanc ).valor
            when coalesce( regularizacao_acomulacao, lag( regularizacao_acomulacao, 1 ) over () ) - ( _lanc ).acomulacao  < 0
            and ( coalesce( regularizacao_acomulacao, lag( regularizacao_acomulacao, 1 ) over () ) - ( _lanc ).acomulacao ) * -1 < ( _lanc ).valor
            then ( _lanc ).valor +  (coalesce( regularizacao_acomulacao, lag( regularizacao_acomulacao, 1 ) over () ) - ( _lanc ).acomulacao)
            else 0
          end as regulado,
          _reg.regularizacao,
          _reg.regularizacao_id,
          _reg.regularizacao_refid,

          ( _lanc ).cliente,
          ((_lanc)._lan )._tgrupo_id,
          ((_lanc)._lan ).lancamento_id,
          ((_lanc)._lan ).lancamento_refid,
          ((_lanc)._lan ).lancamento_referencia,
          ((_lanc)._lan ).lancamento_regclass,
          ((_lanc)._lan ).lancamento_documento,
          ((_lanc)._lan ).lancamento_data,
          ((_lanc)._lan ).lancamento_dataregistro,
          ((_lanc)._lan ).lancamento_sequencia
        from __regularizacao _reg
          where not arg_resumo or  ( _lanc ).counts = ( _lanc ).ordem
        order by
          ( _lanc ).cliente,
          ( _lanc ).grupo,
          ( _lanc ).branch,
          ( _lanc ).ordem
    ;
  end;
$$;


--
-- TOC entry 781 (class 1255 OID 16940)
-- Name: __load_cambio_day(uuid, smallint, date, map.constant); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__load_cambio_day(arg_espaco_auth uuid, arg_currency_id smallint, arg_cambio_data date, _const map.constant DEFAULT map.constant()) RETURNS TABLE(cambio_id uuid, cambio_taxa numeric, cambio_data date, cambio_estado smallint, cambio_dataregistro timestamp with time zone)
    LANGUAGE sql
    AS $$
  select
      cb.cambio_id,
      cb.cambio_taxa,
      cb.cambio_data,
      cb.cambio_estado,
      cb.cambio_dataatualizacao
    from tweeks.cambio cb
    where cb.cambio_currency_id = arg_currency_id
      and cb.cambio_data <= coalesce( arg_cambio_data, current_date )
      and cb.cambio_estado != _const.maguita_cambio_estado_anulado
      and cb.cambio_espaco_auth = arg_espaco_auth
    order by cb.cambio_dataregistro desc
    limit 1;
$$;


--
-- TOC entry 782 (class 1255 OID 16941)
-- Name: __lote(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__lote(args jsonb) RETURNS TABLE(espaco_id uuid, artigo_id uuid, lote_numero character varying, lote_validade date, lote_ref jsonb, lote_refuid uuid, lote_refclass character varying, lote_entrada double precision, lote_saida double precision)
    LANGUAGE plpgsql
    AS $$
declare
  arg_colaborador_id uuid default args->>'colaborador_id';
  arg_espaco_auth uuid default args->>'espaco_auth';
  arg_espaco_armazem uuid default args->>'espaco_armazem';
  arg_artigo_id uuid default args->>'artigo_id';
  arg_with_reference boolean default args->>'withRef';
  _branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
begin
  arg_with_reference := coalesce( arg_with_reference, false );
  _const := map.constant();
  return query with __lote_entrada as (
    select
        e.entrada_espaco_destino as espaco_id,
        e.entrada_artigo_id as artigo_id,
        e.entrada_lote as lote_numero,
        e.entrada_validade as lote_validade,
        e.entrada_quantidade as lote_entrada,
        0::double precision as lote_saida,
        case when arg_with_reference then lib.sets_ref( e ) end as lote_ref,
        case when arg_with_reference then e.entrada_id end as lote_refuid,
        case when arg_with_reference then cluster.__format( e.TABLEOID ) end as lote_refclass
      from tweeks.entrada e
      where true
--         and e.entrada_lote is not null
--         and e.entrada_validade is not null
        and e._branch_uid = _branch

        and e.entrada_estado = _const.entrada_estado_ativo
        and e.entrada_espaco_destino = coalesce( arg_espaco_armazem, e.entrada_espaco_destino )
        and e.entrada_artigo_id = coalesce( arg_artigo_id, e.entrada_artigo_id )
    union all
      select
          e.transferencia_espaco_destino,
          e.transferencia_artigo_id,
          e.transferencia_lote,
          e.transferencia_validade,
          0::double precision lote_entrada,
          e.transferencia_quantidade as lote_saida,
          case when arg_with_reference then lib.sets_ref( e ) end as lote_ref,
          case when arg_with_reference then e.transferencia_id end as lote_refuid,
          case when arg_with_reference then cluster.__format( e.TABLEOID ) end as lote_refclass
        from tweeks.transferencia e
        where true
--           and e.transferencia_lote is not null
--           and e.transferencia_validade is not null
          and e._branch_uid = _branch

          and e.transferencia_estado = _const.transferencia_estado_ativo
          and e.transferencia_espaco_destino = coalesce( arg_espaco_armazem, e.transferencia_espaco_destino )
          and e.transferencia_artigo_id = coalesce( arg_artigo_id, e.transferencia_artigo_id )

  ), __lote_saida as (
    select
        e.venda_espaco_auth as espaco_id,
        e.venda_artigo_id as artigo_id,
        e.venda_lote as lote_numero,
        e.venda_validade as lote_validade,
        e.venda_quantidade as lote_entrada,
        0::double precision as lote_saida,
        case when arg_with_reference then lib.sets_ref( e ) end as lote_ref,
        case when arg_with_reference then e.venda_id end as lote_refuid,
        case when arg_with_reference then cluster.__format( e.TABLEOID ) end as lote_refclass
      from tweeks.venda e
      where true
--         and e.venda_lote is not null
--         and e.venda_validade is not null
        and e._branch_uid = _branch

        and e.venda_estado not in ( _const.maguita_venda_estado_anulado, _const.maguita_venda_estado_canselado )
        and e.venda_espaco_auth = coalesce( arg_espaco_armazem, e.venda_artigo_id )
        and e.venda_artigo_id = coalesce( arg_artigo_id, e.venda_artigo_id )
    union all
      select
          e.transferencia_espaco_origem,
          e.transferencia_artigo_id,
          e.transferencia_lote,
          e.transferencia_validade,
          0::double precision lote_entrada,
          e.transferencia_quantidade as lote_saida,
          case when arg_with_reference then lib.sets_ref( e ) end as lote_ref,
          case when arg_with_reference then e.transferencia_id end as lote_refuid,
          case when arg_with_reference then cluster.__format( e.TABLEOID ) end as lote_refclass
        from tweeks.transferencia e
        where true
--           and e.transferencia_lote is not null
--           and e.transferencia_validade is not null
          and e._branch_uid = _branch

          and e.transferencia_estado = _const.transferencia_estado_ativo
          and e.transferencia_espaco_origem = coalesce( arg_espaco_armazem, e.transferencia_espaco_origem )
          and e.transferencia_artigo_id = coalesce( arg_artigo_id, e.transferencia_artigo_id )
  ), __lote as (
    select
        coalesce( le.espaco_id, ls.espaco_id ) as espaco_id,
        coalesce( le.artigo_id, ls.artigo_id ) as atrigo_id,
        coalesce( le.lote_numero, ls.lote_numero ) as lote_numero,
        coalesce( le.lote_validade, ls.lote_validade ) as lote_validade,
        coalesce( le.lote_entrada, ls.lote_entrada, 0.0 ) as lote_entrada,
        coalesce( le.lote_saida, ls.lote_saida, 0.0 ) as lote_saida,
        coalesce( le.lote_ref, ls.lote_ref ) as lote_ref,
        coalesce( le.lote_refuid, ls.lote_refuid ) as lote_refuid,
        coalesce( le.lote_refclass, ls.lote_refclass ) as lote_refclass
      from __lote_entrada le
        full join __lote_saida ls on le.artigo_id = ls.artigo_id
          and le.espaco_id = ls.espaco_id
          and le.lote_numero = ls.lote_numero
          and le.lote_validade = ls.lote_validade
  ), __filter as (
    select
        _l.espaco_id,
        _l.atrigo_id,
        _l.lote_numero,
        _l.lote_validade,
        _l.lote_ref,
        _l.lote_refuid,
        _l.lote_refclass,
        sum( _l.lote_entrada ) lote_entrada,
        sum( _l.lote_saida ) lote_saida
      from __lote _l
      group by _l.espaco_id,
        _l.atrigo_id,
        _l.lote_numero,
        _l.lote_validade,
        _l.lote_ref,
        _l.lote_refuid,
        _l.lote_refclass
  ) select _l.*
      from __filter _l;
end;
$$;


--
-- TOC entry 783 (class 1255 OID 16942)
-- Name: __precario(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__precario(jsonb) RETURNS TABLE(precario_custo double precision, precario_quantidade double precision)
    LANGUAGE sql IMMUTABLE
    AS $_$
  select ($1->>'precario_custo')::double precision,
         ($1->>'precario_quantidade')::double precision
$_$;


--
-- TOC entry 785 (class 1255 OID 16943)
-- Name: __sets_generate_documento(uuid, integer); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__sets_generate_documento(arg_espaco_auth uuid, arg_tserie integer) RETURNS TABLE(document character varying, serie_id uuid, serie_numero character varying, serie_numatorizacao character varying, serie_numcertificacao character varying, serie_sequencia bigint, serie_quantidade bigint, autorizacao_uid uuid, autorizacao_ano integer, autorizacao_numero character varying)
    LANGUAGE plpgsql STRICT
    AS $$
declare
  _serie tweeks.serie;
  _numero_documento varchar;
  ___branch uuid default tweeks.__branch_uid( null, arg_espaco_auth );
  _const map.constant;
  _espaco tweeks.espaco;
  _tserie tweeks.tserie;
  _iterate int default 0;
  _autorizacao tweeks.autorizacao;
begin
    _const := map.constant();

    select * into _tserie
      from tweeks.tserie ts
      where ts.tserie_id = arg_tserie
    ;

    -- Obter o espaço superior que pode gerar numero de seire
    with recursive __espaco as (
      select e.*, e.espaco_gerarfatura as __generate_serie
      from tweeks.espaco e
      where e.espaco_id =arg_espaco_auth
      union all
      select w.*, w.espaco_gerarfatura
        from __espaco _e
          inner join tweeks.espaco w on _e.espaco_espaco_id = w.espaco_id
        and not _e.__generate_serie
    ) select * into _espaco from __espaco __e
      where __e.__generate_serie
    ;

    while _numero_documento is null loop
      update tweeks.serie s
        set serie_sequencia = s.serie_sequencia +1
        from tweeks.autorizacao a
        where s.serie_autorizacao_uid = a.autorizacao_uid
          and s._branch_uid = ___branch
          and a._branch_uid = ___branch
          and s.serie_espaco_id = _espaco.espaco_id
          and s.serie_tserie_id = arg_tserie
          and s.serie_estado = _const.maguita_serie_estado_ativo
          and a.autorizacao_estado = _const.maguita_autorizacao_estado_ativo
          and a.autorizacao_ano = extract( years from now() )::int
        returning * into _serie
      ;

      if _serie.serie_id is null then
        raise exception 'Nenhuma serie disponivel para gerar a sequencia!';
      end if;

      if length( _serie.serie_sequencia::text ) > _tserie.tserie_seqlimit::int then
        raise exception 'O numero de sequencia excede o tamanho maximo definido para e seire';
      end if;

      _autorizacao := tweeks.__get_autorizacao( _serie.serie_autorizacao_uid );

      -- ex: FT0000119000001
      -- TIPO|FIXA|ANO|SEQUENCIA
      _numero_documento := format(
        '%s%s%s%s',
        _tserie.tserie_code, --TYPE
        lpad( "left"( _serie.serie_numero, _tserie.tserie_numlimit-2), _tserie.tserie_numlimit-2, '0'), --FIXA
        to_char( make_date( _autorizacao.autorizacao_ano, 1, 1 ), 'yy' ), --YEAR
        lpad( _serie.serie_sequencia::text, _tserie.tserie_seqlimit::int,  '0' ) --SEQUENCE
      );

      if _tserie.tserie_id in ( _const.maguita_tserie_fatura, _const.maguita_tserie_faturarecibo )
        and exists(
          select *
            from tweeks.conta c
            where c.conta_numerofatura = _numero_documento
              and c._branch_uid = ___branch
      ) then
        _numero_documento := null;
      end if;

      if _numero_documento is not null
        and _tserie.tserie_id in ( _const.maguita_tserie_recibo, _const.maguita_tserie_faturarecibo )
        and exists(
          select *
            from tweeks.deposito de
            where de.deposito_documento = _numero_documento
              and de._branch_uid = ___branch
      ) then
        _numero_documento := null;
      end if;
      _iterate := _iterate +1;

      if _iterate = 1000 then
        raise exception 'Exedeu o limite de tentativa para geração de numero de serie, por favor proucure pelo suporte.';
      end if;
    end loop;

    __sets_generate_documento.document := _numero_documento;
    __sets_generate_documento.serie_id := _serie.serie_id;
    __sets_generate_documento.serie_sequencia := _serie.serie_sequencia;
    __sets_generate_documento.serie_numero := _serie.serie_numero;
    __sets_generate_documento.serie_quantidade := _serie.serie_quantidade;
    __sets_generate_documento.serie_numatorizacao := _serie.serie_numatorizacao;
    __sets_generate_documento.serie_numcertificacao := _serie.serie_numcertificacao;
    __sets_generate_documento.autorizacao_uid := _autorizacao.autorizacao_uid;
    __sets_generate_documento.autorizacao_ano := _autorizacao.autorizacao_ano;
    __sets_generate_documento.autorizacao_numero := _autorizacao.autorizacao_numero;

    return next;
end;
$$;


--
-- TOC entry 786 (class 1255 OID 16944)
-- Name: __sync_branch_map(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__sync_branch_map() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
declare
  __branch_auto regprocedure default 'tweeks.__tg_use_branch()'::regprocedure;
  _tg record;
  _data record;
  _base_name text;
  _trigger_name text;
  _statement text;
begin
  for _tg in
    select
      tg.tgrelid::regclass::text as share_regclass,
      tg.tgname as trigger_name,
      tg.*
    from pg_trigger tg
    where tg.tgfoid in( __branch_auto )
    loop
        _statement  :=  format( 'drop trigger %I on %s', _tg.trigger_name, _tg.share_regclass );
        return next _statement;
      begin
        execute _statement;
      exception when others then null;
      end;
  end loop;

  for _tg in
    select *
    from tweeks.branchmap _b
  loop
    --language=PostgreSQL
    _statement := $sql$
      alter table __schema_name.__table_name add column if not exists _branch_uid uuid;
    $sql$;
    _statement := replace( _statement, '__schema_name', '%I' );
    _statement := replace( _statement, '__table_name', '%I' );
    _statement := format( _statement, _tg.map_sch, _tg.map_tbl );
    return next _statement;
--     begin
      execute _statement;
--     exception when others then null; end;

 end loop;

  for _tg in
    with __when ( class, schema, tbl, _tg_op, _procedure ) as (
      select  _b.class, _b.map_sch, _b.map_tbl, 'insert', __branch_auto from tweeks.branchmap _b
      union all select  _b.class, _b.map_sch, _b.map_tbl, 'update',  __branch_auto from tweeks.branchmap _b
    ) select *
    from __when w
    loop
      select array_agg( tgname ) as triggers into _data
        from pg_trigger tg
        where tg.tgrelid::regclass = _tg.class::regclass
      ;

      _base_name := format( 'sync_branch_map_before_%s_on_%s_%s', _tg._tg_op, _tg.schema, _tg.tbl );

      _trigger_name := format( '%s_%s', _base_name, ( random() * (999999 - 100000 )+100000)::int );
      while _trigger_name = any( _data.triggers ) loop
        _trigger_name := format( '%s_%s', _base_name, ( random() * (999999 - 100000 )+100000)::int );
      end loop;

      --language=PostgreSQL
      _statement := $sql$
        create trigger _tg_name
          before delete
          on _table_name
          for each row
          when ( not cluster.__is_replication() )
        execute procedure _use_procedure
      ;
      $sql$;

      _statement := replace( _statement, '_tg_name', '%I' );
      _statement := replace( _statement, 'delete', '%s' );
      _statement := replace( _statement, '_table_name', '%s' );
      _statement := replace( _statement, '_use_procedure', '%s' );
      _statement := format( _statement, _trigger_name, _tg._tg_op, _tg.class, _tg._procedure );

      begin
        execute _statement;
      return next _statement;
      exception when others then null;
      end;
    end loop;
end;
$_$;


--
-- TOC entry 594 (class 1255 OID 16945)
-- Name: __tg_before_update_classe(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_before_update_classe() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
begin
  if new.classe_codigo is null then
    new.classe_codigo := tweeks.__generate_classe_code(
      new._branch_uid,
      new.classe_colaborador_id,
      new.classe_espaco_auth
    );
  end if;
  return new;
end;
$$;


--
-- TOC entry 787 (class 1255 OID 16946)
-- Name: __tg_conta_after_close(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_conta_after_close() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare

  _new tweeks.conta;
  _old tweeks.conta;
  _const map.constant;
begin
  if cluster.__is_replication() then
    return null;
  end if;

  _new := new;
  _old := old;
  _const := map.constant();

  if _new.conta_estado != _old.conta_estado and _new.conta_estado in (
    _const.maguita_conta_estado_fechado,
    _const.maguita_conta_estado_anulado
  ) then
    update tweeks.venda
      set venda_estado = case
            when _new.conta_estado = _const.maguita_conta_estado_fechado then _const.maguita_venda_estado_fechado
            when _new.conta_estado = _const.maguita_conta_estado_anulado then _const.maguita_venda_estado_anulado
        end
      where venda_estado = _const.maguita_venda_estado_aberto
        and venda_conta_id = _old.conta_id;
  end if;

  return null;
end;
$$;


--
-- TOC entry 505 (class 1255 OID 16947)
-- Name: __tg_create_lancamento(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_create_lancamento() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _deposito tweeks.deposito;
  _conta tweeks.conta;
  _conta_old tweeks.conta;
  _const map.constant;
  _lancamento tweeks.lancamento;
  _data record;
  _conta_data record;
begin

  --Abortar o trigger quando for conexão com utilizador de replicação
  if cluster.__is_replication() then
    return null;
  end if;

  _const := map.constant();

  if pg_typeof( new ) = pg_typeof( _deposito ) and tg_op = 'INSERT' then
    _deposito :=  new;
    select * into _data from tweeks.tpaga where tpaga_id = _deposito.deposito_tpaga_id;

    _lancamento.lancamento_tlancamento_id := _const.maguita_tlancamento_deposito;
    _lancamento._tgrupo_id := _deposito._tgrupo_id;
    _lancamento.lancamento_refid := _deposito.deposito_id;
    _lancamento.lancamento_regclass := cluster.__format( pg_typeof( _deposito )::text::regclass );
    _lancamento.lancamento_valor := _deposito.deposito_montantefinal;
    _lancamento.lancamento_operacao := 1;
    _lancamento.lancamento_cliente_id := _deposito.deposito_cliente_id;
    _lancamento.lancamento_espaco_auth := _deposito.deposito_espaco_auth;
    _lancamento.lancamento_colaborador_id := _deposito.deposito_colaborador_id;
    _lancamento.lancamento_data := _deposito.deposito_data;
    _lancamento.lancamento_descricao := case
      when _deposito.deposito_docref is not null then format( 'Lançamente de deposito na conta em modalidade %I usando documento nº %I em %I', _data.tpaga_designacao, _deposito.deposito_docref, _deposito.deposito_data )
      else format( 'Lançamente de deposito na conta em modalidade %I em %I', _data.tpaga_designacao, _deposito.deposito_data )
    end;
    _lancamento.lancamento_documento := _deposito.deposito_documento;
    _lancamento.lancamento_referencia := lib.sets_ref( _deposito );

  elseif pg_typeof( new ) = pg_typeof( _conta ) and tg_op = 'UPDATE' then
    _conta := new;
    _conta_old := old;
    
    select * 
      from tweeks.conta ct 
        inner join tweeks.serie s on ct.conta_serie_id = s.serie_id
        inner join tweeks.tserie ts on s.serie_tserie_id = ts.tserie_id
      where ct.conta_id = _conta.conta_id
      into _conta_data
    ;

    if _conta_old.conta_estado != _conta.conta_estado and _conta.conta_estado = _const.maguita_conta_estado_fechado and not exists(
      select *
        from tweeks.lancamento l
        where l.lancamento_regclass = cluster.__format( pg_typeof(_conta)::text::regclass )
          and l.lancamento_refid = _conta.conta_id
    ) then
      _lancamento.lancamento_tlancamento_id := _const.maguita_tlancamento_conta;
      _lancamento._tgrupo_id := _conta._tgrupo_id;
      _lancamento.lancamento_refid := _conta.conta_id;
      _lancamento.lancamento_regclass := cluster.__format( pg_typeof( _conta )::text::regclass );
      _lancamento.lancamento_valor := _conta.conta_montante;
      _lancamento.lancamento_cliente_id := _conta.conta_cliente_id;
      _lancamento.lancamento_espaco_auth := _conta.conta_espaco_auth;
      _lancamento.lancamento_colaborador_id := coalesce( _conta.conta_colaborador_fecho, _conta.conta_colaborador_atualizacao, _conta.conta_colaborador_id );
      _lancamento.lancamento_data := _conta.conta_data;
      _lancamento.lancamento_descricao := format( 'Lançamento de divida na conta com fatura nº %s', _conta.conta_numerofatura );
      _lancamento.lancamento_operacao := -1;
      
      if _conta_data.tserie_id = _const.maguita_tserie_notacredito then
        _lancamento.lancamento_descricao := format( 'Lançamento de nota de credito na conta com fatura nº %s', _conta.conta_numerofatura );
        _lancamento.lancamento_operacao := 1;
        _lancamento.lancamento_valor := abs( _conta.conta_montante );
      elsif _conta_data.tserie_id in(  _const.maguita_tserie_faturarecibo, _const.maguita_tserie_fatura ) then 
        _lancamento.lancamento_descricao := format( 'Lançamento de divida na conta com fatura nº %s', _conta.conta_numerofatura );
      elsif _conta_data.tserie_id = _const.maguita_tserie_guiasaida then 
        _lancamento.lancamento_descricao := format( 'Lançamento de guia de saida com fatura nº %s', _conta.conta_numerofatura );
      end if;
      
      _lancamento.lancamento_documento := _conta.conta_numerofatura;
      _lancamento.lancamento_referencia := lib.sets_ref( _conta );
    end if;
  end if;

  if _lancamento.lancamento_tlancamento_id is not null then
    _lancamento.lancamento_estado := _const.maguita_lancamento_estado_ativo;
    perform lib.sets( _lancamento );
  end if;

  return null;
end;
$$;


--
-- TOC entry 788 (class 1255 OID 16948)
-- Name: __tg_fluxo_on_acerto(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_fluxo_on_acerto() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new tweeks.acerto;
  _fluxo tweeks.fluxo;
  _const map.constant;
begin

  if cluster.__is_replication() then
    return null;
  end if;

  _const := map.constant();
  _new := new::tweeks.acerto;


  _fluxo.fluxo_toperacao_id := _const.maguita_toperacao_acerto;
  -- AC#3049940
  _fluxo.fluxo_documento := _new.acerto_codigo;
  _fluxo.fluxo_data := null;
  _fluxo.fluxo_referencia := lib.sets_ref(new );
  _fluxo.fluxo_regclass := cluster.__format( pg_typeof( new )::text::regclass );
  _fluxo.fluxo_refuid := _new.acerto_id;

  _fluxo.fluxo_quantidadefinal := _new.acerto_quantidade;
  _fluxo.fluxo_artigo_in := _new.acerto_artigo_id;
  _fluxo.fluxo_espaco_in := _new.acerto_espaco_id;

  _fluxo.fluxo_espaco_auth := _new.acerto_espaco_auth;
  _fluxo.fluxo_colaborador_id := _new.acerto_colaborador_id;
  _fluxo.fluxo_checkpoint := 0;

  perform lib.sets_in( _fluxo );
  return null;
end;
$$;


--
-- TOC entry 784 (class 1255 OID 16949)
-- Name: __tg_fluxo_on_entrada(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_fluxo_on_entrada() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new tweeks.entrada;
  _fluxo tweeks.fluxo;
  _const map.constant;
  _guia record;

begin

  if cluster.__is_replication() then
    return null;
  end if;

  _const := map.constant();
  _new := new;

  select * into _guia
    from tweeks.guia g
    where g.guia_uid = _new.entrada_guia_id
  ;

  _fluxo.fluxo_toperacao_id := _const.maguita_toperacao_entrada;
  _fluxo.fluxo_documento := _guia.guia_documentoperacao ;
  _fluxo.fluxo_data := null;
  _fluxo.fluxo_referencia := lib.sets_ref(new );
  _fluxo.fluxo_regclass := cluster.__format( pg_typeof( new )::text::regclass );

  _fluxo.fluxo_refuid := _new.entrada_id;
  _fluxo.fluxo_quantidadein := _new.entrada_quantidade;
--   _fluxo.fluxo_quantidadeout :=;

  _fluxo.fluxo_artigo_in := _new.entrada_artigo_id;
--   _fluxo.fluxo_artigo_out := ;

--   _fluxo.fluxo_espaco_out := ;
  _fluxo.fluxo_espaco_in := _new.entrada_espaco_destino;

  _fluxo.fluxo_espaco_auth := _new.entrada_espaco_auth;
  _fluxo.fluxo_colaborador_id := _new.entrada_colaborador_id;

  perform lib.sets_in( _fluxo );
  return null;
end;
$$;


--
-- TOC entry 790 (class 1255 OID 16950)
-- Name: __tg_fluxo_on_retalho(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_fluxo_on_retalho() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new tweeks.retalho;
  _fluxo tweeks.fluxo;
  _const map.constant;
begin

  if cluster.__is_replication() then
    return null;
  end if;

  _const := map.constant();
  _new := new;

  _fluxo.fluxo_toperacao_id := _const.maguita_toperacao_retalho;
  _fluxo.fluxo_documento := _new.retalho_codigo;
  _fluxo.fluxo_data := null;
  _fluxo.fluxo_referencia := lib.sets_ref(new );
  _fluxo.fluxo_regclass := cluster.__format( pg_typeof( new )::text::regclass );

  _fluxo.fluxo_refuid := _new.retalho_id;
  _fluxo.fluxo_quantidadeout := _new.retalho_quantidade;
  _fluxo.fluxo_quantidadein := _new.retalho_total;

  _fluxo.fluxo_artigo_out := _new.retalho_artigo_composto;
  _fluxo.fluxo_artigo_in := _new.retalho_artigo_base;

  _fluxo.fluxo_espaco_out := _new.retalho_espaco_auth;
  _fluxo.fluxo_espaco_in  := _new.retalho_espaco_auth;

  _fluxo.fluxo_espaco_auth := _new.retalho_espaco_auth;
  _fluxo.fluxo_colaborador_id := _new.retalho_colaborador_id;

  perform lib.sets_in( _fluxo );
  return null;
end;
$$;


--
-- TOC entry 791 (class 1255 OID 16951)
-- Name: __tg_fluxo_on_transferencia(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_fluxo_on_transferencia() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new tweeks.transferencia;
  _fluxo tweeks.fluxo;
  _const map.constant;
begin

  if cluster.__is_replication() then
    return null;
  end if;

  _const := map.constant();
  _new := new;

  _fluxo.fluxo_toperacao_id := _const.maguita_toperacao_transferencia;
  _fluxo.fluxo_documento := _new.transferencia_documento;
  _fluxo.fluxo_data := null;
  _fluxo.fluxo_referencia := lib.sets_ref(new );
  _fluxo.fluxo_regclass := cluster.__format( pg_typeof( new )::text::regclass );

  _fluxo.fluxo_refuid := _new.transferencia_id;
  _fluxo.fluxo_quantidadein := _new.transferencia_quantidade;
  _fluxo.fluxo_quantidadeout := _new.transferencia_quantidade;

  _fluxo.fluxo_artigo_in := _new.transferencia_artigo_id;
  _fluxo.fluxo_artigo_out := _new.transferencia_artigo_id;

  _fluxo.fluxo_espaco_out := _new.transferencia_espaco_origem;
  _fluxo.fluxo_espaco_in := _new.transferencia_espaco_destino;

  _fluxo.fluxo_espaco_auth := _new.transferencia_espaco_auth;
  _fluxo.fluxo_colaborador_id := _new.transferencia_colaborador_id;

  perform lib.sets_in( _fluxo );
  return null;
end;
$$;


--
-- TOC entry 793 (class 1255 OID 16952)
-- Name: __tg_fluxo_on_venda(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_fluxo_on_venda() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _new tweeks.venda;
  _old tweeks.venda;
  _fluxo tweeks.fluxo;
  _const map.constant;
  _conta tweeks.conta;
begin

  if cluster.__is_replication() then
    return null;
  end if;

  _const := map.constant();
  _new := new;

  _fluxo.fluxo_toperacao_id := _const.maguita_toperacao_venda;
  _fluxo.fluxo_documento := null;
  _fluxo.fluxo_data := null;
  _fluxo.fluxo_referencia := lib.sets_ref(new );
  _fluxo.fluxo_regclass := cluster.__format( pg_typeof( new )::text::regclass );

  _fluxo.fluxo_refuid := _new.venda_id;
  _fluxo.fluxo_quantidadeout := _new.venda_quantidade;

  _fluxo.fluxo_artigo_out := _new.venda_artigo_id;

  _fluxo.fluxo_espaco_out := _new.venda_espaco_auth;

  _fluxo.fluxo_espaco_auth := _new.venda_espaco_auth;
  _fluxo.fluxo_colaborador_id := _new.venda_colaborador_id;

  if tg_op = 'INSERT' then
    perform lib.sets_in( _fluxo );

  elseif tg_op = 'UPDATE' then
    _old := old;

    -- Ao atualizar quantidade do produto no carrinho
    if _new.venda_quantidade != _old.venda_quantidade then
      perform lib.sets_in( _fluxo );
      _fluxo.fluxo_quantidadeout := null;
      _fluxo.fluxo_artigo_out := null;
      _fluxo.fluxo_espaco_out := null;

      _fluxo.fluxo_quantidadein := _old.venda_quantidade;
      _fluxo.fluxo_artigo_in := _old.venda_artigo_id;
      _fluxo.fluxo_espaco_in := _old.venda_espaco_auth;
      _fluxo.fluxo_observacao := format( 'Reposição do artigo no stock por atualização da quantidade na conta' );
      perform lib.sets_in( _fluxo );

      -- Ao canselar um produto do carrinho ou ao anular uma conta
    elseif _old.venda_estado != _new.venda_estado and _new.venda_estado in(
        _const.maguita_venda_estado_anulado,
        _const.maguita_venda_estado_canselado
      )  then
      _fluxo.fluxo_quantidadeout := null;
      _fluxo.fluxo_artigo_out := null;
      _fluxo.fluxo_espaco_out := null;

      _fluxo.fluxo_quantidadein := _old.venda_quantidade;
      _fluxo.fluxo_artigo_in := _old.venda_artigo_id;
      _fluxo.fluxo_espaco_in := _old.venda_espaco_auth;
      _fluxo.fluxo_observacao := format( 'Reposição do artigo no stock por Anulação/Canselamento da conta');
      perform lib.sets_in( _fluxo );

    -- Quando tiver que fechar as vendas definir o documento do fluxo para essa venda
    elseif _old.venda_estado != _new.venda_estado and _new.venda_estado = _const.maguita_venda_estado_fechado then
      _conta := tweeks._get_conta( _old.venda_conta_id );
      update tweeks.fluxo
        set fluxo_documento = _conta.conta_numerofatura
        where fluxo_regclass = cluster.__format( pg_typeof( _new )::text::regclass )
          and (fluxo_referencia->>'venda_id')::uuid = _old.venda_id
      ;
    end if;

  end if;
  return null;
end
$$;


--
-- TOC entry 794 (class 1255 OID 16953)
-- Name: __tg_use_branch(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_use_branch() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  declare
    _class text default cluster.__format( format('%I.%I', tg_table_schema, tg_table_name ) );
    _map record;
    __branch_uid uuid;
    __colaborador_uid uuid;
    __espaco_uid uuid;
  begin

    -- Quando houver branch previeamente definido
    if new._branch_uid is not null then
      return new;
    end if;

    select * into _map
      from tweeks.branchmap b
      where b.class = _class;

    if _map.class is null then return new; end if;
    if _map.map_spc is null and _map.map_usr is null then return new; end if;
    if _map.map_brc is not null then
      new._branch_uid := to_jsonb( new )->>( _map.map_brc );
      return new;
    end if;

    __colaborador_uid := to_jsonb( new )->>( _map.map_usr );
    __espaco_uid := to_jsonb( new )->>( _map.map_spc );

    __branch_uid := tweeks.__branch_uid(__colaborador_uid, __espaco_uid );
    if __branch_uid is not null then
  --       raise exception 'Não pode determinar o branch para o registro, verificar o mapeamento dos branch!';
  --     else
      new._branch_uid := __branch_uid;
    else
  --       raise exception 'USR: % = %, SPC: % = %', _map.map_usr, __colaborador_uid, _map.map_spc, __espaco_uid;
    end if;

    return new;
  end;
$$;


--
-- TOC entry 509 (class 1255 OID 167865)
-- Name: __tg_venda_before_check(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.__tg_venda_before_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  _conta record;
  _artigo record;
  _new tweeks.venda;
begin
  if upper( tg_op ) in ( 'INSERT', 'UPDATE' ) then
    _new := new;
    select *
      from tweeks.conta ct
      where ct.conta_id = _new.venda_conta_id
      into _conta
    ;

    select *
      from tweeks.artigo a
      where a.artigo_id = _new.venda_artigo_id
      into _artigo
    ;
    
    -- Garantir que a quantidade vendida nunca seja de zero
    if new.venda_quantidade = 0 then
      raise exception '%', format('A quantidade de artigo para %I %s não pode ser zero', _artigo.artigo_nome, case
        when _new.venda_descricao != _artigo.artigo_nome then format( 'com descrição %I', _new.venda_descricao )
        else ''
      end) ;
    end if;

    -- Garantir que a quantidade vendida só seja negativa para o caso de conta corrente
    if _new.venda_quantidade < 0 and _conta.conta_conta_docorigin is null then
      raise exception '%', format( 'Não vender o artigo %I %s com quantidade negativa!', _artigo.artigo_nome, case
        when _new.venda_descricao != _artigo.artigo_nome then format( 'com descrição %I', _new.venda_descricao )
        else ''
      end);
    end if;

    return new;
  end if;
end;
$$;


--
-- TOC entry 251 (class 1259 OID 16954)
-- Name: artigo; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.artigo (
    artigo_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    artigo_artigo_id uuid,
    artigo_classe_id uuid NOT NULL,
    artigo_espaco_auth uuid NOT NULL,
    artigo_colaborador_id uuid NOT NULL,
    artigo_colaborador_atualizacao uuid,
    artigo_codigo character varying NOT NULL,
    artigo_nome character varying NOT NULL,
    artigo_preparacao boolean DEFAULT false NOT NULL,
    artigo_foto character varying,
    artigo_descricao character varying,
    artigo_stock double precision DEFAULT 0.0 NOT NULL,
    artigo_stocknegativo boolean DEFAULT false NOT NULL,
    artigo_compostoquantidade double precision,
    artigo_estado smallint DEFAULT (map.get('artigo_estado_ativo'::name))::smallint NOT NULL,
    artigo_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    artigo_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    artigo_codigoimposto character varying,
    artigo_unit_id uuid,
    CONSTRAINT ck_artigo_nome CHECK (lib.str_is_normalized((artigo_nome)::text))
);


--
-- TOC entry 5965 (class 0 OID 0)
-- Dependencies: 251
-- Name: TABLE artigo; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.artigo IS '#Artigo - Essa entidade serve para registrar o astigos que serão vendidos';


--
-- TOC entry 5966 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_id IS 'Identificador único do artigo';


--
-- TOC entry 5967 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_classe_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_classe_id IS 'Identificador da classe a qual pertence o artigo';


--
-- TOC entry 5968 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_colaborador_id IS 'Identificador do colaborador responsavel pelo resistro do artigo';


--
-- TOC entry 5969 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_codigo; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_codigo IS 'Corresponde ao codigo do artigo';


--
-- TOC entry 5970 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_nome; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_nome IS 'Corresponde ao nome do artigo';


--
-- TOC entry 5971 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_preparacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_preparacao IS 'Indica se o artigo tem que ser preparado antes da sua venda';


--
-- TOC entry 5972 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_foto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_foto IS 'Referencia da foto do artigo';


--
-- TOC entry 5973 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_descricao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_descricao IS 'Descrição do artigo';


--
-- TOC entry 5974 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_stocknegativo; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_stocknegativo IS 'Esse atributo indica se o produto pode aceitar stock negativo ou não';


--
-- TOC entry 5975 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_estado IS '
Estado do artigo
<ul>
  <li> 1 - Ativo | O artigo pode ser comercializado </li>
  <li> 0 - Fechado | O artigo não poder ser comercializado nesse estado </li>
</ul>
';


--
-- TOC entry 5976 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_dataregistro IS 'Corresponde ao instante em que o artigo foi registrado do sistema';


--
-- TOC entry 5977 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN artigo.artigo_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.artigo.artigo_dataatualizacao IS 'Corresponde ao instante em que o artigo foi atualizado pela última vez';


--
-- TOC entry 795 (class 1255 OID 16966)
-- Name: _get_artigo(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_artigo(arg_atigo_id uuid) RETURNS tweeks.artigo
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Ess funcao serve para obter uma instancia de artigo
  select * from tweeks.artigo art where art.artigo_id = arg_atigo_id;
$$;


--
-- TOC entry 796 (class 1255 OID 16967)
-- Name: _get_branch_by_colaborador(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_branch_by_colaborador(uuid) RETURNS cluster.branch
    LANGUAGE sql
    AS $_$
select b.*
from tweeks.branch b
       inner join auth.colaborador c on c.colaborador_branch_uid = b.branch_uid
where c.colaborador_id = $1;
$_$;


--
-- TOC entry 797 (class 1255 OID 16968)
-- Name: _get_branch_by_espaco(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_branch_by_espaco(uuid) RETURNS cluster.branch
    LANGUAGE sql
    AS $_$
select b.*
from tweeks.branch b
       inner join tweeks.espaco e on b.branch_uid = e.espaco_branch_uid
where e.espaco_id = $1

$_$;


--
-- TOC entry 252 (class 1259 OID 16969)
-- Name: caixa; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.caixa (
    caixa_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    caixa_posto_id uuid NOT NULL,
    caixa_espaco_auth uuid NOT NULL,
    caixa_colaborador_id uuid NOT NULL,
    caixa_colaborador_atualizacao uuid,
    caixa_montanteinicial double precision NOT NULL,
    caixa_montanteinicialposto double precision,
    caixa_montantefecho double precision,
    caixa_montantefechoposto double precision,
    caixa_quantidadecheque smallint,
    caixa_quantidadechequeposto smallint,
    caixa_observacao character varying,
    caixa_estado smallint DEFAULT (map.get('maguita_caixa_estado_ativo'::name))::smallint NOT NULL,
    caixa_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    caixa_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    caixa_code character varying
);


--
-- TOC entry 5982 (class 0 OID 0)
-- Dependencies: 252
-- Name: TABLE caixa; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.caixa IS 'Essa entidade serve para registar as caixas abertas pelos colaboradores';


--
-- TOC entry 5983 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_id IS 'Identificador único da caixa';


--
-- TOC entry 5984 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_posto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_posto_id IS 'Identificador do posto o qual emcontra-se a caixa';


--
-- TOC entry 5985 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_colaborador_id IS 'Identificador do colaborador responsável pelo registro da caixa';


--
-- TOC entry 5986 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização da caixa';


--
-- TOC entry 5987 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_montanteinicial; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_montanteinicial IS 'Corresponde ao montante inicial em que a caixa foi aberta com ele';


--
-- TOC entry 5988 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_montantefecho; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_montantefecho IS 'Corresponde ao montante em que a caixa foi fechado com ele';


--
-- TOC entry 5989 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_quantidadecheque; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_quantidadecheque IS 'Corresponde a quantidade de pagamentos feitos em cheques na caixa';


--
-- TOC entry 5990 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_observacao IS 'Observação deixada no fecho da caixa';


--
-- TOC entry 5991 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_estado IS 'Estado da caixa
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechado </li>
</ul>';


--
-- TOC entry 5992 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_dataregistro IS 'Corresponde ao instante em que a caixa foi registrada';


--
-- TOC entry 5993 (class 0 OID 0)
-- Dependencies: 252
-- Name: COLUMN caixa.caixa_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.caixa.caixa_dataatualizacao IS 'Corresponde ao instante em que a caixa foi atualizado pela última vez (instante em que a caixa foi fechada)';


--
-- TOC entry 798 (class 1255 OID 16977)
-- Name: _get_caixa(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_caixa(arg_caixa_id uuid) RETURNS tweeks.caixa
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Essa função serve para obter uma instancia da caixa
select * from tweeks.caixa cx where cx.caixa_id = arg_caixa_id;
$$;


--
-- TOC entry 253 (class 1259 OID 16978)
-- Name: classe; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.classe (
    classe_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    classe_classe_id uuid,
    classe_espaco_auth uuid NOT NULL,
    classe_colaborador_id uuid NOT NULL,
    classe_colaborador_atualizacao uuid,
    classe_nome character varying NOT NULL,
    classe_codigo character varying,
    classe_foto character varying,
    classe_position smallint DEFAULT 0 NOT NULL,
    classe_lastcodigo integer DEFAULT 0 NOT NULL,
    classe_estado smallint DEFAULT (map.get('classe_estado_ativo'::name))::smallint NOT NULL,
    classe_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    classe_dataatualizacao timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    _branch_uid uuid,
    CONSTRAINT ck_classe_nome_normalized CHECK (lib.str_is_normalized((classe_nome)::text))
);


--
-- TOC entry 5996 (class 0 OID 0)
-- Dependencies: 253
-- Name: TABLE classe; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.classe IS '#Classe - Essa entidade serve para armazenar as classes do produto (categoria do porduto)';


--
-- TOC entry 5997 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN classe.classe_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.classe.classe_id IS 'Identificador único da classe';


--
-- TOC entry 5998 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN classe.classe_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.classe.classe_colaborador_id IS 'Identificador do colaborador responsável pela última atualização';


--
-- TOC entry 5999 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN classe.classe_nome; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.classe.classe_nome IS 'Corresponde ao nome da classe';


--
-- TOC entry 6000 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN classe.classe_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.classe.classe_estado IS ' Estado da classe
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechado </li>
</ul>
';


--
-- TOC entry 6001 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN classe.classe_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.classe.classe_dataregistro IS 'Corresponde ao instante em que a classe for registrada no sistema';


--
-- TOC entry 6002 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN classe.classe_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.classe.classe_dataatualizacao IS 'Corresponde ao instnate em que a classe for atualizado pela sua última vez';


--
-- TOC entry 799 (class 1255 OID 16990)
-- Name: _get_classe(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_classe(arg_classe_id uuid) RETURNS tweeks.classe
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Essa função devolve uma instancia da classe do artigo
select * from tweeks.classe clas where clas.classe_id = arg_classe_id;
$$;


--
-- TOC entry 254 (class 1259 OID 16991)
-- Name: conta; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.conta (
    conta_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    conta_cliente_id uuid,
    conta_posto_id uuid,
    conta_posto_fecho uuid,
    conta_espaco_auth uuid NOT NULL,
    conta_colaborador_id uuid NOT NULL,
    conta_colaborador_atualizacao uuid,
    conta_numero integer NOT NULL,
    conta_titularnif character varying,
    conta_titular character varying,
    conta_data date,
    conta_numerofatura character varying,
    conta_montante double precision DEFAULT 0.0 NOT NULL,
    conta_imprensa smallint DEFAULT 0 NOT NULL,
    conta_observacao character varying,
    conta_desconto double precision DEFAULT 0 NOT NULL,
    conta_estado smallint DEFAULT (map.get('maguita_conta_estado_aberto'::name))::smallint NOT NULL,
    conta_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    conta_dataatualizacao timestamp with time zone,
    conta_extension jsonb DEFAULT '{}'::jsonb NOT NULL,
    conta_mesa json,
    conta_datafecho timestamp with time zone,
    _tgrupo_id smallint,
    conta_colaborador_fecho uuid,
    conta_proforma boolean DEFAULT false,
    conta_proformavencimento date,
    conta_proformaextras jsonb,
    conta_serie_id uuid,
    _branch_uid uuid,
    conta_serie json,
    conta_chave character varying,
    conta_conta_docorigin uuid,
    conta_props jsonb,
    CONSTRAINT ck_conto_titular CHECK (lib.str_is_normalized((conta_titular)::text))
);


--
-- TOC entry 6005 (class 0 OID 0)
-- Dependencies: 254
-- Name: TABLE conta; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.conta IS 'Essa entidade serve para armazenar as contas das vendas feitas';


--
-- TOC entry 6006 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_id IS 'Identificador único da conta';


--
-- TOC entry 6007 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_posto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_posto_id IS 'Identificador da caixa a qual a conta foi aberta';


--
-- TOC entry 6008 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_posto_fecho; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_posto_fecho IS 'Corresponde a caixa em que a conta teve o seu pagamento de fecho (apenas a última que conta, mas pode-se ver todas anterior na entidade amortização)';


--
-- TOC entry 6009 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_colaborador_id IS 'Identificador do colaborador responsável pelo registro da conta';


--
-- TOC entry 6010 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_colaborador_atualizacao IS 'Identificador do último colaborador responsavél pela atualização da conta (colaborador quem finalizou a conta)';


--
-- TOC entry 6011 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_titularnif; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_titularnif IS 'O nif do titular da conta';


--
-- TOC entry 6012 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_titular; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_titular IS 'Corresponde ao titular da conta (o nome do cliente)';


--
-- TOC entry 6013 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_data; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_data IS 'Corresponde a data da conta';


--
-- TOC entry 6014 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_numerofatura; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_numerofatura IS 'Corresponde ao numero de fatura gerado para a conta';


--
-- TOC entry 6015 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_montante; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_montante IS 'Corresponde ao montante total da conta';


--
-- TOC entry 6016 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_imprensa; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_imprensa IS 'Corresponde ao numeros de impressão que a conta já teve';


--
-- TOC entry 6017 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_observacao IS 'Corresponde a observação da conta, normalmente setado na anulação da conta';


--
-- TOC entry 6018 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_desconto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_desconto IS 'Esse atributo indica o montante em desconto da conta';


--
-- TOC entry 6019 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_estado IS 'Corresponde ao estado atuala da conta
<ul>
  <li> 2 - Aberto  | pode efetuar quaisquer alteração na conta</li>
  <li> 1 - Fechado | não se pode alterar mais nada na conta (só anulação)</li>
  <li> 0 - Pago    | conta paga não se pode efetuar mais nenhuma alteração (só anulaçõa)</li>
  <li> -1 Anulado </li>
</ul>';


--
-- TOC entry 6020 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_dataregistro IS 'Corresponde ao instante em que a conta foi registrada';


--
-- TOC entry 6021 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN conta.conta_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.conta.conta_dataatualizacao IS 'Corresponde ao instante em que a conta foi atualizada pela última vez';


--
-- TOC entry 800 (class 1255 OID 17005)
-- Name: _get_conta(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_conta(arg_conta_id uuid) RETURNS tweeks.conta
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Essa função devolve a instancia de uma conta
select * from tweeks.conta ct where ct.conta_id = arg_conta_id;
$$;


--
-- TOC entry 801 (class 1255 OID 17006)
-- Name: _get_espaco(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_espaco(arg_espaco_id uuid) RETURNS tweeks.espaco
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- essa função serve para devolver uma intancia do espaco
select * from tweeks.espaco esp where esp.espaco_id = arg_espaco_id;
$$;


--
-- TOC entry 803 (class 1255 OID 17007)
-- Name: _get_impostos_taxa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_impostos_taxa(args jsonb) RETURNS TABLE(artigo_id uuid, percentagem_adicionar double precision, percentagem_retirar double precision, taxa_adicionar double precision, taxa_retirar double precision, taxas uuid[])
    LANGUAGE plpgsql
    AS $$
declare
  /**
    arg_artigo_id [ ID, ... ]
    arg_espaco_auth UID
    arg_colaborador_id UID
   */


  arg_artigo_id uuid[] default array(
    select e.text::uuid
      from jsonb_array_elements_text( args-> 'arg_artigo_id' ) e(  text )
  );
  arg_espaco_auth uuid default  args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';

  _const map.constant;
  _data record;
  __knext record;
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
  _const := map.constant();

  for __knext in
    select *
     from unnest( arg_artigo_id ) u( _argito_id )
  loop
    select
      sum( ( txass::tweeks.taxa ).taxa_percentagem ) filter ( where tap.taplicar_id = _const.maguita_taplicar_adicionar ) as percentagem_adicionar,
      sum( ( txass::tweeks.taxa ).taxa_percentagem ) filter ( where tap.taplicar_id = _const.maguita_taplicar_retirar ) as percentagem_retivar,
      sum( ( txass::tweeks.taxa ).taxa_taxa ) filter ( where tap.taplicar_id = _const.maguita_taplicar_adicionar ) as taxa_adicionar,
      sum( ( txass::tweeks.taxa ).taxa_taxa ) filter ( where tap.taplicar_id = _const.maguita_taplicar_retirar ) as taxa_retivar,
      array_agg( distinct (txass::tweeks.taxa).taxa_id ) as taxas
      into _data
    from tweeks.imposto ip
      inner join tweeks.taplicar tap on ip.imposto_taplicar_id = tap.taplicar_id
      inner join tweeks.taxa tx on ip.imposto_tipoimposto_id = tx.taxa_tipoimposto_id
        and tx.taxa_estado = _const.taxa_estado_ativo
        and tx.taxa_espaco_auth = ip.imposto_espaco_auth
      inner join rule.taxa_espaco( tx, _const, arg_espaco_auth ) txass on true
    where ip.imposto_artigo_id = __knext._argito_id
      and ip._branch_uid = ___branch
      and tx._branch_uid = ___branch
      and ip.imposto_estado = _const.maguita_imposto_estado_ativo;

    _get_impostos_taxa.artigo_id := __knext._argito_id;
    _get_impostos_taxa.percentagem_adicionar := coalesce( _data.percentagem_adicionar, 0 );
    _get_impostos_taxa.percentagem_retirar := coalesce( _data.percentagem_retivar, 0 );
    _get_impostos_taxa.taxa_adicionar := coalesce( _data.taxa_adicionar, 0 );
    _get_impostos_taxa.taxa_retirar := coalesce( _data.taxa_retivar, 0 );
    _get_impostos_taxa.taxas := coalesce( _data.taxas, array[]::uuid[] );
    return next;
  end loop;
end;
$$;


--
-- TOC entry 769 (class 1255 OID 17008)
-- Name: _get_item(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_item(arg_artigo_item uuid) RETURNS tweeks.artigo
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Essa função devolve uma instancia da item do artigo
select * from tweeks.artigo itt where itt.artigo_id = arg_artigo_item
  and itt.artigo_classe_id = lib.to_uuid( 1 ) ; -- classe dos items
$$;


--
-- TOC entry 255 (class 1259 OID 17009)
-- Name: link; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.link (
    link_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    link_link_id uuid,
    link_link_associacao uuid,
    link_tlink_id smallint NOT NULL,
    link_espaco_destino uuid NOT NULL,
    link_espaco_auth uuid NOT NULL,
    link_colaborador_id uuid NOT NULL,
    link_colaborador_atualizacao uuid,
    link_referencia jsonb,
    link_posicao smallint,
    link_nome character varying NOT NULL,
    link_metadata jsonb,
    link_config jsonb,
    link_estado smallint DEFAULT (map.get('maguita_link_estado_ativo'::name))::smallint NOT NULL,
    link_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    link_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 6027 (class 0 OID 0)
-- Dependencies: 255
-- Name: TABLE link; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.link IS 'Essa entidade serve para registar o item que deve ocupar uma tecla';


--
-- TOC entry 6028 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_id IS 'Identificador único do link';


--
-- TOC entry 6029 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_link_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_link_id IS 'Identificador da link parent';


--
-- TOC entry 6030 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_espaco_destino; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_espaco_destino IS 'Identificador do espaço o qual a link pertence';


--
-- TOC entry 6031 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_colaborador_id IS 'Identificador do colaborador responsavél pelo registro do link';


--
-- TOC entry 6032 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização da link';


--
-- TOC entry 6033 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_referencia; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_referencia IS 'Corresponde a referencia a que o link se aponta (artigo, link, classe ...)';


--
-- TOC entry 6034 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_posicao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_posicao IS 'Corresponde a posição em que a link deve ocupar';


--
-- TOC entry 6035 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_nome; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_nome IS 'Corresponde ao nome da link';


--
-- TOC entry 6036 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_config; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_config IS 'Corresponde a cofifuração da link';


--
-- TOC entry 6037 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_estado IS 'Corresponde ao estado da link
<ul>
  <li> 2 - Ligação </ul>
  <li> 1 - Ativo </ul>
  <li> 0 - Fechado </ul>
</ul>
';


--
-- TOC entry 6038 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_dataregistro IS 'Corresponde ao instante em que a link foi registrada';


--
-- TOC entry 6039 (class 0 OID 0)
-- Dependencies: 255
-- Name: COLUMN link.link_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.link.link_dataatualizacao IS 'Corresponde ao instante em que a link foi atualizado pela última vez';


--
-- TOC entry 780 (class 1255 OID 17017)
-- Name: _get_link(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_link(arg_link_id uuid) RETURNS tweeks.link
    LANGUAGE sql
    AS $$
  -- Essa função serve para devolver a instancia de uma link
select * from tweeks.link where link_id = arg_link_id;
$$;


--
-- TOC entry 256 (class 1259 OID 17018)
-- Name: posto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.posto (
    posto_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    posto_tposto_id smallint NOT NULL,
    posto_espaco_auth uuid NOT NULL,
    posto_colaborador_id uuid NOT NULL,
    posto_colaborador_atualizacao uuid,
    posto_designacao character varying,
    posto_chave character varying NOT NULL,
    posto_multiplecaixa boolean DEFAULT true NOT NULL,
    posto_matricula character varying,
    posto_estado smallint DEFAULT (map.get('maguita_posto_estado_fechado'::name))::smallint NOT NULL,
    posto_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    posto_dataatualizacao timestamp with time zone,
    posto_authmode smallint,
    posto_caixamode smallint,
    posto_caixalimite integer,
    _branch_uid uuid,
    posto_vermontatefaturado boolean DEFAULT false NOT NULL,
    posto_definirmontanteautomaticamente boolean DEFAULT false
);


--
-- TOC entry 6042 (class 0 OID 0)
-- Dependencies: 256
-- Name: TABLE posto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.posto IS 'Essa entidade serve para armazenar os postos de venda';


--
-- TOC entry 6043 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_id IS 'Identificador do posto';


--
-- TOC entry 6044 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_espaco_auth; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_espaco_auth IS 'Identificador do espaço o qual o posto está ancorado';


--
-- TOC entry 6045 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_colaborador_id IS 'Identificador do colaborador responsável pelo registro do posto';


--
-- TOC entry 6046 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_colaborador_atualizacao IS 'Identificador do último colaborador responsável pela atualização do posnto';


--
-- TOC entry 6047 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_designacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_designacao IS 'Corresponde a designação do posto';


--
-- TOC entry 6048 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_estado IS 'Corresponde ao estado do posto
<ul>
  <li> fechado | significa que o posto pode ser encerado ou aberto </li>
  <li> aberto | sigififica que o posto está atualmente com uma caixa aberta (não pode ser encerado nesse estado) </li>
  <li> encerado | significa que nenhuma caixa pode ser mais aberta nesse posto </li>
</ul>';


--
-- TOC entry 6049 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_dataregistro IS 'Corresponde ao instante que o posto foi registrado no sistema';


--
-- TOC entry 6050 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN posto.posto_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.posto.posto_dataatualizacao IS 'Corresponde ao instante em que o posto teve a sua última atualização';


--
-- TOC entry 792 (class 1255 OID 17028)
-- Name: _get_posto(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_posto(arg_posto_id uuid) RETURNS tweeks.posto
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Essa função retorna uma instancia da posto
select * from tweeks.posto cx where cx.posto_id = arg_posto_id;
$$;


--
-- TOC entry 533 (class 1255 OID 17029)
-- Name: _get_stock(uuid, uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_stock(_artigo_id uuid, _espaco_id uuid) RETURNS TABLE(stock_artigo_id uuid, stock_espaco_id uuid, stock_quantidade double precision)
    LANGUAGE sql STRICT
    AS $$
  select s.artigo_id, s.espaco_id, sum( s.stock_quantidade )::double precision
    from tweeks.stock s
    where s.artigo_id = coalesce( _artigo_id, s.artigo_id )
      and s.espaco_id = coalesce( _espaco_id, s.espaco_id)
    group by s.artigo_id, s.espaco_id;
$$;


--
-- TOC entry 257 (class 1259 OID 17030)
-- Name: tmovimento; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tmovimento (
    tmovimento_id smallint NOT NULL,
    tmovimento_multiplo smallint NOT NULL,
    tmovimento_designacao character varying NOT NULL
);


--
-- TOC entry 6054 (class 0 OID 0)
-- Dependencies: 257
-- Name: TABLE tmovimento; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.tmovimento IS 'Essa entidade serve para armazenar os tipos de movimento (credito, debito)';


--
-- TOC entry 6055 (class 0 OID 0)
-- Dependencies: 257
-- Name: COLUMN tmovimento.tmovimento_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tmovimento.tmovimento_id IS 'Identificador único do tipo de movimento';


--
-- TOC entry 6056 (class 0 OID 0)
-- Dependencies: 257
-- Name: COLUMN tmovimento.tmovimento_multiplo; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tmovimento.tmovimento_multiplo IS 'Corresponde ao valor mutiplicavel do tipo de movimento';


--
-- TOC entry 6057 (class 0 OID 0)
-- Dependencies: 257
-- Name: COLUMN tmovimento.tmovimento_designacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tmovimento.tmovimento_designacao IS 'Corresponde a designação do tipo de movimento';


--
-- TOC entry 540 (class 1255 OID 17035)
-- Name: _get_tmovimento(smallint); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_tmovimento(arg_tmovimento_id smallint) RETURNS tweeks.tmovimento
    LANGUAGE sql
    AS $$
  -- Essa função serve para devolver os tipos de movimento do posto
  select * from tweeks.tmovimento tm where tm.tmovimento_id = arg_tmovimento_id;
$$;


--
-- TOC entry 258 (class 1259 OID 17036)
-- Name: venda; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.venda (
    venda_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    venda_conta_id uuid NOT NULL,
    venda_artigo_id uuid NOT NULL,
    venda_espaco_auth uuid NOT NULL,
    venda_colaborador_id uuid NOT NULL,
    venda_colaborador_atualizacao uuid,
    venda_quantidade double precision NOT NULL,
    venda_custounitario double precision NOT NULL,
    venda_montante double precision DEFAULT 0.0 NOT NULL,
    venda_montanteagregado double precision DEFAULT 0.0 NOT NULL,
    venda_montantetotal double precision NOT NULL,
    venda_imposto double precision DEFAULT 0 NOT NULL,
    venda_montantesemimposto double precision DEFAULT 0.0 NOT NULL,
    venda_montantecomimposto double precision DEFAULT 0.0 NOT NULL,
    venda_impostoadicionar double precision,
    venda_impostoretirar double precision,
    venda_estadopreparacao smallint DEFAULT (map.get('venda_estadopreparacao_preparado'::name))::smallint NOT NULL,
    venda_estado smallint DEFAULT (map.get('maguita_venda_estado_aberto'::name))::smallint NOT NULL,
    venda_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    venda_dataatualizacao timestamp with time zone,
    venda_venda_id uuid,
    venda_custoquantidade double precision DEFAULT 1 NOT NULL,
    _branch_uid uuid,
    venda_descricao character varying,
    venda_lote character varying,
    venda_validade date,
    venda_metadata json,
    venda_editado boolean DEFAULT false NOT NULL,
    venda_isencao boolean DEFAULT false NOT NULL,
    venda_taxas uuid[] DEFAULT ARRAY[]::uuid[] NOT NULL,
    venda_codigoimposto character varying,
    venda_venda_docorign uuid
);


--
-- TOC entry 6060 (class 0 OID 0)
-- Dependencies: 258
-- Name: TABLE venda; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.venda IS 'Essa entidade serve para registar as vendas do artigo ';


--
-- TOC entry 6061 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_id IS 'Identificador único da venda';


--
-- TOC entry 6062 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_conta_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_conta_id IS 'Identificador da conta o qual a venda esta associado';


--
-- TOC entry 6063 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_artigo_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_artigo_id IS 'Identificador do artigo o qual foi vendido';


--
-- TOC entry 6064 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_espaco_auth; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_espaco_auth IS 'Identificador do espaço onde saiu o artigo';


--
-- TOC entry 6065 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_colaborador_id IS 'Identificador do colaborador responsável pelo registro da venda';


--
-- TOC entry 6066 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_colaborador_atualizacao IS 'Identificador do colaborador responsável pela última atualização da venda';


--
-- TOC entry 6067 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_quantidade; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_quantidade IS 'Quantidade do artigo vendido';


--
-- TOC entry 6068 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_custounitario; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_custounitario IS 'Custo únitario do artigo';


--
-- TOC entry 6069 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_montante; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_montante IS 'Montente do artigo preco X quantidade';


--
-- TOC entry 6070 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_montanteagregado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_montanteagregado IS 'Corresponde ao montante total de todos os itens agregados';


--
-- TOC entry 6071 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_montantetotal; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_montantetotal IS 'Coresponde ao montante total da venda = (montante + montanteAgregado )';


--
-- TOC entry 6072 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_imposto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_imposto IS 'Esse atributo indica o valor de imposto sobre a venda';


--
-- TOC entry 6073 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_estado IS 'Corresponde ao estado da venda
<ul>
  <li> aberto <li>
  <li> fechado </li>
  <li> anulado </li>
  <li> canselado </li>
</ul>';


--
-- TOC entry 6074 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_dataregistro IS 'Corresponde ao instanre em que a venda foi registrado no sistema';


--
-- TOC entry 6075 (class 0 OID 0)
-- Dependencies: 258
-- Name: COLUMN venda.venda_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.venda.venda_dataatualizacao IS 'Corresponde ao instante em que a venda foi atualizado pela última vez no sistema.';


--
-- TOC entry 541 (class 1255 OID 17054)
-- Name: _get_venda(uuid); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks._get_venda(arg_venda_id uuid) RETURNS tweeks.venda
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
  -- Essa função devolve uma instancia de venda
select * from tweeks.venda ve where ve.venda_id = arg_venda_id;
$$;


--
-- TOC entry 804 (class 1255 OID 17055)
-- Name: funct_change_artigo_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_artigo_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para ativar ou desativar o estado do um artigo
    args = {
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,
      arg_artigo_id: ID
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_artigo_id uuid not null default args->>'arg_artigo_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
  _artigo tweeks.artigo;
begin

  _const := map.constant();
  _artigo := tweeks._get_artigo( arg_artigo_id );

  -- Se o espaço for o proprietario do artigo então desativar/reativar o artigo na boa
  if _artigo.artigo_espaco_auth = any( arg_espaco_child ) then
    update tweeks.artigo
      set
        artigo_estado = lib.swith( artigo_estado, _const.artigo_estado_ativo, _const.artigo_estado_fechado  ),
        artigo_colaborador_atualizacao = arg_colaborador_id,
        artigo_dataatualizacao = current_timestamp
      where artigo_id = arg_artigo_id
      returning * into _artigo
    ;

    return true ? jsonb_build_object(
      'artigo', _artigo,
      'text', case
        when _artigo.artigo_estado = _const.artigo_estado_ativo   then format( 'O artigo "%s" foi ativado!', _artigo.artigo_nome )
        when _artigo.artigo_estado = _const.artigo_estado_fechado then format( 'O artigo "%s" foi desativo!', _artigo.artigo_nome )
      end
    );

  -- os outros só podem desativar apenas os links do artigos associados a ele
  else
    return tweeks.funct_change_link_unlink(
        jsonb_build_object(
          'arg_espaco_auth', arg_espaco_auth,
          'arg_colaborador_id', arg_colaborador_id,
          'arg_link_referencia', rule.artigo_referencia( arg_artigo_id )
        )
      );
  end if;




exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 805 (class 1255 OID 17056)
-- Name: funct_change_autorizacao_closeyear(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_autorizacao_closeyear(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    {
      arg_colaborador_id: UID
      arg_espaco_auth: UID
      autorizacao_uid: UID
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _autorizacao tweeks.autorizacao;
  _const map.constant;
begin
  _const := map.constant();
  _autorizacao := jsonb_populate_record( _autorizacao, args );
  _autorizacao := tweeks.__get_autorizacao( _autorizacao.autorizacao_uid );

  if _autorizacao.autorizacao_estado != _const.maguita_autorizacao_estado_ativo then
    return lib.res_false( 'A autorizacao selecionada para fecho já esta encerada!' );
  end if;

  update tweeks.autorizacao
    set autorizacao_colaborador_atualizacao = arg_colaborador_id,
        autorizacao_dataatualizacao = now(),
        autorizacao_estado = _const.autenticacao_estado_fechado
    where autorizacao_uid = _autorizacao.autorizacao_uid
    returning * into _autorizacao
  ;

  update tweeks.serie
    set serie_dataatualizacao = now(),
        serie_colaborador_atualizacao = arg_colaborador_id,
        serie_estado = _const.maguita_serie_estado_fechado,
        serie_fechoautorizacao = true
    where serie_estado = _const.maguita_serie_estado_ativo
      and serie_autorizacao_uid = _autorizacao.autorizacao_uid
  ;

  return lib.res_true( jsonb_build_object(
    'autorizacao', _autorizacao
  ));
end;
$$;


--
-- TOC entry 802 (class 1255 OID 17057)
-- Name: funct_change_chave_restore(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_chave_restore(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
     arg_chave_temporaria: CHAVE
     arg_chave_definitiva: CHAVE
   */
    arg_chave_temporaria character varying default args->>'arg_chave_temporaria';
    arg_chave_definitiva character varying default args->>'arg_chave_definitiva';
    _chave tweeks.chave;
begin
  select * into _chave
    from tweeks.chave ch
    where ch.chave_temporarai = arg_chave_temporaria;

  if _chave.chave_definitiva is not null then
      return lib.result_false( 'Chave temporaria já aplicada' );
  else
     update tweeks.chave
        set chave_definitiva = arg_chave_definitiva
        where chave_temporarai = arg_chave_temporaria
        returning * into _chave
      ;
     return lib.result_true( to_jsonb( _chave ) );
  end if;
end
$$;


--
-- TOC entry 807 (class 1255 OID 17058)
-- Name: funct_change_classe_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_classe_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para ativar ou desativar o estado do um artigo
    args = {
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,
      arg_classe_id: ID
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  arg_classe_id uuid not null default args->>'arg_classe_id';
  _const map.constant;
  _classe tweeks.classe;
begin
  _const := map.constant();

  if arg_classe_id = _const.classe_itemextra then
    return false ? 'Item extra não pode ser desativado';
  end if;

  _classe := tweeks._get_classe( arg_classe_id );

  if _classe.classe_espaco_auth = any( arg_espaco_child ) then
    update tweeks.classe
      set
        classe_estado = case
          when classe_estado = _const.classe_estado_ativo then   _const.classe_estado_fechado
          when classe_estado = _const.classe_estado_fechado then _const.classe_estado_ativo
          else classe_estado
        end::int2,
        classe_colaborador_atualizacao = arg_colaborador_id,
        classe_dataatualizacao = current_timestamp
      where classe_id = arg_classe_id
      returning * into _classe
    ;

    return true ? jsonb_build_object(
      'classe', _classe,
      'classe_old', _classe,
      'message', case
        when _classe.classe_estado = _const.classe_estado_ativo   then format( 'O item "%s" foi ativado!',   _classe.classe_nome )
        when _classe.classe_estado =   _const.classe_estado_fechado then format( 'O item "%s" foi desativo!',  _classe.classe_nome )
      end
    );

  -- Se não for proprietario deslinkar apenas a classe ao espaço
  else
    return tweeks.funct_change_link_unlink(
      jsonb_build_object(
        'arg_espaco_auth', arg_espaco_auth,
        'arg_colaborador_id', arg_colaborador_id,
        'arg_link_referencia', rule.classe_referencia( arg_classe_id )
      )
    );
  end if;

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 808 (class 1255 OID 17059)
-- Name: funct_change_colaborador(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_colaborador(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para aatualizar as informações do colaborador
    args := {
      arg_espaco_auth: ID
      arg_espaco: [ ]
      arg_colaborador_id: ID,
      arg_colaborador_editar: ID,
      arg_colaborador_email: MAIL,
      arg_colaborador_nome: NOME,
      arg_colaborador_apelido: APELIDO,
      arg_colaborador_datanascimento: DATA,
      arg_colaborador_nif: NIF,
      arg_colaborador_ficha: FICHA,
      arg_colaborador_foto: FICHA,
      arg_tsexo_id: SEXO
    }
    arg_colaborador_editar corresponde ao id do colaborador que sera atualizado
    arg_colaborador_id corresponde ao id do colaborador que esata efetuar a atualização
  */

  arg_colaborador_id uuid not null       := args->>'arg_colaborador_id';
  arg_colaborador_editar uuid not null   := args->>'arg_colaborador_editar';
  arg_espaco_auth uuid not null             := args->>'arg_espaco_auth';

  arg_colaborador_email character varying   := args->>'arg_colaborador_email';
  arg_colaborador_nome character varying    := args->>'arg_colaborador_nome';
  arg_colaborador_apelido character varying := args->>'arg_colaborador_apelido';
  arg_colaborador_datanascimento date       := args->>'arg_colaborador_datanascimento';
  arg_colaborador_nif character varying     := args->>'arg_colaborador_nif';
  arg_colaborador_ficha jsonb               := args->>'arg_colaborador_ficha';
  arg_colaborador_foto varchar               := args->>'arg_colaborador_foto';
  arg_tsexo_id int2                         := args->>'arg_tsexo_id';
  arg_espaco jsonb                      := args->'arg_espaco';

  _colaborador auth.colaborador := auth._get_colaborador( arg_colaborador_editar );
  _const map.constant := map.constant();
begin

  -- Tanto o nif, quanto o email deve ser único na base de dados
  arg_colaborador_email := lib.str_normalize( lower( arg_colaborador_email ) );
  arg_colaborador_nif := lib.str_normalize( lower( arg_colaborador_nif ) );

  -- Quando existir email e estiver associado ao utro colaborador então
  if arg_colaborador_email is not null  and (
    select count( * )
      from auth.colaborador
      where colaborador_email = arg_colaborador_email
        and colaborador_id != _colaborador.colaborador_id
  ) > 0 then
    return lib.result_false( 'Email já existe!' );
  end if;

  -- Quando existir um colaborador o nif expecificado
  if arg_colaborador_nif is not null is not null and  (
    select count( * ) > 0
      from auth.colaborador co
      where co.colaborador_nif = arg_colaborador_nif
        and co.colaborador_id != _colaborador.colaborador_id
  ) then
    return lib.result_false( 'NIF já existe!' );
  end if;

  -- A atualização deve ser feita apenas quando o novo valor vier nulo
  update auth.colaborador
    set colaborador_email = coalesce( arg_colaborador_email, colaborador_email ),
        colaborador_nome = coalesce( lib.str_normalize( arg_colaborador_nome ), colaborador_nome ),
        colaborador_apelido = coalesce( lib.str_normalize( arg_colaborador_apelido ), colaborador_apelido ),
        colaborador_tsexo_id = coalesce( arg_tsexo_id, colaborador_tsexo_id ),
        colaborador_datanascimento = coalesce( arg_colaborador_datanascimento, colaborador_datanascimento ),
        colaborador_nif = coalesce( arg_colaborador_nif, colaborador_nif ),
        colaborador_foto = coalesce( arg_colaborador_foto, colaborador_foto ),
        colaborador_ficha = coalesce( arg_colaborador_ficha, colaborador_ficha ),
        colaborador_colaborador_atualizacao = arg_colaborador_id,
        colaborador_dataatualizacao = now()
    where colaborador_id = _colaborador.colaborador_id
    returning * into _colaborador
  ;

  perform tweeks.funct_reg_trabalha(
    jsonb_build_object(
      'arg_espaco_auth', arg_espaco_auth,
      'arg_colaborador_id', arg_colaborador_id,
      'arg_colaborador_propetario', _colaborador.colaborador_id,
      'arg_espaco', arg_espaco
    )
  );

  return lib.result_true();
end;
$$;


--
-- TOC entry 514 (class 1255 OID 17060)
-- Name: funct_change_conta(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_conta(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    /**
      Essa função registra um nova conta
      arg = {

        -- obrigatorios
        arg_colaborador_id: ID,
        arg_conta_id: ID,
        arg_espaco_auth: ID,
        arg_posto_id: ID,
        arg_mesa_numero: NUMERO,


        -- requerido
        arg_vendas: [
          {
            arg_venda_id: ID,
            arg_artigo_id: ID,
            arg_venda_quantidade: QUANT,
            arg_venda_custounitario: CUSTO,

            arg_agregas: [
              {
                arg_agrega_id: ID,
                arg_item_id: ID,
                arg_item_quantidadecusto: QUANT/CUSTO
                arg_item_custo: CUSTO,
                arg_agrega_quantidade: QUANT,
                arg_agrega_montante: MONTANTE
              }
            ]
          }
        ]
      }
     */
   */

  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_conta_id uuid not null default args->>'arg_conta_id';
  arg_posto_id uuid not null default args->>'arg_posto_id';

  arg_mesa_numero varchar default args->>'arg_mesa_numero';
  arg_vendas jsonb not null default args->>'arg_vendas';

  arg_reserva_id uuid  default args->>'arg_reserva_id';
  arg_currency_id int2 default args->>'arg_currency_id';
  arg_tpaga_id int2 default args->>'arg_tpaga_id';
  arg_conta_titular varchar default args->>'arg_conta_titular';
  arg_conta_data date default args->>'arg_conta_data';

  arg_vendas_id uuid [] not null default array( select ( ele.doc->>'arg_venda_id' )::uuid from jsonb_array_elements( arg_vendas ) ele( doc ) where ele.doc->>'arg_venda_id' is not null );

  _conta tweeks.conta;
  _const map.constant;
  _mesa tweeks.mesa;
  _res lib.result;
  _data record;
  _data_item record;
  _stock tweeks.stock;

  arg_venda_add jsonb;
  arg_venda_change jsonb;
begin
  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );
  _mesa := tweeks._get_mesa( arg_colaborador_id, arg_espaco_auth, arg_mesa_numero );
  _mesa.mesa_estado := coalesce( _mesa.mesa_estado, _const.mesa_estado_disponivel );
  _mesa.mesa_id := coalesce( _mesa.mesa_id, -1 );

--   -- A mesa tem de estar disponivel para associa-la a conta
--   if _conta.conta_mesa_id != _mesa.mesa_id and _mesa.mesa_estado != _const.mesa_estado_disponivel then
--     return false ? '@tweeks.conta.mesa.estado.not-open';
--   end if;


  -- Validar as vendas e distirgir quais vão ser atualizado, e quais vão ser registrados e quais não vão ter acão
  for _data in
    select *
    from jsonb_array_elements( arg_vendas ) v( venda_document )
     inner join jsonb_to_record( v.venda_document ) as venl(
        arg_venda_id int,
        arg_artigo_id int,
        arg_venda_quantidade float,
        arg_venda_custounitario float,
        arg_agregas jsonb
      ) on true
           inner join tweeks.artigo art on venl.arg_artigo_id = art.artigo_id
           left join tweeks.venda ve on art.artigo_id = ve.venda_artigo_id
      and ve.venda_id = venl.arg_venda_id
      and ve.venda_estado = _const.venda_estado_aberto
    loop

      if _data.venda_id is not null then
        arg_venda_change := coalesce( arg_venda_change, jsonb_build_array());
        arg_venda_change := arg_venda_change || (_data.venda_document );
      else
        arg_venda_add := coalesce( arg_venda_add, jsonb_build_array() );
        arg_venda_add := arg_venda_add || _data.venda_document;
      end if;
    end loop;

  -- canselar todas as vendas não removidas da conta
  update tweeks.venda
  set venda_estado = _const.venda_estado_canselado,
      venda_colaborador_atualizacao = arg_colaborador_id,
      venda_dataatualizacao = current_timestamp
  where venda_id != all ( arg_vendas_id )
    and venda_conta_id = arg_conta_id
    and venda_estado = _const.venda_estado_aberto
  ;

  -- Alterar as vendas antigas
  if arg_venda_change is not null then

    perform tweeks.funct_change_venda(
      jsonb_build_object(
        'arg_colaborador_id', arg_colaborador_id,
        'arg_espaco_auth', arg_espaco_auth,
        'arg_message_error', true,
        'arg_conta_id', arg_conta_id,
        'arg_vendas', arg_venda_change
      )
    );
  end if;

  if arg_venda_add is not null then
    perform tweeks.funct_reg_venda(
      jsonb_build_object(
        'arg_colaborador_id', arg_colaborador_id,
        'arg_espaco_auth', arg_espaco_auth,
        'arg_message_error', true,
        'arg_conta_id', arg_conta_id,
        'arg_vendas', arg_venda_add
      )
    );
  end if;

  -- Quando houver alteração da mesa então mover a conta para outra mesa
  if _conta.conta_mesa_id != _mesa.mesa_id then
    update tweeks.conta
      set conta_mesa_id = _mesa.mesa_id
      where conta_id = _conta.conta_id
          returning * into _conta;
  end if;

  return true ? _res.message || jsonb_build_object(
    'conta', _conta,
    'venda', ( with asVend as (
      select to_jsonb( ve ) || jsonb_build_object( 'agrega', jsonb_agg( a ) )
        from tweeks.venda ve
            left join  agrega a on ve.venda_id = a.agrega_venda_id
          and a.agrega_estado = _const.agrega_estado_aberto
        where ve.venda_conta_id = _conta.conta_id
          and ve.venda_estado = _const.venda_estado_aberto
        group by ve.venda_id
      ) select
        array_agg( to_jsonb( av ) ) from asVend aV
    )
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 810 (class 1255 OID 17062)
-- Name: funct_change_conta_imprimir(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_conta_imprimir(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Alterar o estado da conta para imprensa
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_conta_id: ID,
    }
  */

  arg_espaco_auth uuid not null  default args->>'arg_espaco_auth';
  arg_conta_id uuid not null default args->>'arg_conta_id';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';

  _conta tweeks.conta;
  _const map.constant;
begin
  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );

  if _conta.conta_imprensa then
    return  true ? jsonb_build_object(
      'conta', _conta
    );
  end if;

  update tweeks.conta
    set conta_imprensa = conta_imprensa +1,
        conta_colaborador_atualizacao = arg_colaborador_id,
        conta_dataatualizacao = current_timestamp
    where conta_id = arg_conta_id
    returning * into _conta
  ;

  return true ? jsonb_build_object(
    'conta', _conta
  );

exception when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 811 (class 1255 OID 17063)
-- Name: funct_change_conta_preparar(json); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_conta_preparar(args json) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para marcar os pedidos de cosinha como preparados
    args := {
      arg_espaco_auth: ID,
      arg_colaborador_id: ID,
      arg_conta_id: ID,
    }
  */
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_conta_id uuid not null default args->>'arg_conta_id';

  _const map.constant;
  _conta tweeks.conta;

begin

  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );


  if _conta.conta_estado != _const.conta_estado_aberto then
    return false ? 'Não pode marcar mais pedidos dessa conta como preparado!';
  end if;

  update tweeks.venda
    set venda_estadopreparacao = _const.venda_estadopreparacao_preparado
    where venda_estadopreparacao = _const.venda_estadopreparacao_pendente
      and venda_conta_id = arg_conta_id
      and venda_estado = _const.venda_estado_aberto
  ;

  return true ? 'success';

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 812 (class 1255 OID 17064)
-- Name: funct_change_espaco(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_espaco(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para atualizar as informações do espaco
    args := {
      arg_espaco_change: ID -- id do espao que ser atualizado
      arg_espaco_vender: BOOLEAN
      arg_espaco_auth: ID
      arg_colaborador_id: ID
      arg_espaco_nome: NOME
      arg_espaco_descricao: DESCRICAO
      arg_espaco_gerarfatura: BOOLEAN
      arg_espaco_configurar: BOOLEAN
      arg_espaco_posto_admin: UUID,
      xBranch:boolean
    }
  */

  arg_espaco_vender character varying not null default args->>'arg_espaco_vender';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_change uuid not null default args->>'arg_espaco_change';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_nome character varying not null default args->>'arg_espaco_nome';
  arg_espaco_descricao character varying default args->>'arg_espaco_descricao';
  arg_espaco_gerarfatura boolean not null default args->>'arg_espaco_gerarfatura';
  arg_espaco_configurar boolean not null default args->>'arg_espaco_configurar';
  arg_espaco_posto_admin uuid default args->>'arg_espaco_posto_admin';
  xBranch boolean default args->>'xBranch';
  _espaco tweeks.espaco;
begin
  xBranch := coalesce( xBranch, false );

  --Quando for uma atualização do propietario
  if not xBranch then
    update tweeks.espaco
      set espaco_nome = arg_espaco_nome,
          espaco_descricao = arg_espaco_descricao,
          espaco_vender = arg_espaco_vender,
          espaco_gerarfatura = arg_espaco_gerarfatura,
          espaco_configurar = arg_espaco_configurar,
          espaco_posto_admin = coalesce( arg_espaco_posto_admin, espaco_posto_admin ),

          espaco_colaborador_atualizaco = arg_colaborador_id,
          espaco_dataatualizacao = current_timestamp
      where espaco_id = arg_espaco_change
      returning * into _espaco
    ;
  else
    update tweeks.espaco
      set espaco_nome = arg_espaco_nome,
          espaco_colaborador_atualizaco = arg_colaborador_id,
          espaco_dataatualizacao = current_timestamp
      where espaco_id = arg_espaco_change
      returning * into _espaco;
  end if;

  return true ? jsonb_build_object(
    'espaco', _espaco
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text; ll jsonb;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 814 (class 1255 OID 17065)
-- Name: funct_change_espaco_configuracao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_espaco_configuracao(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para atualizar as informações do espaco
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID
      arg_espaco_configuracao: JSON
    }
  */
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_configuracao jsonb not null default args->'arg_espaco_configuracao';
  _espaco tweeks.espaco;
begin

  update tweeks.espaco
    set
        espaco_configuracao = arg_espaco_configuracao,
        espaco_colaborador_atualizaco = arg_colaborador_id,
        espaco_dataatualizacao = current_timestamp
    where espaco_id = arg_espaco_auth
    returning * into _espaco
  ;

  return true ? jsonb_build_object(
    'espaco', _espaco
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 815 (class 1255 OID 17066)
-- Name: funct_change_espaco_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_espaco_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para ativar ou desativar o estado do um artigo
    args = {
      arg_colaborador_id: ID,
      arg_espaco_id: ID
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_id uuid not null default args->>'arg_espaco_id';
  _const map.constant;
  _espaco tweeks.espaco;
begin

  _const := map.constant();
  _espaco := tweeks._get_espaco( arg_espaco_id );

  update tweeks.espaco
    set
      espaco_estado = lib.swith( espaco_estado, _const.espaco_estado_ativo, _const.espaco_estado_fechado  ),
      espaco_colaborador_atualizaco = arg_colaborador_id,
      espaco_dataatualizacao = current_timestamp
    where espaco_id = arg_espaco_id
    returning * into _espaco
  ;

  return true ? jsonb_build_object(
    'espaco', _espaco,
    'text', case
      when _espaco.espaco_estado = _const.espaco_estado_ativo   then format( 'O espaco "%s" foi ativado!', _espaco.espaco_nome )
      when _espaco.espaco_estado = _const.espaco_estado_fechado then format( 'O espaco "%s" foi desativo!', _espaco.espaco_nome )
    end
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 816 (class 1255 OID 17067)
-- Name: funct_change_espaco_migrate(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_espaco_migrate(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
    /**
      args := {
        arg_espaco_auth: uuid
        arg_colaborador_id: uuid
        espaco_id: uuid
        espaco_espaco_id uuid
      }
     */
    _espaco tweeks.espaco;
    _loop jsonb;
    _data record;
  begin
    _espaco := jsonb_populate_record( _espaco, args );
    _loop := tweeks.__infinity_loop( _espaco );

    if _espaco.espaco_id is null or _espaco.espaco_espaco_id is null then
      return lib.res_false( 'Necessario informar qual espaco e para onde sera alocado!' );
    end if;

    if _espaco.espaco_id = _espaco.espaco_espaco_id then
      return lib.res_false( 'Não pode migrar um espaco para ele proprio' );
    end if;


    if _loop is not null then
      return lib.res_false( 'Não pode alocar em um sub-espaço!' );
    end if;

    select
      tweeks.__branch_uid( null, _espaco.espaco_id ) as local_branch,
      tweeks.__branch_uid( null, _espaco.espaco_espaco_id ) as master_branc
      into _data
    ;

    if _data.local_branch != _data.master_branc then
      return lib.res_false('Não pode migra armazem de branchs diferentes' );
    end if;

    _espaco.espaco_colaborador_atualizaco := args->>'arg_colaborador_id';
    _espaco.espaco_dataatualizacao := current_timestamp;

    select ( "returning" ).* into _espaco
      from lib.sets_up( _espaco, defaults := array[ 'espaco_nivel']::text[] )
    ;

    return lib.res_true( jsonb_build_object(
      'esapco', _espaco
    ));
  end;
$$;


--
-- TOC entry 817 (class 1255 OID 17068)
-- Name: funct_change_fornecedor_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_fornecedor_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função atualiza o estado do fornecedor (ativa/desativa)
    args := {
      arg_colaborador_id: ID,
      arg_fornecedor_id: ID
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_fornecedor_id uuid not null default args->>'arg_fornecedor_id';

  _const map.constant;
  _fornecedor tweeks.fornecedor;

begin
  _const := map.constant();

  update tweeks.fornecedor
    set
      fornecedor_estado = lib.swith( fornecedor_estado,
          _const.maguita_fornecedor_estado_ativo,
          _const.maguita_fornecedor_estado_fechado
      ),
      fornecedor_dataatualizacao = current_timestamp,
      fornecedor_colaborador_atualizacao = arg_colaborador_id
    where fornecedor_id = arg_fornecedor_id
    returning * into _fornecedor;

  return true ? jsonb_build_object(
    'fornecedor', _fornecedor
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 818 (class 1255 OID 17069)
-- Name: funct_change_item_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_item_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para ativar ou desativar o estado do um artigo
    args = {
      arg_colaborador_id: ID,
      arg_item_id: ID
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_item_id uuid not null default args->>'arg_item_id';
  _const map.constant;
  _artigo tweeks.artigo;
begin

  _artigo :=  tweeks._get_item( arg_item_id );
  _const := map.constant();

  if _artigo.artigo_classe_id != _const.classe_itemextra then
    return false ? '@artigo-is-not-item-extra';
  end if;


  -- Abrir ou fechar o item
  update tweeks.artigo
    set
      artigo_estado = lib.swith( artigo_estado, _const.item_estado_ativo, _const.item_estado_fechado ),
      artigo_colaborador_atualizacao = arg_colaborador_id,
      artigo_dataatualizacao = current_timestamp
    where artigo_id = arg_item_id
    returning * into _artigo
  ;

  return true ? jsonb_build_object(
    'artigo', _artigo
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 819 (class 1255 OID 17070)
-- Name: funct_change_link_disable(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_link_disable(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para desativar uma link
    args := {
      arg_link_id: ID,
      arg_colaborador_id: ID
    }
   */

  arg_link_id uuid not null default args->>'arg_link_id';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';

  _const map.constant;
  _link tweeks.link;

begin

  lock tweeks.link in share mode;

  _const := map.constant();
  _link := tweeks._get_link( arg_link_id );

  if _link.link_estado != _const.link_estado_ativo then
    return false ? '@tweeks.link.is-closed';
  end if;

  -- Fechar os links e os sublink associados a esse
  update tweeks.link
    set link_estado = _const.link_estado_fechado,
        link_colaborador_atualizacao = arg_colaborador_id,
        link_dataatualizacao = current_timestamp
    where link_id in (
      with recursive aux as (
          select a.link_id
            from tweeks.link a
            where a.link_id = arg_link_id
        union all
          select a2.link_id
            from tweeks.link a2
              inner join aux on a2.link_link_id = aux.link_id
            where a2.link_estado = _const.link_estado_ativo
      )
      select link_id
        from aux
    );

  return true ? jsonb_build_object(
    'link', _link
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 820 (class 1255 OID 17071)
-- Name: funct_change_link_move(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_link_move(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para trocar duas link de posição
    arg_link_id: ID,
    arg_colaborador_id: ID,
    arg_move_incremento: ID,
   */
  _link tweeks.link;
  _const map.constant;

  arg_link_id uuid default args->>'arg_link_id';
  arg_move_incremento int2 default args->>'arg_move_incremento';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_link_start int2;
  arg_link_end int2;
  arg_incremento int2;
begin

  lock tweeks.link in share mode;

  _link := tweeks._get_link( arg_link_id );
  _const := map.constant();

  if arg_move_incremento = 0 then
    return false ? '@tweeks.link.move-none';
  end if;

  if _link.link_posicao + arg_move_incremento < 0 then
    return false ? '@move-position-invalid';
  end if;

  if _link.link_estado != _const.link_estado_ativo then
    return false ? '@tweeks.link.is-closed';
  end if;

  if arg_move_incremento > 0 then
    arg_link_start := _link.link_posicao;
    arg_link_end := _link.link_posicao + arg_move_incremento;
    arg_incremento := -1;
  else
    arg_link_start := _link.link_posicao + arg_move_incremento;
    arg_link_end := _link.link_posicao;
    arg_incremento := 1;
  end if ;

  -- Mover as links todas
  update tweeks.link
    set link_posicao = case
        when link_id = _link.link_id then link_posicao + arg_move_incremento
        else link_posicao + arg_incremento
      end,
      link_colaborador_atualizacao = arg_colaborador_id,
      link_dataatualizacao = current_timestamp
    where link_posicao between arg_link_start and arg_link_end
      and link_espaco_destino = _link.link_espaco_destino
      and coalesce( link_link_id, -1 ) = coalesce( _link.link_link_id, -1 )
      and link_estado = _const.link_estado_ativo
  ;

  return true ? jsonb_build_object(
    'link', array(
      select a
        from tweeks.link a
        where link_posicao between arg_link_start and arg_link_end
          and link_espaco_destino = _link.link_espaco_destino
          and coalesce( link_link_id, -1 ) = coalesce( _link.link_link_id, -1 )
          and link_estado = _const.link_estado_ativo
        order by a.link_posicao
    )
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 809 (class 1255 OID 17072)
-- Name: funct_change_link_switch(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_link_switch(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para trocar duas link de posição
    arg_link_id: ID_LINK_PARENT,
    arg_espaco_destino: ID,
    arg_espaco_auth: ID,
    arg_colaborador_id: ID
    arg_link_posicao_1: POSICAO
    arg_link_posicao_2: POSICAO,
   */
  _link tweeks.link;
  _const map.constant;

  arg_link_id uuid default args->>'arg_link_id';
  arg_espaco_destino uuid default args->>'arg_espaco_destino';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_link_posicao_1 int not null default args->>'arg_link_posicao_1';
  arg_link_posicao_2 int not null default args->>'arg_link_posicao_2';
begin

  lock tweeks.link in share mode;
  _const := map.constant();

  arg_espaco_destino := coalesce( arg_espaco_destino, arg_espaco_auth );

  update tweeks.link
    set link_posicao = lib.swith( link_posicao, arg_link_posicao_1, arg_link_posicao_2 ),
        link_colaborador_atualizacao = arg_colaborador_id,
        link_dataatualizacao = current_timestamp
    where link_posicao in ( arg_link_posicao_1, arg_link_posicao_2 )
      and link_estado = _const.link_estado_ativo
      and link_espaco_destino = arg_posto_id
      and coalesce( link_link_id, -1 ) = coalesce( arg_link_id, -1 )
  ;

  return true ? jsonb_build_object(
    'link', array(
      select a
        from tweeks.link a
        where link_posicao in ( arg_link_posicao_1, arg_link_posicao_2 )
          and link_estado = _const.link_estado_ativo
          and link_espaco_destino = arg_espaco_destino
          and coalesce( link_link_id, -1 ) = coalesce( arg_link_id, -1 )
        order by a.link_posicao
    )
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 821 (class 1255 OID 17073)
-- Name: funct_change_link_unlink(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_link_unlink(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_espaco_auth: ID,
      arg_colaborador_id: ID,
      arg_link_referencia: REF
    }
   */
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_link_referencia jsonb not null default args->'arg_link_referencia';
  _const map.constant;
begin
  _const := map.constant();

  update tweeks.link
    set link_estado = _const.link_estado_fechado,
        link_colaborador_atualizacao = arg_colaborador_id,
        link_dataatualizacao = current_timestamp
    where link_referencia @> arg_link_referencia
      and link_espaco_destino = any( arg_espaco_child )
      and link_estado = _const.link_estado_associacao
      and link_tlink_id = _const.tlink_associacao
  ;

  return true ? jsonb_build_object(
    'text', 'A associação ao espaço foi desativado com sucesso'
  );
end;
$$;


--
-- TOC entry 822 (class 1255 OID 17074)
-- Name: funct_change_mesa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_mesa(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para atualizar informação da mesa
    args := {
      arg_mesa_id: ID,
      arg_colaborador_id: ID,
      arg_mesa_designacao: DESIGNACAO,
      arg_mesa_numero: DESIGNACAO,
      arg_mesa_lotacao: DESIGNACAO
    }
   */
  arg_mesa_designacao character varying default args->>'arg_mesa_designacao';
  arg_mesa_numero character varying default args->>'arg_mesa_numero';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_mesa_id uuid not null default args->>'arg_mesa_id';
  _mesa tweeks.mesa;
begin

  -- Garantir que o numero de mesa seja unico
  if (
    select count( * ) > 0
      from tweeks.mesa m
      where m.mesa_numero =  arg_mesa_numero
        and m.mesa_id != arg_mesa_id
  ) then
    return false ? '@mesa.numero.already-exist';
  end if;

  update tweeks.mesa
    set mesa_designacao = coalesce( arg_mesa_designacao, mesa_designacao ),
        mesa_numero = coalesce( arg_mesa_numero, mesa_numero ),
        mesa_colaborador_atualizacao = arg_colaborador_id,
        mesa_dataatualizacao = current_timestamp
    where mesa_id = arg_mesa_id
    returning * into _mesa
  ;

  return true ? jsonb_build_object(
    'mesa', _mesa
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 824 (class 1255 OID 17075)
-- Name: funct_change_mesa_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_mesa_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função atualiza o estado da mesa
    args = {
      arg_colaborador_id: ID,
      arg_mesa_id: ID,
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_mesa_id uuid default args->>'arg_mesa_id';

  _const map.constant;
  _mesa tweeks.mesa;
begin

  _mesa := tweeks._get_mesa( arg_mesa_id );
  _const := map.constant();

  if _mesa.mesa_estado  not in ( _const.mesa_estado_disponivel, _const.mesa_estado_desativado ) then
    return false ? '@tweeks.mesa.estado.no-accept';
  end if;

  update tweeks.mesa
    set
      mesa_estado = lib.swith( _mesa.mesa_estado, _const.mesa_estado_disponivel, _const.mesa_estado_desativado ),
      mesa_dataatualizacao = current_timestamp,
      mesa_colaborador_atualizacao = arg_colaborador_id
    where mesa_id = arg_mesa_id
    returning * into _mesa
  ;

  return true ? jsonb_build_object(
      'mesa', _mesa
    );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 825 (class 1255 OID 17076)
-- Name: funct_change_ordem_classe(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_ordem_classe(parms jsonb) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    /** Essa função serve para caregar os artigos pelas sua categoria
      parms := [{
        parms_classe_id: ID
        parms_classe_position: SMALLINT
      }]
    */
    i jsonb;
begin
    for i in select * from jsonb_array_elements(parms)
    loop
        update tweeks.classe
            set
                classe_position = (i::jsonb ->>'parms_classe_position')::smallint
        where classe_id = (i::jsonb ->>'parms_classe_id')::uuid;
    end loop;
    return true;
end;
$$;


--
-- TOC entry 827 (class 1255 OID 17077)
-- Name: funct_change_posto_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_posto_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para ativar ou desativar o estado do um artigo
    args = {
      arg_colaborador_id: ID,
      arg_posto_id: ID
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_posto_id uuid not null default args->>'arg_posto_id';
  _const map.constant;
  _posto tweeks.posto;
begin

  _const := map.constant();
  _posto := tweeks._get_posto( arg_posto_id );

  if _posto.posto_estado = _const.maguita_posto_estado_aberto then
    return false ? 'Posto não pode ser encerrado!';
  end if;

  update tweeks.posto
    set
      posto_estado = lib.swith( posto_estado, _const.maguita_posto_estado_encerado, _const.maguita_posto_estado_fechado  ),
      posto_colaborador_atualizacao = arg_colaborador_id,
      posto_dataatualizacao = current_timestamp
    where posto_id = arg_posto_id
    returning * into _posto
  ;

  return true ? jsonb_build_object(
    'artigo', _posto,
    'artigo_old', _posto,
    'text', case
      when _posto.posto_estado = _const.maguita_posto_estado_fechado   then format( 'O posto "%s" foi ativado!', _posto.posto_designacao )
      when _posto.posto_estado = _const.maguita_posto_estado_encerado then format( 'O posto "%s" foi desativo!', _posto.posto_designacao )
    end
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 828 (class 1255 OID 17078)
-- Name: funct_change_posto_open(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_posto_open(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para que um colaborador abra a posto
    args := {
      arg_colaborador_id: ID,
      arg_colaborador_proprietario: ID,
      arg_posto_montante: MONTANTE
    }
   */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_colaborador_proprietario uuid not null default args->>'arg_colaborador_proprietario';
  arg_posto_montanteinicial double precision not null default args->>'arg_posto_montanteinicial';

  _const map.constant;
  _posto record;

begin
  _const := map.constant();

  select * into _posto
    from tweeks.posto cx
    where cx.posto_colaborador_proprietario = arg_colaborador_proprietario
      and cx.posto_estado in ( _const.posto_estado_ativo, _const.posto_estado_pendete )
  ;

  if _posto.posto_id is null then
    return false ? '@posto.colaborador.not-found';
  end if;

  if _posto.posto_montanteinicial != arg_posto_montanteinicial then
    return false ? 'Montante inicial incorreto!';
  end if;

  update tweeks.posto
    set posto_estado = _const.posto_estado_ativo,
        posto_colaborador_atualizacao = arg_colaborador_id,
        posto_dataatualizacao = current_timestamp
    where posto_id = _posto.posto_id
    returning * into _posto
  ;

  return true ? jsonb_build_object(
    'posto', _posto
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 829 (class 1255 OID 17079)
-- Name: funct_change_tipoimposto_estado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_tipoimposto_estado(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_tipoimposto_id: ID,
      arg_colaborador_id: ID,
    }
   */
  arg_tipoimposto_id int2 not null default args->>'arg_tipoimposto_id';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  _tipoimposto tweeks.tipoimposto;
  _const map.constant;
begin
  _const := map.constant();
  update tweeks.tipoimposto
    set tipoimposto_estado = lib.swith( tipoimposto_estado, _const.tipoimposto_estado_ativo, _const.tipoimposto_estado_fechado ),
        tipoimposto_colaborador_atualizacao = arg_colaborador_id,
        tipoimposto_dataatuzaliacao = current_timestamp
    where tipoimposto_id = arg_tipoimposto_id
    returning * into _tipoimposto
  ;

  return true ? jsonb_build_object(
    'tipoimposto', _tipoimposto
  );

end;
$$;


--
-- TOC entry 516 (class 1255 OID 17080)
-- Name: funct_change_venda(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_venda(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para associar mais vendas a conta
    args := {
      arg_colaborador_id: ID,
      arg_conta_id: ID,
      arg_message_error: TRUE|FALSE,
      arg_espaco_auth: ID,
      arg_vendas: [
        {
          arg_venda_id: ID,
          arg_venda_quantidade: QUANT,
          arg_venda_custounitario: CUSTO,

          arg_agregas: [
            {
              arg_item_id: ID,
              arg_item_quantidadecusto: QUANT/CUSTO
              arg_agrega_quantidade: QUANT,
              arg_item_custo: CUSTO,
              arg_agrega_montante: MONTANTE
            }
          ]
        }
      ]
    }*/

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_conta_id uuid not null default args->>'arg_conta_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_vendas jsonb not null default args->>'arg_vendas';
  arg_message_error boolean not null default args->>'arg_message_error';

  -- colocar todos os id dos artigos em uma lista
  arg_artigos_id uuid [ ] default array( select ( doc.venda->>'arg_artigo_id' )::uuid  from jsonb_array_elements( arg_vendas ) doc( venda ) );

  arg_items_id uuid [ ];

  _const map.constant;
  _conta tweeks.conta;
  _data record;
  _venda tweeks.venda;

begin
  arg_message_error := coalesce( arg_message_error, true );

  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );


  -- Garrantir que tenha o stock disponivel para os artigos
  with novas_vendas as (
    select
        ( dos.venda->>'arg_venda_id' )::uuid as arg_venda_id,
        ( dos.venda->>'arg_artigo_id' )::uuid as arg_artigo_id,
        ( dos.venda->>'arg_venda_quantidade' )::double precision as arg_venda_quantidade,
        ( dos.venda->>'arg_venda_custounitario' )::double precision as arg_venda_custounitario,
        dos.venda->'arg_agregas' as arg_agregas
    from jsonb_array_elements( arg_vendas ) dos( venda )
  )
  select
      count( art.artigo_id ) as artigo_total,
      string_agg( art.artigo_nome, ', ' ) as artigo_nomes
      into _data
    from novas_vendas vds
      inner join tweeks.venda ve on vds.arg_venda_id = ve.venda_id
      inner join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id
      inner join tweeks.stock st on art.artigo_id = st.stock_artigo_id
    where st.stock_espacao_id = arg_espaco_auth
      and not rule.artigo_has_stock( art.artigo_id, arg_espaco_auth, vds.arg_venda_quantidade -  ve.venda_quantidade )
  ;

  if _data.artigo_total > 0 and arg_message_error then
    raise exception '%', format( 'Os stock dos produtos "%s" não cobrem a venda para essa conta', _data.artigo_nomes );

  elsif _data.artigo_total > 0 then
    return false ? format( 'Os stock dos produtos "%s" não cobrem a venda para essa conta', _data.artigo_nomes );
  end if;


  -- Registar as novas vendas a conta
  for _data in
    with novas_vendas as (
      select
          ( dos.venda->>'arg_venda_id' )::uuid as arg_venda_id,
          ( dos.venda->>'arg_artigo_id' )::uuid as arg_artigo_id,
          ( dos.venda->>'arg_venda_quantidade' )::double precision as arg_venda_quantidade,
          ( dos.venda->>'arg_venda_custounitario' )::double precision as arg_venda_custounitario,
          dos.venda -> 'arg_agregas' as arg_agregas
        from jsonb_array_elements( arg_vendas ) dos( venda )
    )
    select *
      from novas_vendas nv
        inner join tweeks.venda ve on nv.arg_venda_id = ve.venda_id
  loop
    _data.venda_custounitario := _data.arg_venda_custounitario;
    _data.venda_quantidade := _data.arg_venda_quantidade;

    -- Anular o valor do montante anterior em campo montante
    _data.venda_montantetotal := _data.venda_montantetotal - _data.venda_montente;

    -- Atualizar o valor de novo montante
    _data.venda_montente := _data.arg_venda_quantidade * _data.arg_venda_custounitario;

    -- Atualizar o valor de montante total
    _data.venda_montantetotal := _data.venda_montantetotal + _data.venda_montente;

    update tweeks.venda
      set venda_quantidade = _data.venda_quantidade,
          venda_custounitario = _data.venda_custounitario,
          venda_montente = _data.venda_montente,
          venda_montantetotal = _data.venda_montantetotal,
          venda_espaco_auth = arg_espaco_auth
      where venda_id = _data.venda_id
      returning * into _venda
    ;

    arg_items_id := array( select ( doc.agrega->>'arg_item_id' )::uuid  from jsonb_array_elements( _data.arg_agregas ) doc( agrega ) );
    -- desagregar o item da venda
    update tweeks.agrega
      set agrega_estado = _const.agrega_estado_canselado,
          agrega_colaborador_atualizacao = arg_colaborador_id,
          agrega_dataatualizacao = current_timestamp
      where agrega_venda_id = _data.venda_id
        and agrega_artigo_item != all( arg_items_id )
        and agrega_estado = _const.agrega_estado_aberto
    ;

    -- aggregar os novos item a venda
    with item_preco as (
      select
        ( doc.agrega->>'arg_agrega_quantidade' )::double precision as arg_agrega_quantidade,
        ( doc.agrega->>'arg_item_quantidadecusto' )::double precision as arg_item_quantidadecusto,
        ( doc.agrega->>'arg_item_custo' )::double precision as arg_item_custo,
        ( doc.agrega->>'arg_item_id' )::uuid as arg_item_id
      from jsonb_array_elements( _data.arg_agregas ) doc( agrega )
    )
    insert into tweeks.agrega (
      agrega_venda_id,
      agrega_artigo_item,
      agrega_colaborador_id,
      agrega_quantidade,
      agrega_custounitario,
      agrega_montante,
      agrega_espaco_auth
    )
    select
        _data.venda_id,
        it.artigo_id,
        arg_colaborador_id,
        ip.arg_agrega_quantidade,
        ip.arg_item_custo,
        rule.calculate_cost( ip.arg_item_quantidadecusto, ip.arg_item_custo, ip.arg_agrega_quantidade ),
        arg_espaco_auth
      from tweeks.artigo it
        inner join item_preco ip on it.artigo_id = ip.arg_item_id
        left join agrega a on it.artigo_id = a.agrega_artigo_item
          and a.agrega_estado = _const.agrega_estado_aberto
      where it.artigo_id = any ( arg_items_id )
        and a.agrega_id is null
    ;

    -- Aplicar o calculo do imposto
    perform tweeks.funct_reg_vendaimposto(
      jsonb_build_object(
        'arg_colaborador_id', arg_colaborador_id,
        'arg_venda_id', _venda.venda_id,
        'arg_artigo_id', _venda.venda_artigo_id,
        'arg_espaco_auth', arg_espaco_auth
      )
    );

  end loop;

  return true ? jsonb_build_object(
    'venda', array (
      select to_jsonb( ve ) || jsonb_build_object(
          'venda_item', jsonb_agg( to_jsonb( agg ) || to_jsonb( it) )
        )
        from tweeks.venda ve
          left join tweeks.agrega agg on ve.venda_id = agg.agrega_venda_id
            and agg.agrega_estado = _const.agrega_estado_aberto
          left join tweeks.artigo it on agg.agrega_artigo_item = it.artigo_id
        where ve.venda_conta_id = arg_conta_id
          and ve.venda_artigo_id = any( arg_artigos_id )
          and ve.venda_estado = _const.venda_estado_aberto
        group by ve.venda_id
    ),

    'venda_all', array (
      select to_jsonb( ve ) || jsonb_build_object(
          'venda_item', jsonb_agg( to_jsonb( agg ) || to_jsonb( it) )
        )
        from tweeks.venda ve
          left join tweeks.agrega agg on ve.venda_id = agg.agrega_venda_id
            and agg.agrega_estado >= _const.agrega_estado_aberto
          left join tweeks.artigo it on agg.agrega_artigo_item = it.artigo_id
        where ve.venda_conta_id = arg_conta_id
          and ve.venda_estado >= _const.venda_estado_aberto
        group by ve.venda_id
    )
  );
end;
$$;


--
-- TOC entry 830 (class 1255 OID 17082)
-- Name: funct_change_venda_preparado(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_change_venda_preparado(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
    declare
      /**
          args := {
            arg_colaborador_id: UID
            arg_espaco_auth: UID
            arg_conta_id: UID
            arg_vendas: [UID, UID, ..., UID]
          }
       */
      arg_colaborador_id uuid default args->>'arg_colaborador_id';
      arg_espaco_auth uuid default args->>'arg_espaco_auth';
      
      ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
      vendas uuid[] default array( select e.text from jsonb_array_elements_text( args->'arg_vendas' ) e( text) );
      _const map.constant;
      updates tweeks.venda[];
    begin
      _const := map.constant();
      with __update as (
          update tweeks.venda
            set venda_estadopreparacao = _const.maguita_venda_estadopreparacao_preparado,
                venda_colaborador_atualizacao = arg_colaborador_id
            where venda_id = any( vendas )
              and _branch_uid = ___branch
              and venda_estado = _const.maguita_venda_estadopreparacao_pendente
            returning *
      ) select array_agg( u ) into updates
          from __update u 
      ;
      
      
      return lib.res_true( jsonb_build_object(
        'venda', updates
      ));
    end;
  $$;


--
-- TOC entry 831 (class 1255 OID 17083)
-- Name: funct_generate_chave(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_generate_chave(args jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _chave tweeks.chave;
  arg_chave_descricao character varying default args->>'arg_chave_descricao';
  letters character varying default 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  numbers character varying default '0123456789';
begin
  _chave.chave_temporarai := format( '%s-%s-%s',
      lib.dset_random_text( letters, 3 ),
      lib.dset_random_text( numbers||letters||numbers, 3 ),
      lib.dset_random_text( numbers, 3 )
  );
  insert into tweeks.chave(
    chave_temporarai,
    chave_descricao
  ) values (
    _chave.chave_temporarai,
    arg_chave_descricao
  ) returning * into _chave;
  return next  to_jsonb( _chave );
end;
$$;


--
-- TOC entry 832 (class 1255 OID 17084)
-- Name: funct_load_acerto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_acerto(filter jsonb) RETURNS TABLE(acerto_id uuid, acerto_quantidade double precision, acerto_diferenca double precision, acerto_quantidadeinicial double precision, acerto_observacao character varying, acerto_estado smallint, acerto_dataregistro timestamp with time zone, acerto_dataatualizacao timestamp with time zone, artigo_id uuid, artigo_nome character varying, artigo_codigo character varying, espaco_id uuid, espaco_nome character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver a listagem dos acertos

  filter := {
    arg_artigo_id: ID,
    arg_espaco_id: ID
    arg_espaco_auth: ID
  }
  */

  arg_artigo_id uuid default filter ->>'arg_artigo_id';
  arg_espaco_auth uuid not null default filter ->>'arg_espaco_auth';
  arg_espaco_id uuid default filter ->>'arg_espaco_id';
  arg_espaco_loads uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
begin

  return query
    select
        acc.acerto_id,
        acc.acerto_quantidade,
        acc.acerto_diferenca,
        acc.acerto_quantidadeinicial,
        acc.acerto_observacao,
        acc.acerto_estado,
        acc.acerto_dataregistro,
        acc.acerto_dataatualizacao,

        art.artigo_id,
        art.artigo_nome,
        art.artigo_codigo,

        esp.espaco_id,
        esp.espaco_nome
      from tweeks.acerto acc
        inner join tweeks.stock sto on acc.acerto_stock_id = sto.stock_id
        inner join tweeks.artigo art on sto.stock_artigo_id = art.artigo_id
        inner join tweeks.espaco esp on sto.stock_espacao_id = esp.espaco_id
      where art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
        and esp.espaco_id = coalesce( arg_espaco_id, esp.espaco_id )
        and esp.espaco_id = any( arg_espaco_loads )
    ;
end;
$$;


--
-- TOC entry 833 (class 1255 OID 17085)
-- Name: funct_load_artig_check_nome(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_artig_check_nome(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função devolve todos os artigos com os nomes expecificados
    filter := {
      arg_espaco_auth: ID
      arg_artigo_nome: [
        @+nome/artigo,
        @+nome/artigo,
        @+nome/artigo,
        @+nome/artigo
      ]
    }
   */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_artigo_nome character varying [] default array( select lib.str_normalize( public.unaccent( lower( names ) ) ) from jsonb_array_elements_text( filter->'arg_artigo_nome' ) names );
  arg_espaco_child uuid[] := rule.espaco_get_childrens( arg_espaco_auth );
begin
  return query
    select lib.jsonb_values(
          to_jsonb( art ),
          'artigo_id',
          'artigo_nome',
          'artigo_custo',
          'artigo_descricao',
          'artigo_dataregistro'
        )
      from tweeks.artigo art
      where lower( lib.str_normalize( lower( public.unaccent( art.artigo_nome ) ) ) ) = any ( arg_artigo_nome )
        and art.artigo_espaco_auth = any( arg_espaco_child )
    ;
end;
$$;


--
-- TOC entry 408 (class 1255 OID 17086)
-- Name: funct_load_artigo(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_artigo(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /**
        Essa função serve para carregar os artigos registrado
        args := {
          arg_espaco_auth: ID
          arg_colaborador_id: ID
          arg_classe_id: ID
          arg_artigo_estado: ARTIGO_ESTADO
          query: {
            any?: CODE|NAME|DESCRICAO
            code?: CODE
            name?: NAME
            desc?: DESCRICAO
          }
        }
   */
    arg_espaco_auth uuid default args->>'arg_espaco_auth';
    arg_colaborador_id uuid default args->>'arg_colaborador_id';
    arg_espaco_childs uuid[] default rule.espaco_get_childrens_static( arg_espaco_auth );
    arg_classe_id uuid default args->>'arg_classe_id';
    arg_artigo_estado int2 default args->>'arg_artigo_estado';

    _query_any text  default lower( args->'query'->>'any' );
    _query_code text default lower( args->'query'->>'code' );
    _query_name text default lower( args->'query'->>'name' );
    _query_desc text default lower( args->'query'->>'desc' );
    _const map.constant;
    _branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
    _const := map.constant();

    /**
      ID, NOME, STOCK, PRECO, [STOK-MINIMO], FOTO
     */
    return query
        with
          __stock as (
            select
                fluxo_artigo_id as stock_artigo_id,
                fluxo_espaco_id as stock_espaco_id,
                fluxo_resultado as stock_quantidade
              from tweeks.__fluxo_scan(
                _branch := _branch,
                _espaco_id := arg_espaco_auth,
                _resume := true
              )
          ), __artigo as (
            select
                art.artigo_id,
                art.artigo_codigo,
                art.artigo_descricao,
                art.artigo_nome,
                art.artigo_compostoquantidade,
                art.artigo_artigo_id,

                art.artigo_espaco_auth = any( arg_espaco_childs ) as artigo_owner,
                coalesce( s.stock_quantidade, 0 ) as stock_quantidade,
                art.artigo_foto,
                art.artigo_espaco_auth,
                art.artigo_classe_id,
                art.artigo_estado,
                art.artigo_stocknegativo,
                art.artigo_codigoimposto,
                origin.artigo_id as origin_id,
                origin.artigo_codigo as origin_codigo,
                origin.artigo_descricao as orign_descricao,
                origin.artigo_nome as origin_nome,
                origin.artigo_compostoquantidade as orign_compostoquantidade,
                origin.artigo_artigo_id as origin_origin_id,

                coalesce( array_agg( l.link_espaco_destino ) filter ( where l.link_id is not null ), array[]::uuid[] )  as links,
                ( lib.first( l.link_metadata ) filter ( where l.link_espaco_destino = arg_espaco_auth ) )->>'precario_custo' as precario_custo,
                ( lib.first( l.link_metadata ) filter ( where l.link_espaco_destino = arg_espaco_auth ) )->>'precario_quantidade' as precario_quantidade,
                ( ( lib.first( l.link_metadata ) filter ( where l.link_espaco_destino = arg_espaco_auth ) )->>'stock_minimo' )::double precision as link_stockminimo
              from tweeks.artigo art
                left join tweeks.artigo origin on art.artigo_artigo_id = origin.artigo_id
                left join tweeks.link l on l.link_estado = _const.maguita_link_estado_ativo
                  and l.link_referencia = rule.artigo_referencia( art.artigo_id )
                  and l.link_espaco_destino = any( arg_espaco_childs )
                  and l.link_tlink_id = _const.maguita_tlink_preco
                  and l._branch_uid = _branch
                left join __stock s on art.artigo_id = s.stock_artigo_id and s.stock_espaco_id = arg_espaco_auth
              where art._branch_uid = _branch
              group by art.artigo_id,
                 origin.artigo_id,
                s.stock_quantidade
          ), __filter as (
            select *,
                coalesce( art.link_stockminimo ) as stock_minimo
              from __artigo art
              where ( coalesce( art.links, array[]::uuid[] )||art.artigo_espaco_auth ) && arg_espaco_childs
                and art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
                and art.artigo_estado = coalesce( arg_artigo_estado, art.artigo_estado )
         ), __filter_query as (
            select *
            from __filter f
            where arg_classe_id is not null or f.artigo_classe_id != _const.classe_itemextra
            order by
              case
                when f.artigo_estado = _const.artigo_estado_ativo then 1
                else 2
              end,
              case
                when f.artigo_espaco_auth = arg_espaco_auth then 1
                when f.artigo_espaco_auth = any( arg_espaco_childs ) then 2
                else 3
              end,
              case
                when stock_quantidade < f.stock_minimo then 1
                when stock_quantidade = f.stock_minimo then 2
                else 3
               end,
               f.artigo_nome
           ), __query as (
             select *
                from __filter_query _f
                where true
                  and lower( _f.artigo_codigo ) = lower( coalesce( _query_code, _f.artigo_codigo ) )
                  and lower( _f.artigo_nome ) like lower( format( '%%%s%%', coalesce( _query_name, _f.artigo_nome ) ) )
                  and lower( coalesce( _f.artigo_descricao, '' ) ) like lower( format( '%%%s%%', coalesce( _query_desc, _f.artigo_descricao ) ) )
                  and (
                    lower( _f.artigo_codigo ) = lower( coalesce( _query_any, _f.artigo_codigo ) )
                    or lower( _f.artigo_nome) like lower( format( '%%%s%%', coalesce( _query_any, _f.artigo_nome ) ) )
                    or lower( coalesce( _f.artigo_descricao, '' ) ) like lower( format( '%%%s%%', coalesce( _query_any, _f.artigo_descricao, '' ) ))
                  )
          ) select to_jsonb( _q ) - 'links'
              from __query _q
    ;
end
$$;


--
-- TOC entry 789 (class 1255 OID 17087)
-- Name: funct_load_artigo_associar(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_artigo_associar(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para carregar os artigos associados
    filter := {
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  _const map.constant;
begin
  _const := map.constant();

  return query
    with aux as (
      select *
        from tweeks.link l
          inner join tweeks.artigo art on l.link_artigo_id = art.artigo_id
        where l.link_estado = _const.link_estado_associacao
          and l.link_tlink_id = _const.tlink_associacao
          and l.link_espaco_destino = arg_espaco_auth
          and art.artigo_estado = _const.artigo_estado_ativo
    ) select lib.jsonb_values(
      aux,
      'link_id',
      'artigo_id',
      'artigo_nome'
    )
    from aux;
end;
$$;


--
-- TOC entry 834 (class 1255 OID 17088)
-- Name: funct_load_artigo_base(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_artigo_base(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    arg_espaco_auth: UID
    arg_colaborador_id: UID
    arg_artigo_composto: UID

    arg_classe_id: ID
        arg_artigo_estado: ARTIGO_ESTADO
        query: {
          any?: CODE|NAME|DESCRICAO
          code?: CODE
          name?: NAME
          desc?: DESCRICAO
        }
   */
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_artigo_composto uuid default args->>'arg_artigo_composto';

  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _artigo tweeks.artigo;
  _result record;
begin
  _artigo := tweeks._get_artigo( arg_artigo_composto );

  with recursive __artigos as (
    select
        art.artigo_id,
        art.artigo_nome,
        art.artigo_artigo_id,
        array[ art.artigo_id ]::uuid[] as path
      from tweeks.artigo art
      where art._branch_uid = ___branch
        and art.artigo_artigo_id is null
    union all
      select
          es.artigo_id,
          es.artigo_nome,
          es.artigo_artigo_id,
          _e.path || es.artigo_id
        from __artigos _e
          inner join tweeks.artigo es on _e.artigo_id = es.artigo_artigo_id
        where es._branch_uid = ___branch
  ) select array_agg( _art.artigo_id ) as artigos into _result
      from __artigos _art
      where  arg_artigo_composto is null or (
          arg_artigo_composto != all( _art.path )
        and _art.artigo_id != coalesce( _artigo.artigo_artigo_id, _artigo.artigo_id )
        and _art.artigo_id != _artigo.artigo_id
      )
  ;
  
  return query
    select e.document
      from tweeks.funct_load_artigo( args ) e( document )
      where (e.document->>'artigo_id')::uuid = any( _result.artigos )
  ;
end;
$$;


--
-- TOC entry 835 (class 1255 OID 17089)
-- Name: funct_load_artigo_data(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_artigo_data(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_espaco_auth: UUDI,
      arg_colaborador_id: UUID,
      artigos:[
        UUID, UUID, UUID
      ]
    }
   */
  arg_espaco_auth uuid not null default args ->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args ->>'arg_colaborador_id';
  artigos uuid[] default array( select e.text::uuid from jsonb_array_elements_text( args->'artigos' ) e( text ));
  _const map.constant;
begin
  _const := map.constant();

  return query
    with
      __extras as (
        select
            d.dispoe_artigo_id,
            array_agg( to_jsonb( d ) || jsonb_build_object( 'artigo_nome', art.artigo_nome) ) as extras
          from tweeks.dispoe d
            inner join tweeks.artigo art on d.dispoe_artigo_item = art.artigo_id
          where d.dispoe_artigo_id = any( artigos )
            and d.dispoe_estado = _const.dispoe_estado_ativo
          group by d.dispoe_artigo_id
      ), __eans as (
        select
            e.ean_artigo_id,
            array_agg( to_jsonb( e ) ) as eans
          from tweeks.ean e
          where e.ean_artigo_id = any( artigos )
            and e.ean_estado = _const.maguita_ean_estado_ativo
          group by e.ean_artigo_id
    ), __links as (
      select
          art.artigo_id,
          array_agg( to_jsonb( l ) )  as links
        from tweeks.link l
          inner join tweeks.artigo art on  l.link_referencia @> lib.sets_ref( art )
        where l.link_tlink_id = _const.maguita_tlink_preco
          and art.artigo_id = any( artigos )
          and l.link_estado = _const.maguita_link_estado_ativo
        group by art.artigo_id
    ), __impostos as (
      select
          ip.imposto_artigo_id,
          array_agg( to_jsonb( ip ) ) as impostos
        from tweeks.imposto ip
        where ip.imposto_artigo_id = any( artigos )
          and ip.imposto_estado = _const.maguita_imposto_estado_ativo
        group by ip.imposto_artigo_id
    ), __artigos as (
        select art.*, cla.*, to_jsonb( a ) as artigo_base
          from tweeks.artigo art
            left join tweeks.artigo a on art.artigo_artigo_id = a.artigo_id
            left join tweeks.classe cla on art.artigo_classe_id = cla.classe_id
          where art.artigo_id = any( artigos )
    ), __exports as (
      select
          e.extras,
          ea.eans,
          l.links,
          ip.impostos,
          a.*
        from __artigos a
          left join __extras e on a.artigo_id = e.dispoe_artigo_id
          left join __eans ea on a.artigo_id = ea.ean_artigo_id
          left join __links l on a.artigo_id = l.artigo_id
          left join __impostos ip on a.artigo_id = ip.imposto_artigo_id
    ) select to_jsonb( exp )
      from __exports exp
    ;
end
$$;


--
-- TOC entry 836 (class 1255 OID 17090)
-- Name: funct_load_artigo_simple(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_artigo_simple(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(artigo_id uuid, artigo_nome character varying, artigo_descricao character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Devolver uma lista simples de artigos
    filter :{
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;

begin
  _const := map.constant();
  return query
    select
        art.artigo_id,
        art.artigo_nome,
        art.artigo_descricao
      from tweeks.artigo art
      where art.artigo_estado = _const.artigo_estado_ativo
        and art.artigo_classe_id != _const.classe_itemextra
        and art.artigo_espaco_auth = any( arg_espaco_child )
  ;
end;
$$;


--
-- TOC entry 826 (class 1255 OID 17091)
-- Name: funct_load_autorizacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_autorizacao(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
  {
    arg_colaborador_id: UID
    arg_espaco_auth: UID
  }
 */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _espaco_child uuid[] default rule.espaco_get_childrens_static( arg_espaco_auth );

  _const map.constant;

begin
  _const := map.constant();
  return query
    with __autorizacao as (
      select
          a.autorizacao_uid,
          a.autorizacao_numero,
          a.autorizacao_ano,
          a.autorizacao_estado,
          a.autorizacao_designacao,
          a.autorizacao_dataregistro,
          e.espaco_id,
          e.espaco_nome,
          count( at.* ) filter ( where at.autorizacao_ano > a.autorizacao_ano ) as autorizacao_postone,
          count( at.* ) filter ( where at.autorizacao_ano < a.autorizacao_ano ) as autorizacao_previews
        from tweeks.autorizacao a
          inner join tweeks.espaco e on a.autorizacao_espaco_uid = e.espaco_id
          left join tweeks.autorizacao at on at.autorizacao_espaco_uid = a.autorizacao_espaco_uid
            and at._branch_uid = a._branch_uid
            and at.autorizacao_ano != a.autorizacao_ano
        where a._branch_uid = arg_branch_uid
          and true in (
            a.autorizacao_espaco_auth = any( _espaco_child ),
            a.autorizacao_espaco_uid = any( _espaco_child )
          )
        group by
          a.autorizacao_uid,
          e.espaco_id
    ), __continue as (
       select
            at.*,
            case
              when at.autorizacao_estado = _const.maguita_autorizacao_estado_fechado and at.autorizacao_postone = 0 then true
              else false
            end as autorizacao_continue
          from __autorizacao at
    ) select to_jsonb( _a )
        from __continue _a
        order by _a.autorizacao_ano desc,
          _a.autorizacao_dataregistro desc
  ;
end;
$$;


--
-- TOC entry 837 (class 1255 OID 17092)
-- Name: funct_load_branch(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_branch(args jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
begin
  return query with
    __branh as (
      select
          b.branch_uid,
          b.branch_name,
          b.branch_path,
          b.branch_licence,
          b.branch_grants,
          b.branch_main_user,
          b.branch_main_workspace,
          b.branch_clusters,
          b.branch_date,
          b.branch_update,
          b.branch_state,
          tb.*,
          e.espaco_id,
          e.espaco_nome,
          e.espaco_nivel,
          e.espaco_estado,
          e.espaco_codigo,
          e.espaco_vender,
          c.colaborador_id,
          c.colaborador_nome,
          c.colaborador_email,
          c.colaborador_apelido,
          c.colaborador_tipo
        from tweeks.branch b
          inner join tweeks.tbranch tb on  b.branch_tbranch_id = tb.tbranch_id
          left join tweeks.espaco e on b.branch_uid = e.espaco_branch_uid
            and e.espaco_id = b.branch_main_workspace
          left join auth.colaborador c on b.branch_uid = c.colaborador_branch_uid
            and c.colaborador_id = b.branch_main_user
    ) select to_jsonb( _b )
      from __branh _b
  ;
end;
$$;


--
-- TOC entry 838 (class 1255 OID 17093)
-- Name: funct_load_caixa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_caixa(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /** Essa função serve para devolver todas as caixas
      arg_espaco_auth: ID,
      arg_caixa_estado: [ ],
      arg_posto_showmontante: boolean,

     */
    arg_espaco_auth uuid default filter->>'arg_espaco_auth';
    arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
    arg_caixa_estado int2[] default array( select jsonb_array_elements_text( filter->'arg_caixa_estado' )::int2 );
    arg_posto_showmontante boolean default filter->>'arg_posto_showmontante';
    arg_show  text[];
    _const map.constant;
begin
    _const := map.constant();

    if filter->'arg_caixa_estado' is null then
        arg_caixa_estado := array[ _const.caixa_estado_ativo ];
    end if;

    arg_show := array[
        'caixa_id',
        'caixa_montanteinicial',
        'caixa_montantefecho',
        'caixa_montanteinicialposto',
        'caixa_montantefechoposto',
        'caixa_quantidadecheque',
        'caixa_observacao',
        'posto_id',
        'posto_designacao',
        'colaborador_id',
        'colaborador_nome',
        'colaborador_apelido'
        ];

    if arg_posto_showmontante then
        arg_show := arg_show || array[
            'posto_montante',
            'conta_cheques',
            'conta_montantevenda',
            'caixa_montante'
            ];
    end if;

    return query
        with loads as (
            select
                cx.*,
                pos.*,
                col.*,
                count( distinct ct.conta_id ) conta_cheques,
                sum( ct.conta_montante ) as conta_montantevenda,
                cx.caixa_montanteinicial + sum( ct.conta_montante ) as caixa_montante
            from tweeks.caixa cx
                     inner join tweeks.posto pos on cx.caixa_posto_id = pos.posto_id
                     inner join auth.colaborador col on cx.caixa_colaborador_id = col.colaborador_id
                     left join tweeks.conta ct on cx.caixa_id = ct.conta_caixa_fechopagamento
                and ct.conta_estado = _const.conta_estado_pago
            where cx.caixa_estado = any( arg_caixa_estado )
              and cx.caixa_espaco_auth = any( arg_espaco_child )
            group by cx.caixa_id,
                     pos.posto_id,
                     col.colaborador_id
            order by
                case
                    when cx.caixa_estado = _const.caixa_estado_ativo then 1
                    when cx.caixa_estado = _const.cambio_estado_fechado then 3
                    else 2
                    end asc,
                cx.caixa_dataregistro desc
        ) select lib.jsonb_values( to_jsonb( l ), variadic arg_show )
        from loads l
    ;
end;
$$;


--
-- TOC entry 839 (class 1255 OID 17094)
-- Name: funct_load_caixa_by_colaborador(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_caixa_by_colaborador(filter jsonb) RETURNS TABLE(caixa_id uuid, caixa_montanteinicial double precision, caixa_estado smallint, caixa_dataregistro timestamp with time zone, caixa_dataatualizacao timestamp with time zone, posto_id uuid, posto_designacao character varying, posto_montante double precision, posto_estado smallint, posto_dataregistro timestamp with time zone, posto_dataatualizacao timestamp with time zone, espaco_id uuid, espaco_nome character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para carragar a posto do colaborador
    filter := {
      arg_colaborador_id: ID,
    }
   */
  arg_colaborador_id uuid default filter->>'arg_colaborador_id';
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
      ab.caixa_id,
      ab.caixa_montanteinicial,
      ab.caixa_estado,
      ab.caixa_dataregistro,
      ab.caixa_dataatualizacao,
      cx.posto_id,
      cx.posto_designacao,
      cx.posto_montante,
      cx.posto_estado,
      cx.posto_dataregistro,
      cx.posto_dataatualizacao,
      esp.espaco_id,
      esp.espaco_nome
    from tweeks.caixa ab
      inner join tweeks.posto cx on ab.caixa_posto_id = cx.posto_id
      inner join tweeks.espaco esp on cx.posto_espaco_id = esp.espaco_id
    where ab.caixa_colaborador_id = arg_colaborador_id
      and ab.caixa_estado = _const.caixa_estado_ativo
      and cx.posto_estado = _const.posto_estado_aberto
  ;
end;
$$;


--
-- TOC entry 526 (class 1255 OID 17095)
-- Name: funct_load_cambio_ativo(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_cambio_ativo(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql STRICT
    AS $$
declare
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
  _data record;
begin
  _const := map.constant();

  select * into _data
    from geoinfo.currency cu 
      left join tweeks.cambio cb on cb.cambio_currency_id = cu.currency_id
        and cb.cambio_estado = _const.cambio_estado_ativo
        and cb.cambio_espaco_auth = arg_espaco_auth
        and cb._branch_uid = ___branch
    where upper( cu.currency_code )  = 'STN'
  ;
  
  if _data.cambio_id is null then
    insert into tweeks.cambio (
      cambio_currency_id,
      cambio_espaco_auth, 
      cambio_colaborador_id, 
      cambio_taxa, 
      _branch_uid
    ) values (
      _data.currency_id,
      arg_espaco_auth,
      _const.colaborador_system_data,
      1,
      ___branch
    );
  end if;

  return query
    with __cambio as (
      select
          cb.cambio_id,
          cb.cambio_data,
          cb.cambio_taxa,
          cb.cambio_dataregistro,
          cu.currency_id,
          cu.currency_name,
          cu.currency_code,
          cu.currency_symbol,
          rank() over ( partition by cb.cambio_currency_id order by
            case when cambio_espaco_auth = arg_espaco_auth then 1 else 2 end,
            cb.cambio_dataregistro desc )  as cambio_rank
        from tweeks.cambio cb
          inner join geoinfo.currency cu on cb.cambio_currency_id = cu.currency_id
        where cb.cambio_estado = _const.cambio_estado_ativo
          and cb.cambio_espaco_auth = arg_espaco_auth
          and cb._branch_uid = ___branch
    ) select
        to_jsonb( cb )
      from __cambio cb
      where cb.cambio_rank = 1
  ;
end;
$$;


--
-- TOC entry 840 (class 1255 OID 17096)
-- Name: funct_load_cambio_history(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_cambio_history(filter jsonb) RETURNS TABLE(cambio_id uuid, cambio_taxa double precision, cambio_data date, cambio_estado smallint, cambio_dataregistro timestamp with time zone, cambio_dataatualizacao timestamp with time zone, currency_id smallint, currency_name character varying, currency_symbol character varying, currency_code character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função carrega os cambios ativo
    filter := {
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  _const map.constant;
begin
  _const := map.constant();
  return query
    select
        cb.cambio_id,
        cb.cambio_taxa,
        cb.cambio_data,
        cb.cambio_estado,
        cb.cambio_dataregistro,
        cb.cambio_dataatualizacao,

        cur.currency_id,
        cur.currency_name,
        cur.currency_code,
        cur.currency_symbol

      from tweeks.cambio cb
        inner join geoinfo.currency cur on cb.cambio_currency_id = cur.currency_id
      where cb.cambio_espaco_auth = arg_espaco_auth
      order by cb.cambio_data desc,
        cb.cambio_dataregistro desc
  ;
end;
$$;


--
-- TOC entry 841 (class 1255 OID 17097)
-- Name: funct_load_chave(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_chave(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    arg_chave_temporaria: CHAVE-TEMP
   */
    arg_chave_temporaria character varying default args->>'arg_chave_temporaria';
    _const map.constant;
begin
  _const := map.constant();
  if arg_chave_temporaria is null then
      return query
          select to_jsonb( ch )
            from tweeks.chave ch
            where (ch.chave_date + interval '24' hour )  > now()
              and ch.chave_definitiva is null;
  else
      return query
          select to_jsonb( ch ) || coalesce( to_jsonb( p ), jsonb_build_object()) || jsonb_build_object(
                'posto_disponivel', coalesce( p.posto_estado != _const.maguita_posto_estado_encerado, false )
            )
          from tweeks.chave ch
            left join tweeks.posto p on ch.chave_definitiva = p.posto_chave
          where ch.chave_temporarai = arg_chave_temporaria
      ;
  end if;
end;
$$;


--
-- TOC entry 912 (class 1255 OID 17098)
-- Name: funct_load_classe(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_classe(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para carregar as listas de classes ativas
    filter := {
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
begin
  _const := map.constant();

  return query
    with
      __espaco as ( select e.espaco_id, e.espaco_nome from tweeks.espaco e),
      __links as (
        select
            l.link_referencia,
            l.link_espaco_destino,
            array_agg( to_jsonb( e ) ) as espacos
          from  __espaco e
            inner join tweeks.link l on e.espaco_id = l.link_espaco_destino
          where l.link_estado = _const.maguita_link_estado_ativo
            and l.link_tlink_id = _const.maguita_tlink_classe
          group by l.link_referencia,
            l.link_espaco_destino

        ),
      __classe as (
        select
            cla.classe_id,
            cla.classe_classe_id,
            cla.classe_nome,
            cla.classe_foto,
            cla.classe_position,
            jsonb_build_object(
              'total', count( distinct atr.artigo_id ),
              'ativos', count( distinct atr.artigo_id ) filter ( where atr.artigo_estado = _const.artigo_estado_ativo )
            ) as artigos,
            coalesce( l.espacos, array[]::jsonb[] ) as classe_espacos

        from tweeks.classe cla
          left join __links l on ( l.link_referencia->>'classe_id' )::uuid = cla.classe_id
          left join tweeks.artigo atr on cla.classe_id = atr.artigo_classe_id
        where cla.classe_estado = _const.classe_estado_ativo
          and ( 
            cla.classe_espaco_auth = any( arg_espaco_child )
              or l.link_espaco_destino = any( arg_espaco_child )
              or cla.classe_id = _const.classe_itemextra
          )
        group by cla.classe_id, cla.classe_nome, l.espacos
        order by
          case
            when cla.classe_id != _const.classe_itemextra then 1
            else 2
          end,
          cla.classe_nome
      ) select to_jsonb( c )
          from __classe c
    ;
end;
$$;


--
-- TOC entry 843 (class 1255 OID 17099)
-- Name: funct_load_classe_simple_report(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_classe_simple_report(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(classe_id uuid, classe_nome character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para carregar as listas de classes ativas
    filter := {
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
        cla.classe_id,
        cla.classe_nome
      from tweeks.classe cla
        left join tweeks.link l on l.link_referencia @> jsonb_build_object( 'classe_id', cla.classe_id )
          and l.link_estado = _const.link_estado_associacao
          and l.link_tlink_id = _const.tlink_associacao
      where cla.classe_estado = _const.classe_estado_ativo
        and ( cla.classe_espaco_auth = any( arg_espaco_child ) or l.link_espaco_auth = any( arg_espaco_child ) or l.link_espaco_destino = any( arg_espaco_child ) )
      group by cla.classe_id
      order by
        case
          when cla.classe_id != _const.classe_itemextra then 1
          else 2
        end asc,
        cla.classe_nome asc
    ;

  return query select null::int2, 'Desativados'::varchar;
end;
$$;


--
-- TOC entry 844 (class 1255 OID 17100)
-- Name: funct_load_cliente(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_cliente(args jsonb) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_espaco_auth: UUID,
      arg_colaborador_id: UUID,
      query: {
        any?: any
        code?: CODE,
        name?: NAME
        mail?: MAIL
        tel?: TEL
        nif?: NIF
      }
    }
   */
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  __branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id );
  _const map.constant;

  _query_any  text default lower( args->'query'->>'any' );
  _query_code text default lower( args->'query'->>'code' );
  _query_name text default lower( args->'query'->>'name' );
  _query_mail text default lower( args->'query'->>'mail' );
  _query_tel  text default lower( args->'query'->>'tel' );
  _query_nif  text default lower( args->'query'->>'nif' );
begin
  _const := map.constant();
  return query
    with
      __deposito as (
        select
            la.lancamento_cliente_id,
            sum( la.lancamento_valor ) as balanco_credito,
            sum( la.lancamento_valor ) filter ( where la._tgrupo_id = _const.maguita_tgrupo_cnormal ) as   balanco_creditonormal,
            sum( la.lancamento_valor ) filter ( where la._tgrupo_id = _const.maguita_tgrupo_ccorrente ) as balanco_creditocorrente,
            count( la.lancamento_id ) as depositos
          from tweeks.lancamento la
          where la._branch_uid = __branch_uid
            and la.lancamento_operacao = 1
            and la.lancamento_estado =  _const.maguita_lancamento_estado_ativo
          group by la.lancamento_cliente_id

      ), __conta as (
        select
            la.lancamento_cliente_id,
            sum( la.lancamento_valor ) as balanco_debito,
            sum( la.lancamento_valor ) filter ( where la._tgrupo_id = _const.maguita_tgrupo_cnormal ) as   balanco_debitonormal,
            sum( la.lancamento_valor ) filter ( where la._tgrupo_id = _const.maguita_tgrupo_ccorrente ) as balanco_debitocorrente
          from tweeks.lancamento la
          where la._branch_uid = __branch_uid
            and la.lancamento_estado = _const.maguita_lancamento_estado_ativo
            and la.lancamento_operacao = -1
          group by la.lancamento_cliente_id

      ), __cliente as (
        select
            c.cliente_id,
            c.cliente_code,
            c.cliente_titular,
            c.cliente_nif,
            c.cliente_contactos,
            c.cliente_mail,
            c.cliente_estado,
            c.cliente_metadata,
            c.cliente_dataregistro,
            coalesce( _de.balanco_credito, 0.0 ) as balanco_credito,
            coalesce( _de.balanco_creditonormal, 0.0 ) as balanco_creditonormal,
            coalesce( _de.balanco_creditocorrente, 0.0 ) as balanco_creditocorrente,
            coalesce( _de.depositos, 0 ) as depositos,
            coalesce( _ct.balanco_debito, 0.0 ) as balanco_debito,
            coalesce( _ct.balanco_debitocorrente, 0.0 ) as balanco_debitocorrente,
            coalesce( _ct.balanco_debitonormal, 0.0 ) as balanco_debitonormal
          from tweeks.cliente c
            left join __deposito _de on c.cliente_id = _de.lancamento_cliente_id
            left join __conta _ct on c.cliente_id = _ct.lancamento_cliente_id
          where c._branch_uid = __branch_uid
      ), __cliente_saldo as (
        select
            _c.*,
            _c.balanco_creditonormal - _c.balanco_debitonormal as balanco_normal,
            _c.balanco_creditocorrente - _c.balanco_debitocorrente as balanco_corrente,
            _c.balanco_credito - _c.balanco_debito as balanco_final
          from __cliente _c
      ), __query as (
        select *
          from __cliente_saldo _cl
          where true
            and _cl.cliente_code = coalesce( _query_code, _cl.cliente_code )
            and coalesce( _cl.cliente_nif, '') = coalesce( _query_nif, _cl.cliente_nif, '' )
            and lower( _cl.cliente_titular ) like lower( format( '%%%s%%', coalesce( _query_name, _cl.cliente_titular ) ) )
            and lower( coalesce( _cl.cliente_mail, '' ) ) like lower( format( '%%%s%%', coalesce( _query_mail, _cl.cliente_mail, '' ) ) )
            and ( coalesce( _cl.cliente_contactos, jsonb_build_array()) || to_jsonb(''::text) ) @> to_jsonb(coalesce( _query_tel, '' ) )
            and ( false
                or _cl.cliente_code = coalesce( _query_any, _cl.cliente_code )
                or coalesce( _cl.cliente_nif, '') = coalesce( _query_any, _cl.cliente_nif, '' )
                or lower( _cl.cliente_titular ) like lower( format( '%%%s%%', coalesce( _query_any, _cl.cliente_titular ) ) )
                or lower( coalesce( _cl.cliente_mail, '' ) ) like lower( format( '%%%s%%', coalesce( _query_any, _cl.cliente_mail, '' ) ) )
                or (_cl.cliente_contactos || to_jsonb(''::text) ) @> to_jsonb(coalesce( _query_any, '' ) )
            )
      ) select to_json( _q )
        from __query _q;
end
$$;


--
-- TOC entry 845 (class 1255 OID 17101)
-- Name: funct_load_cluster_by_branch(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_cluster_by_branch(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_branch_uid: UID
    }
   */
  arg_branch_uid uuid default args->>'arg_branch_uid';
  _branch tweeks.branch;
begin
  _branch := tweeks.__get_branch( arg_branch_uid );

  return query with
    __clusters as (
      select
          c.cluster_identifier,
          c.cluster_name,
          c.cluster_configs,
          c.cluster_type,
          c.cluster_path,
          c.cluster_grants,
          c.cluster_version,
          c.cluster_sequence
        from cluster.cluster c
        where c.cluster_identifier = any( _branch.branch_clusters )
    ) select to_jsonb( c )
      from __clusters c;
end;
$$;


--
-- TOC entry 846 (class 1255 OID 17102)
-- Name: funct_load_colaborador(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_colaborador(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa função sere para carregar os colaborador apartir dos filtros expecificados
      filetr := {
        arg_espaco_auth: ID
      }
     */
    arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
    arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
    _const map.constant;
begin
    _const :=  map.constant();

    return query with
        __espacos as (
            select
                   e.espaco_id,
                   e.espaco_nivel,
                   e.espaco_nome,
                   tr.trabalha_colaborador_proprietario
               from tweeks.espaco e
                  inner join tweeks.trabalha tr on e.espaco_id = tr.trabalha_espaco_destino
                    and tr.trabalha_estado = _const.maguita_trabalha_estado_ativo
                where e.espaco_estado = _const.maguita_espaco_estado_ativo
        ), __colaborador as(
            select
                co.colaborador_id,
                co.colaborador_nome,
                co.colaborador_apelido,
                co.colaborador_email,
                co.colaborador_estado,
                co.colaborador_tipo,
                auth._colaborador_estado_desc( co.colaborador_estado ) as colaborador_estado_desc,
                co.colaborador_accesso,
                auth._colaborador_accesso_desc( co.colaborador_accesso ) as colaborador_accesso_desc,
                co.colaborador_foto,
                s2.tsexo_id,
                s2.tsexo_nome,
                s2.tsexo_codigo,
                co.colaborador_datanascimento,
                co.colaborador_nif,
                co.colaborador_dataregisto,
                co.colaborador_espaco_auth,
                min( e.espaco_nivel ) as espaco_minnivel,
                max( e.espaco_nivel ) as espaco_maxnivel,
                jsonb_agg( to_jsonb( e ) ) as colaborador_espacotrabalha,
                array_agg( e.espaco_id )||co.colaborador_espaco_auth as espacos
              from auth.colaborador co
                left join auth.tsexo s2 ON co.colaborador_tsexo_id = s2.tsexo_id
                left join __espacos e on co.colaborador_id = e.trabalha_colaborador_proprietario
              where co.colaborador_tipo in ( _const.colaborador_tipo_user, _const.colaborador_tipo_user_master )
                and ( co.colaborador_estado = _const.colaborador_estado_ativo or co.colaborador_tipo = _const.colaborador_tipo_user_master )
              group by co.colaborador_id,
                s2.tsexo_id
        )  select to_jsonb( co )
          from __colaborador co
          where arg_espaco_auth = any ( co.espacos )
        order by
            case
              when co.colaborador_espaco_auth = arg_espaco_auth then 1
              else 2
            end,
            espaco_minnivel,
            case
                when co.colaborador_accesso = _const.colaborador_accesso_ativo then 1
                when co.colaborador_accesso = _const.colaborador_accesso_pendente then 2
                when co.colaborador_accesso = _const.colaborador_accesso_fechado then 3
            end,
            co.colaborador_nome,
            co.colaborador_apelido

    ;
end;
$$;


--
-- TOC entry 847 (class 1255 OID 17103)
-- Name: funct_load_conta_by_caixa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_conta_by_caixa(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função server para devolver a lista de todas as contas pagas em uma caixa
    filter := {
      arg_caixa_id: ID
    }
   */
  arg_caixa_id uuid default filter->>'arg_caixa_id';
  _const map.constant;
begin
  _const := map.constant();

  return query
    select to_jsonb( tweeks.funct_load_conta_data( jsonb_build_object( 'arg_conta_id', ct.conta_id ) ) )
      from tweeks.conta ct
      where ct.conta_caixa_fechopagamento = arg_caixa_id
        and ct.conta_estado = _const.conta_estado_pago
  ;
end;
$$;


--
-- TOC entry 406 (class 1255 OID 134421)
-- Name: funct_load_conta_notacredito(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_conta_notacredito(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: UID
      arg_espaco_auth: UID
      conta_fatura
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _conta_fatura character varying := args->>'conta_fatura';
  _const map.constant;
begin
  _const := map.constant();
  return query
    with __venda as (
      select
          ve.*,
          art.*,
          sum( tx.taxa_taxa ) as taxa_taxa,
          sum( tx.taxa_percentagem ) as taxa_percentagem
        from tweeks.venda ve
          inner join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id
          left join tweeks.taxa tx on tx.taxa_id = any( venda_taxas )
        where ve._branch_uid  = arg_branch
          and ve.venda_venda_id is null
          and ve.venda_estado = _const.maguita_venda_estado_fechado
        group by ve.venda_id,
          art.artigo_id
    ), __venda_group as (
      select
          _ve.venda_id,
          _ve.venda_conta_id,
          array_agg( to_jsonb( _vei ) ) as venda_itens
        from __venda _ve
          left join __venda _vei on _ve.venda_id = _vei.venda_venda_id
        where _ve.venda_venda_id is null
        group by _ve.venda_id,
          _ve.venda_conta_id

    ), __conta as (
      select
        ct.*,
        array_agg( to_jsonb( _veg ) || to_jsonb( _ved ) ) as conta_vendas
        from tweeks.conta ct
          inner join __venda_group _veg on ct.conta_id = _veg.venda_conta_id
          inner join __venda _ved on _veg.venda_id = _ved.venda_id
          left join tweeks.venda venda_ncred on _veg.venda_id = venda_ncred.venda_venda_docorign
            and venda_ncred.venda_estado = _const.maguita_venda_estado_fechado
        where ct._branch_uid = arg_branch
          and ct.conta_estado = _const.maguita_conta_estado_fechado
          and venda_ncred.venda_id is null
          and ct.conta_numerofatura = _conta_fatura
        group by ct.conta_id
    ) select to_jsonb( _ct )
        from __conta _ct
  ;
end;
$$;


--
-- TOC entry 849 (class 1255 OID 17104)
-- Name: funct_load_conta_preparacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_conta_preparacao(filter jsonb) RETURNS TABLE(conta_id uuid, conta_numero integer, conta_titular character varying, conta_titularnif character varying, conta_data date, conta_numerofatura character varying, conta_montante double precision, conta_montanteamortizado double precision, conta_estado smallint, conta_imprensa smallint, conta_dataregistro timestamp with time zone, conta_dataatualizacao timestamp with time zone, mesa_id uuid, mesa_numero character varying, mesa_lotacao smallint, mesa_designacao character varying, currency_id smallint, currency_code character varying, currency_name character varying, tpaga_id smallint, tpaga_designacao character varying, colaborador_id uuid, colaborador_nome character varying, colaborador_apelido character varying, vendas jsonb)
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função devolve uma mesa juntamente com as conta associada que ainda esta aberta
    filter := {
      arg_conta_id
    }
   */
  arg_conta_id uuid default filter->>'arg_conta_id';

  _const map.constant;
begin

  _const := map.constant();

  return query
    with conta_venda as (
      select
          art.*,
          ve.*,
          coalesce(
            jsonb_agg(
            lib.jsonb_values_as(
              to_jsonb( agg ) || to_jsonb( it ),
              'artigo_id', 'item_id',
              'artigo_nome', 'item_nome',
              'artigo_custo', 'item_custo',
              'agrega_id', 'agrega_id',
              'agrega_quantidade', 'agrega_quantidade',
              'agrega_custounitario', 'agrega_custounitario',
              'agrega_montante', 'agrega_montante'
            ) order by it.artigo_nome asc ) filter ( where it.artigo_id is not null ),
            jsonb_build_array()
          ) as items
        from tweeks.venda ve
          inner join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id
          left join tweeks.agrega agg on ve.venda_id = agg.agrega_venda_id
            and agg.agrega_estado in ( _const.agrega_estado_aberto, _const.agrega_estado_fechado )
          left join tweeks.artigo it on agg.agrega_artigo_item = it.artigo_id
        where ve.venda_estado in ( _const.venda_estado_aberto )
          and ve.venda_estadopreparacao = _const.venda_estadopreparacao_pendente
        group by art.artigo_id,
        ve.venda_id
    )
    select
      ct.conta_id,
      ct.conta_numero,
      ct.conta_titular,
      ct.conta_titularnif,
      ct.conta_data,
      ct.conta_numerofatura,
      ct.conta_montante,
      ct.conta_montanteamortizado,
      ct.conta_estado,
      ct.conta_imprensa,
      ct.conta_dataregistro,
      ct.conta_dataatualizacao,

      m.mesa_id,
      m.mesa_numero,
      m.mesa_lotacao,
      m.mesa_designacao,

      cur.currency_id,
      cur.currency_code,
      cur.currency_name,

      tpag.tpaga_id,
      tpag.tpaga_designacao,

      col.colaborador_id,
      col.colaborador_nome,
      col.colaborador_apelido,
      jsonb_agg(
          lib.jsonb_values(
            to_jsonb( vd ),
            'artigo_id',
            'artigo_codigo',
            'artigo_nome',
            'artigo_custo',
            'artigo_stocknegativo',
            'venda_id',
            'venda_quantidade',
            'venda_custounitario',
            'venda_montente',
            'venda_montanteagregado',
            'venda_montantetotal',
            'venda_estado',
            'items'
            )
          order by vd.artigo_nome asc
        )
    from tweeks.conta ct
      inner join auth.colaborador col on ct.conta_colaborador_id = col.colaborador_id
      left join tweeks.mesa m on ct.conta_mesa_id = m.mesa_id
      left join geoinfo.currency cur on ct.conta_currency_id = cur.currency_id
      left join tweeks.tpaga tpag on ct.conta_tpaga_id = tpag.tpaga_id
      left join conta_venda vd on ct.conta_id = vd.venda_conta_id

    where ct.conta_id = arg_conta_id
    group by
      ct.conta_id,
      m.mesa_id,
      col.colaborador_id,
      tpag.tpaga_id,
      cur.currency_id
  ;
end;
$$;


--
-- TOC entry 823 (class 1255 OID 17105)
-- Name: funct_load_deposito_data(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_deposito_data(args jsonb) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      deposito_id: UUID
    }
   */
  _deposito tweeks.deposito;
begin
  _deposito := jsonb_populate_record( _deposito, args );
  select * into _deposito
    from tweeks.deposito d
    where d.deposito_id = _deposito.deposito_id
  ;

  return query
    with __deposito as (
      select
          de.deposito_id,
          de.deposito_documento,
          de.deposito_montante,
          de.deposito_montantefinal,
          de.deposito_montantetroco,
          de.deposito_montantemoeda,
          de.deposito_referencia,
          de.deposito_docref,
          de.deposito_data,
          de.deposito_dataregistro,
          de.deposito_observacao,
          de._tgrupo_id,
          tp.tpaga_id,
          tp.tpaga_designacao,
          cu.currency_name,
          cu.currency_code,
          cu.currency_symbol,
          cli.cliente_id,
          cli.cliente_nif,
          cli.cliente_titular,
          col.colaborador_id,
          col.colaborador_nome,
          col.colaborador_apelido,
          col.colaborador_email,
          cx.caixa_id,
          po.posto_id,
          po.posto_designacao,
          po.posto_matricula
        from tweeks.deposito de
          inner join tweeks.cliente cli on de.deposito_cliente_id = cli.cliente_id
          inner join tweeks.tpaga tp on de.deposito_tpaga_id = tp.tpaga_id
          inner join geoinfo.currency cu on de.deposito_currency_id  = cu.currency_id
          inner join auth.colaborador col on de.deposito_colaborador_id = col.colaborador_id
          left join tweeks.caixa cx on de.deposito_caixa_id = cx.caixa_id
          left join tweeks.posto po on cx.caixa_posto_id = po.posto_id
        where de.deposito_id = _deposito.deposito_id
    ) select to_json( _d )
        from __deposito _d
  ;

  return query
    select to_json( reg )
      from tweeks.__lancamento_regularizacao( jsonb_build_object(
        'cliente_id', _deposito.deposito_cliente_id,
        'tgrupo_id', _deposito._tgrupo_id,
        'braunc_uid', _deposito._branch_uid
      )) reg
      where _deposito.deposito_id = any( reg.regula_refid )
  ;
end;
$$;


--
-- TOC entry 850 (class 1255 OID 17106)
-- Name: funct_load_device_unregistered(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_device_unregistered(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_dispositivos: [
        {
          client_ip: IP
          client_mac: IP
          client_hostname: HOSTNAME
          client_ipv4: IPV4
          client_ipv6: IPV6
          client_distro: DISTRO
          client_platform: PLATFORM
          client_vendor: VENDOR
          client_user: USER
        }
      ]
    }
   */
  arg_dispositivos jsonb default filter->'arg_dispositivos';
begin
  return query
  with devices_found as (
    select
        el.document->>'client_ip' as posto_ip,
        el.document->>'client_mac' as posto_mac,
        el.document->>'client_hostname' as posto_hostname,
        el.document->>'client_ipv6' as posto_ipv6,
        el.document->>'client_distro' as posto_distro,
        el.document->>'client_vendor' as posto_vendor,
        el.document->>'client_user' as posto_user,
        coalesce( el.document->>'client_user', el.document->>'client_hostname' ) as client_label
      from jsonb_array_elements( arg_dispositivos ) el( document )
  ), no_registred as (
    select dvf.*,
           case
             when dvf.client_label is not null then format( '%s (%s)', dvf.posto_mac, dvf.client_label )
             else  dvf.posto_mac
          end as client_label
      from devices_found dvf
        left join tweeks.posto pt on dvf.posto_mac = pt.posto_mac
      where pt.posto_id is null
  )  select lib.jsonb_values(
        nr,
        'posto_ip',
        'posto_mac',
        'posto_hostname',
        'posto_ipv4',
        'posto_ipv6',
        'posto_distro',
        'posto_platform',
        'posto_vendor',
        'posto_user',
        'client_label'
      )
    from no_registred nr
  ;
end;
$$;


--
-- TOC entry 851 (class 1255 OID 17107)
-- Name: funct_load_entrada(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_entrada(filter jsonb) RETURNS TABLE(entrada_id uuid, entrada_data date, entrada_codigofatura character varying, entrada_quantidade double precision, entrada_montante double precision, entrada_descricao character varying, entrada_estado smallint, entrada_dataregistro timestamp with time zone, entrada_dataatualizacao timestamp with time zone, artigo_id uuid, artigo_nome character varying, artigo_codigo character varying, espaco_id uuid, espaco_nome character varying, fornecedor_id uuid, fornecedor_nome character varying, fornecedor_nif character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /**
      Essa função serve para listar as entradas de artigos no stock
      filter := {
        arg_fornecedor_id: ID,
        arg_artigo_id: ID,
        arg_local_id: ID,
      }
   */

  arg_fornecedor_id uuid default filter ->>'arg_fornecedor_id';
  arg_artigo_id uuid default filter ->> 'arg_artigo_id';
  arg_espaco_id uuid default filter->>'arg_espaco_id';
  arg_espaco_auth uuid default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );

begin
  return query
    select
        ent.entrada_id ,
        ent.entrada_data,
        ent.entrada_codigofatura,
        ent.entrada_quantidade,
        ent.entrada_montante,
        ent.entrada_descricao,
        ent.entrada_estado,
        ent.entrada_dataregistro,
        ent.entrada_dataatualizacao,

        art.artigo_id,
        art.artigo_nome,
        art.artigo_codigo,

        esp.espaco_id,
        esp.espaco_nome,

        forn.fornecedor_id,
        forn.fornecedor_nome,
        forn.fornecedor_nif
      from tweeks.entrada ent
        inner join tweeks.artigo art on ent.entrada_artigo_id = art.artigo_id
        inner join tweeks.espaco esp on ent.entrada_espaco_id = esp.espaco_id
        inner join tweeks.fornecedor forn on ent.entrada_fornecedor_id = forn.fornecedor_id
      where forn.fornecedor_id = coalesce( arg_fornecedor_id, forn.fornecedor_id )
        and art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
        and esp.espaco_id = coalesce( arg_espaco_id, esp.espaco_id )
        and forn.fornecedor_espaco_auth = any( arg_espaco_child )
      order by ent.entrada_data desc,
        ent.entrada_dataregistro desc
    ;
end;
$$;


--
-- TOC entry 852 (class 1255 OID 17108)
-- Name: funct_load_espaco(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_espaco(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função lista todos os espacos registrado no sistema
    filter := {
      arg_espaco_auth: ID,
      arg_colaborador_id: UID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default filter->>'arg_colaborador_id';
  arg_espaco_child uuid[] default rule.espaco_get_childrens_static( arg_espaco_auth );
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
begin

  _const := map.constant();
  return query
    with __espaco as (

    select
        esp.espaco_id,
        esp.espaco_nome,
        esp.espaco_vender,
        esp.espaco_descricao,
        esp.espaco_codigo,
        esp.espaco_estado,
        esp.espaco_dataregistro,
        esp.espaco_dataatualizacao,
        esp.espaco_gerarfatura,
        esp.espaco_configurar,
        esp.espaco_configuracao,
        esp.espaco_nivel,
        esp.espaco_posto_admin,
        clu.cluster_identifier,
        clu.cluster_name,
        po.posto_id,
        po.posto_designacao,
        po.posto_chave,
        po.posto_matricula

      from tweeks.espaco esp
        inner join tweeks.branch br on esp.espaco_branch_uid = br.branch_uid
          and br.branch_uid = ___branch
        left join tweeks.posto po on esp.espaco_posto_admin = po.posto_id
        left join cluster.cluster clu on clu.cluster_identifier = esp.espaco_vender
--           and clu.cluster_identifier = any( br.branch_clusters )
      where esp.espaco_espaco_id = any( arg_espaco_child )
        or esp.espaco_id = arg_espaco_auth
      order by esp.espaco_nivel,
        esp.espaco_nome
    ) select to_jsonb( e  )
      from __espaco e
  ;
end;
$$;


--
-- TOC entry 848 (class 1255 OID 17109)
-- Name: funct_load_espaco_configuracao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_espaco_configuracao(filter jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  /**
    Essa função serve para devolver o espaço onde deve ser processado a fatura
    arg_espaco_auth := ID
   */
  arg_espaco_id uuid not null default filter->>'arg_espaco_auth';
  _espaco record;
begin

--   Obter o espaço superior que pode gerar numero de seire
    with recursive __espaco as (
      select e.*, e.espaco_gerarfatura as __generate_serie
      from tweeks.espaco e
      where e.espaco_id = arg_espaco_id
      union all
      select w.*, w.espaco_configurar
        from __espaco _e
          inner join tweeks.espaco w on _e.espaco_espaco_id = w.espaco_id
        and not _e.__generate_serie
    ) select * into _espaco from __espaco __e
      where __e.__generate_serie
    ;

--   with recursive parent as (
--       select e.* from tweeks.espaco e where e.espaco_id = arg_espaco_id
--     union all
--       select e.*
--         from parent p
--           inner join tweeks.espaco e on p.espaco_espaco_id = e.espaco_id
--         where not p.espaco_configurar
--   ) select l.* into _espaco
--   from parent l
--     where l.espaco_configurar
--   ;

  _espaco.espaco_configurar := arg_espaco_id = _espaco.espaco_id and _espaco.espaco_configurar;

  return jsonb_build_object(
    'espaco', lib.jsonb_values( _espaco, 'espaco_configurar', 'espaco_configuracao', 'espaco_id', 'espaco_nome' )
  );
end;
$$;


--
-- TOC entry 853 (class 1255 OID 17110)
-- Name: funct_load_espaco_migrate(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_espaco_migrate(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    arg_espaco_migracao: UID
    arg_espaco_id: UID
    arg_colaborador_id: UID
   */
  arg_espaco_id uuid default args->>'arg_espaco_id';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_migracao uuid default args->>'arg_espaco_migracao';

  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_id );
  _espaco tweeks.espaco;
begin
  _espaco := tweeks._get_espaco( arg_espaco_migracao );

  return query
    with recursive __espaco as (
      select
          e.espaco_id,
          e.espaco_nome,
          e.espaco_nivel,
          e.espaco_espaco_id,
          array[ e.espaco_id ]::uuid[] as path
        from tweeks.espaco e
        where e.espaco_nivel = 1
          and _branch_uid = _branch_uid
      union all
        select
            es.espaco_id,
            es.espaco_nome,
            es.espaco_nivel,
            es.espaco_espaco_id,
            _e.path || es.espaco_id
          from __espaco _e
            inner join tweeks.espaco es on _e.espaco_id = es.espaco_espaco_id
          where es._branch_uid = ___branch
    ) select to_jsonb( _es )
        from __espaco _es
        where arg_espaco_migracao != all( _es.path )
          and _es.espaco_id != _espaco.espaco_espaco_id
  ;
end;
$$;


--
-- TOC entry 854 (class 1255 OID 17111)
-- Name: funct_load_espaco_simple(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_espaco_simple(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função lista os espacos ativos
    filter := {
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
begin

  _const := map.constant();
  return query
    with __espaco as (
        select
          esp.espaco_id,
          esp.espaco_nome,
          esp.espaco_codigo,
          esp._branch_uid
        from tweeks.espaco esp
        where esp.espaco_estado = _const.maguita_espaco_estado_ativo
          and ( esp.espaco_espaco_id = any( arg_arg_espaco_child ) or esp.espaco_id = arg_espaco_auth )
        order by esp.espaco_nome
    ) select to_jsonb( e )
        from __espaco e
  ;
end;
$$;


--
-- TOC entry 855 (class 1255 OID 17112)
-- Name: funct_load_fornecedor(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_fornecedor(filter jsonb) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para listar os fornecedores da base de dados
    filter := {
      arg_espaco_auth: ID,
      arg_colaborador_id: UID,
      query: {
        any:,
        code: CODE,
        name: NAME,
        mail: MAIL,
        tel: CONTACTO,
        nif: NIF,
        address: ENDERECO

      }
    }
  */
  arg_espaco_auth uuid default filter->>'arg_espaco_auth';
  arg_colaborador_id uuid default filter->>'arg_colaborador_id';
  arg_espaco_child uuid[ ] default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
  _branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );

  _query_any text default lower( filter->'query'->>'any' );
  _query_code text default lower( filter->'query'->>'code' );
  _query_name text default lower( filter->'query'->>'name' );
  _query_mail text default lower( filter->'query'->>'mail' );
  _query_tel text default lower( filter->'query'->>'tel' );
  _query_nif text default lower( filter->'query'->>'nif' );
  _query_address text default lower( filter->'query'->>'address' );
begin
  _const := map.constant();

  return query
    with __fornecedor as  (
      select
        fo.fornecedor_id,
        fo.fornecedor_code,
        fo.fornecedor_nif,
        fo.fornecedor_nome,
        fo.fornecedor_email,
        fo.fornecedor_contacto,
        fo.fornecedor_endereco,
        fo.fornecedor_estado,
        fo.fornecedor_dataregistro,
        fo.fornecedor_dataatualizacao
      from tweeks.fornecedor fo
      where fo.fornecedor_espaco_auth = any( arg_espaco_child )
        and fo.fornecedor_estado = _const.maguita_fornecedor_estado_ativo
        and fo._branch_uid = _branch
      order by fo.fornecedor_nome
    ), __query as  (
        select _f.*
          from __fornecedor _f
          where true
            and coalesce( _f.fornecedor_code, '' ) = coalesce( _query_code, _f.fornecedor_code, '' )
            and coalesce( _f.fornecedor_nif, '' ) = coalesce( _query_nif, _f.fornecedor_nif, '' )
            and coalesce( _f.fornecedor_contacto, '' ) = coalesce( _query_tel, _f.fornecedor_contacto, '' )
            and lower( coalesce( _f.fornecedor_nome, '' ) ) like lower( format( '%%%s%%', coalesce( _query_name, _f.fornecedor_nome, '' ) ) )
            and lower( coalesce( _f.fornecedor_email, '' ) ) like lower( format( '%%%s%%', coalesce( _query_mail, _f.fornecedor_email, '' ) ) )
            and lower( coalesce( _f.fornecedor_endereco, '' ) ) like lower( format( '%%%s%%', coalesce( _query_address, _f.fornecedor_endereco, '' ) ) )
            and ( false
              or coalesce( _f.fornecedor_code, '' ) = coalesce( _query_any, _f.fornecedor_code, ''  )
              or coalesce( _f.fornecedor_nif, '') = coalesce( _query_any, _f.fornecedor_nif, ''  )
              or coalesce( _f.fornecedor_contacto, '' ) = coalesce( _query_any, _f.fornecedor_contacto, '' )
              or lower( coalesce( _f.fornecedor_nome, '' ) ) like lower( format( '%%%s%%', coalesce( _query_name, _f.fornecedor_nome, '' ) ) )
              or lower( coalesce( _f.fornecedor_email, '' ) ) like lower( format( '%%%s%%', coalesce( _query_mail, _f.fornecedor_email, '' ) ) )
              or lower( coalesce( _f.fornecedor_endereco, '' ) ) like lower( format( '%%%s%%', coalesce( _query_address, _f.fornecedor_endereco, '' ) ) )
            )
    )
    select to_json( f )
      from __query f
  ;
end;
$$;


--
-- TOC entry 856 (class 1255 OID 17113)
-- Name: funct_load_fornecedor_simple(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_fornecedor_simple(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(fornecedor_id uuid, fornecedor_nome character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para listar todos os fornecedores ativaos (lista para as selects do form)
    filter := {
      arg_espaco_auth: ID
    }
    */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[]not null default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
        fo.fornecedor_id,
        fo.fornecedor_nome
      from tweeks.fornecedor fo
      where fo.fornecedor_estado = _const.fornecedor_estado_ativo
        and fo.fornecedor_espaco_auth = any( arg_espaco_child )
      order by fo.fornecedor_nome
  ;
end;
$$;


--
-- TOC entry 857 (class 1255 OID 17114)
-- Name: funct_load_guia_data(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_guia_data(args jsonb) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      guia_id UUID,
      arg_colaborador_id UUID
      arg_espaco_auth UUID
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';

  _guia tweeks.guia;
  _const map.constant;
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
  _const := map.constant();
  _guia := jsonb_populate_record( _guia, args );
  select * into _guia
    from tweeks.guia
    where guia_uid = _guia.guia_uid
      and _branch_uid = ___branch
  ;

  return next json_build_object( 'type', cluster.__format( pg_typeof( _guia )::text::regclass ), 'data', _guia );

  return query with __custoguia as (
    select ent as data, cluster.__format( ent.tableoid ) as type
      from tweeks.custoguia ent
      where ent.custoguia_guia_uid = _guia.guia_uid
        and ent.custoguia_estado = _const.maguita_custoguia_estado_ativo
        and ent._branch_uid = ___branch
  ) select to_json( _e ) from __custoguia _e;

  if _guia.guia_toperacao_id = _const.maguita_toperacao_entrada then
    return query with __raw as (
      select ent.*,
             art.artigo_id,
             art.artigo_nome,
             art.artigo_codigo,
          cluster.__format( ent.tableoid ) as type
        from tweeks.entrada ent
          inner join tweeks.artigo art on ent.entrada_artigo_id = art.artigo_id
        where ent.entrada_guia_id = _guia.guia_uid
          and ent.entrada_estado = _const.entrada_estado_ativo
          and ent._branch_uid = ___branch
    ), __entrada as (
      select to_json( r ) as data, r.type
        from __raw r
    ) select to_json( _e ) from __entrada _e;

    return query with __fornecedor as (
      select ent as data, cluster.__format( ent.tableoid ) as type
        from tweeks.fornecedor ent
      where ent._branch_uid = ___branch
        and ent.fornecedor_id = _guia.guia_refuid
        and _guia.guia_refclass::regclass = ent.TABLEOID::regclass
    ) select to_json( _f ) from __fornecedor _f;

  elseif _guia.guia_toperacao_id = _const.maguita_toperacao_venda then
    return query with __venda as (
      select ent as data, cluster.__format( 'tweeks.conta'::regclass ) as type
      from tweeks.funct_pos_load_conta_data( args ) ent
    ) select to_json( _e ) from __venda _e;

  end if;
end
$$;


--
-- TOC entry 858 (class 1255 OID 17115)
-- Name: funct_load_items_simple(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_items_simple(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(artigo_id uuid, artigo_nome character varying, artigo_descricao character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /** Devolver uma lista simples de items
    arg_espaco_auth: ID
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  _const map.constant;
begin
  _const := map.constant();
  return query
    select
        art.artigo_id,
        art.artigo_nome,
        art.artigo_descricao
      from tweeks.artigo art
      where art.artigo_estado = _const.artigo_estado_ativo
        and art.artigo_classe_id = _const.classe_itemextra
        and art.artigo_espaco_auth = any( arg_espaco_child )
  ;
end;
$$;


--
-- TOC entry 859 (class 1255 OID 17116)
-- Name: funct_load_lancamento(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_lancamento(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: UID,
      arg_espaco_auth: UID,
      arg_cliente_id: UID,
      arg_lancamento_tmodalidade_conta
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_tgrupo_id int2 default args->>'arg_tgrupo_id';
  arg_cliente_id uuid default args->>'arg_cliente_id';
  _const map.constant;
begin
  _const := map.constant();
  return query
    with recursive __lancamento as (
      select
          row_number() over () as lancamento_posicao,
          la.lancamento_id,
          la.lancamento_descricao,
          la.lancamento_credito,
          la.lancamento_debito,
          la.lancamento_data,
          la.lancamento_dataregistro,
          la.lancamento_refid,
          la.lancamento_regclass,
          la.lancamento_referencia,
          la.lancamento_documento,
          la.lancamento_montante,
          la.lancamento_operacao,
          la.lancamento_sequencia,
          la.lancamento_via,
          la.lancamento_valor
        from tweeks.lancamento la
        where la.lancamento_cliente_id = arg_cliente_id
          and la.lancamento_estado = _const.maguita_lancamento_estado_ativo
          and la._tgrupo_id = arg_tgrupo_id
        order by la.lancamento_dataregistro,
          la.lancamento_sequencia
    ), __lancamento_saldo as (
      select
          _la.*,
          _la.lancamento_credito - _la.lancamento_debito as lancamento_valor,
          _la.lancamento_credito - _la.lancamento_debito as lancamento_saldo
        from __lancamento _la
        where _la.lancamento_posicao = 1
        union all
          select
              _la.*,
              _la.lancamento_credito - _la.lancamento_debito as lancamento_valor,
              _ls.lancamento_saldo + ( _la.lancamento_credito - _la.lancamento_debito ) as lancamento_saldo
      from __lancamento_saldo _ls
              inner join __lancamento _la on _ls.lancamento_posicao + 1 = _la.lancamento_posicao
    ) select to_jsonb( _ls )
        from __lancamento_saldo _ls;
end;
$$;


--
-- TOC entry 806 (class 1255 OID 17117)
-- Name: funct_load_mesa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_mesa(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
  declare
    /** Essa função serve para deveolver todas as mesas registradas na base de dados*/
  begin
    return query
      select lib.jsonb_values( m,
          'mesa_id',
          'mesa_numero',
          'mesa_designacao',
          'mesa_lotacao',
          'mesa_estado',
          'mesa_dataregistro',
          'mesa_dataatualizacao'
        )
        from tweeks.mesa m
        order by m.mesa_numero asc;
  end;
$$;


--
-- TOC entry 842 (class 1255 OID 17118)
-- Name: funct_load_mesa_livre(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_mesa_livre(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver as mesas disponiveis
  */
  _const map.constant;
begin
  _const := map.constant();

  return query
    select lib.jsonb_values( m,
        'mesa_id',
        'mesa_numero',
        'mesa_designacao',
        'mesa_lotacao',
        'mesa_estado',
        'mesa_dataregistro'
      )
      from tweeks.mesa m
      where m.mesa_estado = _const.mesa_estado_disponivel
    ;
end;
$$;


--
-- TOC entry 499 (class 1255 OID 17119)
-- Name: funct_load_posto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_posto(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
    declare
    /** Essa função serve para devolver os postos
      filter := {
        arg_colaborador_id UUID
        arg_espaco_auth UUID
        arg_aloca_espaco:UUID
      }
     */
    arg_colaborador_id uuid not null default filter->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';

  __branch uuid not null default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  arg_aloca_espaco uuid default filter->>'arg_aloca_espaco';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;
    begin
  _const := map.constant();

    return query
        with __alocacao as (
      select
        a.aloca_posto_id as posto_id,
        sum( a.aloca_montante ) as posto_montante,
        coalesce( array_agg( e.espaco_id ), array[]::uuid[] )||a.aloca_posto_id as posto_espacos,
        jsonb_agg( to_jsonb( a )||to_jsonb( e ) ) as posto_alocacao
      from tweeks.aloca a
             inner join tweeks.espaco e on a.aloca_espaco_destino = e.espaco_id
      where a.aloca_estado = _const.maguita_aloca_estado_ativo
        and e.espaco_estado = _const.maguita_espaco_estado_ativo
      group by a.aloca_posto_id
    ), __posto_filter as (
      select
        pos.posto_id,
        pos.posto_designacao,
        pos.posto_estado != _const.maguita_posto_estado_encerado as posto_ativo,
        a.posto_montante as posto_montante,
        coalesce( a.posto_alocacao, jsonb_build_array() ) as posto_alocacao,
        pos.posto_estado,
        pos.posto_caixamode,
        pos.posto_authmode,
        pos.posto_chave,
        pos.posto_vermontatefaturado,
        pos.posto_multiplecaixa,
        pos.posto_definirmontanteautomaticamente,
        tpos.tposto_id,
        tpos.tposto_designacao
      from tweeks.posto pos
        inner join tweeks.tposto tpos on pos.posto_tposto_id = tpos.tposto_id
        left join __alocacao a on pos.posto_id = a.posto_id
      where pos._branch_uid = __branch
        and ( arg_aloca_espaco = any ( a.posto_espacos ) or arg_aloca_espaco is null )
      order by
        case
          when pos.posto_estado = _const.maguita_posto_estado_aberto then 1
          when pos.posto_estado = _const.maguita_posto_estado_fechado then 2
          when pos.posto_estado = _const.maguita_posto_estado_encerado then 3
        end,
        pos.posto_designacao
    ), __treat_posto as (
      select ps.*,
        coalesce( ps.posto_alocacao, jsonb_build_array() ) as posto_alocacao
        from __posto_filter ps
    ) select to_jsonb( t )
      from __treat_posto t
    ;
    end;
$$;


--
-- TOC entry 860 (class 1255 OID 17120)
-- Name: funct_load_posto_by_endereco(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_posto_by_endereco(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver um posto a partir do seu endereço IP
    filter := {
      arg_posto_endereco: IP
    }
  */
  arg_posto_endereco character varying not null default filter->>'arg_posto_endereco';
  _const map.constant;
begin
  _const := map.constant();

    return query
      with aux as (
        select
          post.*,
          tp.*,
          esp.*,
          cx.*
        from tweeks.posto post
          inner join tweeks.tposto tp on post.posto_tposto_id = tp.tposto_id
          inner join tweeks.espaco esp on post.posto_espaco_destino = esp.espaco_id
          left join tweeks.caixa cx on post.posto_id = cx.caixa_posto_id
            and cx.caixa_estado = _const.caixa_estado_ativo
        where post.posto_endereco = arg_posto_endereco
        limit 1

      ) select
          jsonb_build_object(
            'posto', lib.jsonb_values( a, 'posto_id', 'posto_montante', 'posto_endereco', 'posto_multipleuser', 'posto_estado', 'posto_designacao' ),
            'caixa', lib.jsonb_values( a, 'caixa_id', 'caixa_montanteinicial', 'caixa_montanteinicialposto' ),
            'espaco', lib.jsonb_values( a, 'espaco_id', 'espaco_nome' ),
            'tposto', lib.jsonb_values( a, 'tposto_id', 'tposto_designacao' )
          )
        from aux a;
end;
$$;


--
-- TOC entry 813 (class 1255 OID 17121)
-- Name: funct_load_posto_closed(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_posto_closed() RETURNS TABLE(posto_id uuid, posto_designacao character varying, espaco_id uuid, espaco_nome character varying)
    LANGUAGE plpgsql
    AS $$
declare
  _const map.constant;
begin
  _const := map.constant();

  return query
    select
        pos.posto_id,
        pos.posto_designacao,
        esp.espaco_id,
        esp.espaco_nome
      from tweeks.posto pos
        inner join tweeks.espaco esp on pos.posto_espaco_destino = esp.espaco_id
      where pos.posto_estado != _const.posto_estado_encerado
        and esp.espaco_estado = _const.espaco_estado_ativo
  ;
end;
$$;


--
-- TOC entry 861 (class 1255 OID 17122)
-- Name: funct_load_posto_simple(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_posto_simple(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(posto_id uuid, posto_designacao character varying)
    LANGUAGE plpgsql
    AS $$
declare

  /** Carregar a lista de posto simples
    filter := {
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;

begin
  _const := map.constant();

  return query
    select
        pt.posto_id,
        pt.posto_designacao
      from tweeks.posto pt
      where pt.posto_estado != _const.posto_estado_encerado
        and pt.posto_espaco_auth = any( arg_espaco_child )
      order by pt.posto_designacao asc
  ;
end;
$$;


--
-- TOC entry 862 (class 1255 OID 17123)
-- Name: funct_load_posto_status(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_posto_status(filters jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver o status atual do posto
    filter := {
      arg_posto_id: ID,
      arg_espaco_auth: ID
    }
  */
  arg_espaco_auth uuid not null default filters->>'arg_espaco_auth';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  arg_posto_id uuid not null default filters->>'arg_posto_id';
  _data record;
  _const map.constant;
begin

  _const := map.constant();

  with posto_cheques as (
    select
        cx.caixa_posto_id,
        count( ct.conta_id ) filter( where ct.conta_tpaga_id = _const.tpaga_cheque ) as conta_cheque
      from tweeks.conta ct
        inner join tweeks.caixa cx on ct.conta_caixa_fechopagamento = cx.caixa_id
      where ct.conta_espaco_auth = any ( arg_espaco_child )
        and ct.conta_estado = _const.conta_estado_pago
        and cx.caixa_posto_id = arg_posto_id
      group by cx.caixa_posto_id

  ), conta_moedas as (
    select
        cx.caixa_posto_id,
        cu.*,
        sum( ct.conta_montantemoeda ) as conta_montantemoeda
      from tweeks.conta ct
        inner join tweeks.caixa cx on ct.conta_caixa_fechopagamento = cx.caixa_id
        inner join geoinfo.currency cu on ct.conta_currency_id = cu.currency_id
      where ct.conta_espaco_auth = any ( arg_espaco_child )
        and ct.conta_estado = _const.conta_estado_pago
        and cx.caixa_posto_id = arg_posto_id
      group by cx.caixa_posto_id,
        cu.currency_id

  ), posto_moeda as (
    select
        ct.caixa_posto_id,
        jsonb_agg (
          lib.jsonb_values( ct, 'currency_id', 'currency_code', 'currency_name' )
        ) as posto_moedas
      from conta_moedas ct
      group by ct.caixa_posto_id
  )
    select * into _data
      from tweeks.posto pos
        inner join tweeks.espaco esp on pos.posto_espaco_destino = esp.espaco_id
        left join posto_moeda pm on pos.posto_id = pm.caixa_posto_id
        left join posto_cheques pc on pos.posto_id = pc.caixa_posto_id
      where pos.posto_id = arg_posto_id
        and pos.posto_espaco_destino = any( arg_espaco_child )
  ;

  return  true ? lib.jsonb_values(
    _data,
    'posto_id',
    'posto_designacao',
    'posto_montante',
    'posto_estado',
    'posto_dataregistro',
    'posto_endereco',
    'espaco_id',
    'espaco_nome',
    'conta_cheque',
    'posto_moedas'
  );

end;
$$;


--
-- TOC entry 863 (class 1255 OID 17124)
-- Name: funct_load_serie(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_serie(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    arg_espaco_auth
    arg_colaborador_id
    arg_autorizacao_id
   */
  _const map.constant;
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_autorizacao_id uuid default args->>'arg_autorizacao_id';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  ___branch_uid uuid;
  _espaco_child uuid[] default rule.espaco_get_childrens_static( arg_espaco_auth );
begin
  _const := map.constant();
  ___branch_uid := tweeks.__branch_uid( null, arg_espaco_auth );
  return query
    with
      __serie as (
        select _vs.*,
            e.espaco_id,
            e.espaco_nome
          from tweeks.serie _vs
            inner join tweeks.espaco e on _vs.serie_espaco_id = e.espaco_id
          where _vs._branch_uid = ___branch_uid
            and coalesce( _vs.serie_autorizacao_uid ) = coalesce( arg_autorizacao_id, _vs.serie_autorizacao_uid )
            and true in (
              _vs.serie_espaco_auth = any( _espaco_child ),
              _vs.serie_espaco_id = any( _espaco_child )
            )
      )
    select to_jsonb( _s )
      from __serie _s;
end;
$$;


--
-- TOC entry 864 (class 1255 OID 17125)
-- Name: funct_load_serie_available(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_serie_available(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
    declare
      /**
        args := {
          arg_espaco_auth:UUID
          arg_colaborado_id:UUID
        }
       */
        arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
        arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
        ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
        _const map.constant;
    begin

      _const := map.constant();

      -- Obter o espaço superior que pode gerar numero de seire
      return query
        with recursive __recursive_espaco as (
          select e.espaco_id as _espaco,
               e.*,
               ts.tserie_id, ts.tserie_desc, ts.tserie_code,
               s.serie_id, s.serie_numero, s.serie_numatorizacao, s.serie_numcertificacao
            from tweeks.espaco e
               full join tweeks.tserie ts on true
               left join tweeks.serie s on e.espaco_id = s.serie_espaco_id
                and s.serie_tserie_id = ts.tserie_id
                and s.serie_estado = _const.maguita_serie_estado_ativo
                and s._branch_uid = ___branch
            where e.espaco_id = arg_espaco_auth
              and e._branch_uid = ___branch
            
            union all
            select _re._espaco, e.*,
                   _re.tserie_id, _re.tserie_desc, _re.tserie_code,
                   s.serie_id, s.serie_numero, s.serie_numatorizacao, s.serie_numcertificacao
            from __recursive_espaco _re
              inner join tweeks.espaco e on _re.espaco_espaco_id = e.espaco_id
                and not _re.espaco_gerarfatura
              inner join tweeks.serie s on e.espaco_id = s.serie_espaco_id
                and _re.tserie_id = s.serie_tserie_id
              and s.serie_tserie_id = _re.tserie_id
              and s.serie_estado = _const.maguita_serie_estado_ativo
              and s._branch_uid = ___branch
            where e._branch_uid = ___branch
        ), __serie_espaco as (
          select
                _re._espaco as espaco_id,
                _re.espaco_id as espaco_serie,
                _re.espaco_nivel,
                _re.espaco_codigo,
                _re.espaco_nome,
                _re.tserie_id,
                _re.tserie_desc,
                _re.tserie_code,
                _re.serie_id,
                _re.serie_numcertificacao,
                _re.serie_numatorizacao,
                _re.serie_numero
            from __recursive_espaco  _re
            where _re.serie_id is not null
      ) select to_jsonb( _se )
          from __serie_espaco _se
      ;
      
    end;
  $$;


--
-- TOC entry 865 (class 1255 OID 17126)
-- Name: funct_load_stoks(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_stoks(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para carragar a quantidade em stock dos diferentes espaços
    args := {
      arg_colaborador_id: UUID
      arg_espaco_auth: UUID
      espaco_destino: UUID,
      artigos:[ UUID, UUID, UUID ]
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';

  arg_espaco_destino uuid default args->>'espaco_destino';
  arg_artigos uuid[] default array( select jsonb_array_elements_text( args->'artigos' )::uuid);
begin
  if jsonb_array_length( args->'artigos' )  = 0 then
    arg_artigos := null;
  end if;

  return query
    with __stoks as (
        select
            art.artigo_id,
            art.artigo_nome,
            e.espaco_id,
            e.espaco_nome,
            s.stock_quantidade,
            n.index
          from tweeks.artigo art
            inner join tweeks.espaco e on e.espaco_id = coalesce( arg_espaco_destino, e.espaco_id )
            inner join tweeks._get_stock(art.artigo_id, arg_espaco_destino ) s on art.artigo_id = s.stock_artigo_id
            left join unnest( arg_artigos ) with ordinality n( id, index ) on art.artigo_id = n.id
          where art.artigo_id = any( coalesce( arg_artigos, array[]::uuid[] ) )

    ) select to_jsonb( s )
      from __stoks s
      order by s.index
      ;
end;
$$;


--
-- TOC entry 534 (class 1255 OID 17127)
-- Name: funct_load_tespaco(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_tespaco(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(tespaco_id smallint, tespaco_designacao character varying)
    LANGUAGE sql
    AS $$
  -- Essa função lista os tipos de espaco
  select * from tweeks.tespaco t order by t.tespaco_designacao asc
$$;


--
-- TOC entry 866 (class 1255 OID 17128)
-- Name: funct_load_tipoimposto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_tipoimposto(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para carregar os tipos de impostos registrados
    filter := {
      arg_espaco_auth: ID
      arg_colaborador_id UID
    }
   */

  arg_espaco_auth uuid not null default filter ->>'arg_espaco_auth';
  arg_colaborador_id uuid default filter->>'arg_colaborador_id';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  _const map.constant;

  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
  _const := map.constant();

  return query
    with associacao as (
      select
        ls.link_referencia,

        jsonb_agg(
          lib.jsonb_values(
            to_jsonb( esp ),
              'espaco_id',
              'espaco_nome'
          )) as link

      from tweeks.link ls
        inner join tweeks.espaco esp on ls.link_espaco_destino = esp.espaco_id
          and esp._branch_uid = ___branch
      where ls.link_tlink_id = _const.maguita_tlink_associacao
        and ls.link_estado = _const.maguita_link_estado_ativo
        and ( ls.link_espaco_auth = any( arg_espaco_child ) or ls.link_espaco_destino = any( arg_espaco_child ) )
        and ls._branch_uid = ___branch
      group by ls.link_referencia
    ), imposto_taxa as (
      select
        tip.*,
        txow.*,
        coalesce( ass.link, jsonb_build_array() ) as link,
        coalesce( tx.taxa_percentagem, (txow::tweeks.taxa).taxa_percentagem ) as taxa_percentagem,
        coalesce( tx.taxa_taxa, (txow::tweeks.taxa).taxa_taxa ) as taxa_taxa,
        arg_espaco_auth = tip.tipoimposto_espaco_auth as tipoimposto_editinfo,
        true as tipoimposto_editespaco,
        true as tipoimposto_edittaxa
      from tweeks.tipoimposto tip
        left join associacao ass on ass.link_referencia @> jsonb_build_object( 'tipoimposto_id', tip.tipoimposto_id )
        left join tweeks.taxa tx on tip.tipoimposto_id = tx.taxa_tipoimposto_id
          and tx.taxa_estado = _const.taxa_estado_ativo
          and tx.taxa_espaco_auth = arg_espaco_auth
          and tx._branch_uid = ___branch
        left join rule.taxa_espaco( tx, _const, arg_espaco_auth ) txow on true
          and tx.taxa_estado = _const.taxa_estado_ativo
          and tx.taxa_espaco_auth = tip.tipoimposto_espaco_auth
      where
          tip._branch_uid = ___branch
        and ( tip.tipoimposto_espaco_auth = any( arg_espaco_child ) or ass.link_referencia is not null )
      order by
        tip.tipoimposto_nome
    ) select
      lib.jsonb_values(
        it,
        'tipoimposto_id',
        'tipoimposto_nome',
        'tipoimposto_codigo',
        'tipoimposto_dataatuzaliacao',
        'tipoimposto_estado',
        'tipoimposto_dataregistro',
        'link',
        'taxa_percentagem',
        'taxa_taxa',
        'tipoimposto_edittaxa',
        'tipoimposto_editespaco',
        'tipoimposto_editinfo'
      )
      from imposto_taxa it
      ;
end;
$$;


--
-- TOC entry 535 (class 1255 OID 17129)
-- Name: funct_load_tpaga(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_tpaga(filter jsonb DEFAULT NULL::jsonb) RETURNS TABLE(tpaga_id smallint, tpaga_designacao character varying)
    LANGUAGE sql
    AS $$
  -- Essa função lista os tipos de pagamento
  select * from tweeks.tpaga t order by t.tpaga_designacao asc
$$;


--
-- TOC entry 867 (class 1255 OID 17130)
-- Name: funct_load_trabalha(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_trabalha(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para carragar os espaços onde um colaborador trabalha
    filter := {
      arg_colaborador_id: ID
    }
  */
  arg_colaborador_id  uuid not null default filter->>'arg_colaborador_id';
  _const map.constant;
begin
  _const := map.constant();

  return query
    with aux as (
      select tr.*, esp.*
        from tweeks.trabalha tr
          inner join tweeks.espaco esp on tr.trabalha_espaco_destino = esp.espaco_id
        where tr.trabalha_colaborador_proprietario = arg_colaborador_id
          and tr.trabalha_estado = _const.trabalha_estado_ativo
          and esp.espaco_estado = _const.espaco_estado_ativo
    ) select lib.jsonb_values(
        a,
        'espaco_id',
        'espaco_nome',
        'espaco_descricao',
        'espaco_estado',
        'espaco_dataregistro',
        'espaco_dataatualizacao',
        'espaco_gerarfatura',
        'espaco_codigo',
        'espaco_configurar',
        'trabalha_id',
        'trabalha_estado'
      )
      from aux a
      order by a.trabalha_posicao,
        a.espaco_nivel,
        a.espaco_id
    ;
end;
$$;


--
-- TOC entry 868 (class 1255 OID 17131)
-- Name: funct_load_transferencia(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_transferencia(filter jsonb) RETURNS TABLE(transferencia_id uuid, transferencia_quantidade double precision, transferencia_data date, transferencia_documento character varying, transferencia_observacao character varying, transferencia_estado smallint, transferencia_dataregistro timestamp with time zone, transferencia_dataatualizacao timestamp with time zone, artigo_id uuid, artigo_nome character varying, artigo_codigo character varying, origem_espaco_id uuid, origem_espaco_nome character varying, destino_espaco_id uuid, destino_espaco_nome character varying)
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para listar as transferencias dos artigos
    filter := {
      arg_artigo_id: ID,
      arg_espaco_origem: ID,
      arg_espaco_destino: ID,
      arg_espaco_auth: ID,
    }
  */

  arg_artigo_id uuid default filter->>'arg_artigo_id';
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  arg_espaco_origem uuid default filter->>'arg_espaco_origem';
  arg_espaco_destino uuid default filter->>'arg_espaco_destino';

  _const map.constant;

begin
  _const := map.constant();

  return query
    select
        trans.transferencia_id,
        trans.transferencia_quantidade,
        trans.transferencia_data,
        trans.transferencia_documento,
        trans.transferencia_observacao,
        trans.transferencia_estado,
        trans.transferencia_dataregistro,
        trans.transferencia_dataatualizacao,

        art.artigo_id,
        art.artigo_nome,
        art.artigo_codigo,

        esporg.espaco_id,
        esporg.espaco_nome,

        espdest.espaco_id,
        espdest.espaco_nome
      from tweeks.transferencia trans
        inner join tweeks.stock origen on trans.transferencia_stock_origem = origen.stock_id
        inner join tweeks.stock dest on trans.transferencia_stock_destino = dest.stock_id
        inner join tweeks.artigo art on origen.stock_artigo_id = art.artigo_id
        inner join tweeks.espaco esporg on origen.stock_espacao_id = esporg.espaco_id
        inner join tweeks.espaco espdest on dest.stock_espacao_id = espdest.espaco_id
      where art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
        and esporg.espaco_id = coalesce( arg_espaco_origem, esporg.espaco_id )
        and espdest.espaco_id = coalesce( arg_espaco_destino, espdest.espaco_id )
        and trans.transferencia_espaco_auth = any( arg_espaco_child )
  ;
end;
$$;


--
-- TOC entry 524 (class 1255 OID 157926)
-- Name: funct_load_unit(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_load_unit(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /**doc
        Carregar os documentos 
        args := {
          _espaco_auth
          _user_id
        }
  doc*/
    _espaco_auth uuid not null default args->>'_espaco_auth';
    _user_id uuid not null default args->>'_user_id';
    _branch uuid default tweeks.__branch_uid( _user_id, _espaco_auth );
begin
  return query
    with _unit as (
      select *
        from tweeks.unit u
        where u._branch_uid = _branch
    ) select to_jsonb( _u ) from _unit _u;
end;
$$;


--
-- TOC entry 869 (class 1255 OID 17132)
-- Name: funct_pos__calc_imposto(uuid, double precision, jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos__calc_imposto(arg_artigo_id uuid, montante double precision, args jsonb DEFAULT NULL::jsonb) RETURNS TABLE(venda_imposto double precision, venda_impostoadicionar double precision, venda_impostoretirar double precision, venda_montantesemimposto double precision, venda_montantecomimposto double precision, impostos jsonb)
    LANGUAGE plpgsql
    AS $$
declare
  _const map.constant;
  _simple tweeks.impostovenda;
  _changes record;
  _data record;
begin
  /*_const := map.constant();
  _simple.impostovenda_espaco_auth := args->>'arg_espaco_auth';
  _simple.impostovenda_colaborador_id := args->>'arg_colaborador_id';
  _simple.impostovenda_venda_id := args->>'arg_venda_id';
  with __imposto as (
    select
        i.imposto_percentagem,
        i.imposto_valor,
        ti.tipoimposto_valor,
        ti.tipoimposto_percentagem,
        i.imposto_taplicar_id as aplicar_id,
        i.imposto_taplicar_id = _const.maguita_taplicar_retirar as retirar,
        i.imposto_taplicar_id = _const.maguita_taplicar_adicionar as adicionar,
        iv.impostovenda_id,
        iv.impostovenda_valor,
        iv.impostovenda_percentagem,
        iv,
        coalesce( i.imposto_percentagem, ti.tipoimposto_percentagem ) as percentagem,
        coalesce( i.imposto_valor, ti.tipoimposto_valor ) as valor
      from tweeks.imposto i
        inner join tweeks.tipoimposto ti on i.imposto_tipoimposto_id = ti.tipoimposto_id
        left join tweeks.impostovenda iv on ti.tipoimposto_id = iv.impostovenda_tipoimposto_id
          and iv.impostovenda_venda_id = _simple.impostovenda_venda_id
          and iv.impostovenda_estado = _const.maguita_venda_estado_aberto
      where i.imposto_artigo_id = arg_artigo_id
        and i.imposto_estado = _const.maguita_imposto_estado_ativo
  ), __calc_value as (
    select
        ip.*,
        case
          when ip.valor and ip.valor > 0 then ip.valor
          when ip.percentagem and ip.percentagem > 0  then ( ip.percentagem / 100 ) * montante
        end as value_apply
      from __imposto ip
  ), __calc_percent as (
    select
        cv.*,
        case
          when cv.percentagem is not null and cv.percentagem > 0  then cv.percentagem
          when cv.value_apply is not null and cv.value_apply > 0 then cv.value_apply / montante * 100
        end as percent_apply
      from __calc_value cv
  ), __sync as (
    select
        c.*, "returning"
      from __calc_percent c
        inner join lib.sets( c.iv, replacer := jsonb_build_object(
          'impostovenda_colaborador_id', _simple.impostovenda_colaborador_id,
          'impostovenda_espaco_auth', _simple.impostovenda_espaco_auth,
          'impostovenda_venda_id', _simple.impostovenda_venda_id,
          'impostovenda_valor', c.impostovenda_valor,
          'impostovenda_percentagem', c.impostovenda_percentagem,
        ) || to_jsonb( _simple ) ) on true
      where true in (
        c.impostovenda_valor != c.value_apply,
        c.impostovenda_percentagem != c.percent_apply
      )
  ) select count( * ) as changes, array_agg( "returning" ) into _changes from __sync;
  */

  funct_pos__calc_imposto.venda_imposto := 0;
  funct_pos__calc_imposto.venda_impostoadicionar := 0;
  funct_pos__calc_imposto.venda_impostoretirar := 0;
  funct_pos__calc_imposto.venda_montantesemimposto := montante;
  funct_pos__calc_imposto.venda_montantecomimposto := montante;
  funct_pos__calc_imposto.impostos := jsonb_build_array();
  return next;
end;
$$;


--
-- TOC entry 870 (class 1255 OID 17133)
-- Name: funct_pos__sync_conta_amount(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos__sync_conta_amount(args jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
declare
  arg_conta_id uuid default args->>'arg_conta_id';
  _const map.constant;
  _conta tweeks.conta;
begin
  _const := map.constant();
--   with __vendas  as(
--     select
--         ve.*,
--         coalesce( sum( vi.venda_montantetotal ), 0.0 ) as _venda_montanteagregado
--       from tweeks.venda ve
--         left join tweeks.venda vi on ve.venda_id = vi.venda_venda_id
--           and vi.venda_conta_id = arg_conta_id
--           and vi.venda_estado in ( _const.maguita_venda_estado_aberto, _const.maguita_venda_estado_fechado )
--
--       where ve.venda_conta_id  = arg_conta_id
--         and ve.venda_estado = _const.maguita_venda_estado_aberto
--         and ve.venda_venda_id is null
--
--       group by ve.venda_id
--   ), __venda_calcs as (
--     select
--         _ve._venda_montanteagregado,
--         _ve.venda_id,
--         _ve.venda_montante + _ve._venda_montanteagregado as _venda_montantetotal,
--         _vi.*
--       from __vendas _ve
--         inner join tweeks.funct_pos__calc_imposto( _ve.venda_artigo_id, _ve.venda_montante + _ve._venda_montanteagregado, args || jsonb_build_object(
--           'arg_venda_id', _ve.venda_id
--         )) _vi on true
--       where _ve.venda_id = _ve.venda_id
--         and _ve.venda_conta_id = arg_conta_id
--         and true in (
--           _ve.venda_montantetotal != _ve.venda_montante + _ve._venda_montanteagregado,
--           _ve.venda_montanteagregado != _ve._venda_montanteagregado,
--           _ve.venda_imposto != _vi.venda_imposto,
--           _ve.venda_impostoadicionar != _vi.venda_impostoadicionar,
--           _ve.venda_impostoretirar != _vi.venda_impostoretirar,
--           _ve.venda_montantesemimposto != _vi.venda_montantesemimposto,
--           _ve.venda_montantecomimposto != _vi.venda_montantecomimposto
--         )
--     ), __sync_calc as (
--     update tweeks.venda _up
--       set
--           venda_montantetotal = _vc._venda_montantetotal,
--           venda_montanteagregado = _vc._venda_montanteagregado,
--           venda_imposto = _vc.venda_imposto,
--           venda_impostoadicionar = _vc.venda_impostoadicionar,
--           venda_impostoretirar = _vc.venda_impostoretirar,
--           venda_montantesemimposto = _vc.venda_montantesemimposto,
--           venda_montantecomimposto = _vc.venda_montantecomimposto
--       from __venda_calcs _vc
--       where _vc.venda_id = _up.venda_id
--       returning _up.*, _vc.impostos
--   ) select count( * ) as changes, jsonb_agg( to_jsonb( s )) as syncs into _data from __sync_calc s;


  with __final_amount as (
    select sum( ve.venda_montantecomimposto ) as conta_montante
      from tweeks.venda ve
      where ve.venda_conta_id = arg_conta_id
        and ve.venda_venda_id is null
        and ve.venda_estado in (
          _const.maguita_venda_estado_aberto,
          _const.maguita_venda_estado_fechado
        )
  ), __sync_conta as (
    update tweeks.conta _c set
        conta_montante = _ve.conta_montante
      from __final_amount _ve
      where _c.conta_id = arg_conta_id
        and _c.conta_montante != _ve.conta_montante
      returning *
  ) select * into _conta from __sync_conta;

  return jsonb_build_object(
    'conta', _conta
  );
end;
$$;


--
-- TOC entry 871 (class 1255 OID 17134)
-- Name: funct_pos_change_caixa_close(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_change_caixa_close(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para fechar uma posto
    args := {
      arg_caixa_id: ID,
      arg_espaco_auth: ID,
      arg_colaborador_id: ID,
      arg_caixa_montantefecho: MONTANTE,
      arg_caixa_quantidadecheque: QUANT,
      arg_caixa_observacao: OBS,
    }
  */

  arg_caixa_id uuid not null default args->>'arg_caixa_id';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_caixa_montantefecho  double precision not null default args->>'arg_caixa_montantefecho';
  arg_caixa_quantidadecheque int2 not null default args->>'arg_caixa_quantidadecheque';
  arg_caixa_observacao varchar default args->>'arg_caixa_observacao';

  _posto record;
  _caixa tweeks.caixa;
  _const map.constant;
  _movimentos record;

begin

  _const := map.constant();
  _caixa := tweeks._get_caixa( arg_caixa_id );

  if _caixa.caixa_estado != _const.maguita_caixa_estado_ativo then
    return lib.res_false( 'Essa caixa não se encontra mais aberta!' );
  end if;

  select * into _posto
    from tweeks.posto cx
      inner join tweeks.caixa ab on cx.posto_id = ab.caixa_posto_id
    where ab.caixa_id = arg_caixa_id
      and ab.caixa_estado = _const.maguita_caixa_estado_ativo
      and cx.posto_estado = _const.maguita_posto_estado_aberto
  ;

  -- Obter a quantidade de cheque de venda
  select count( * ) into arg_caixa_quantidadecheque
    from tweeks.deposito de
    where de.deposito_caixa_id = _caixa.caixa_id
      and de.deposito_tpaga_id = _const.maguita_tpaga_cheque
      and de._tgrupo_id = _const.maguita_tgrupo_cnormal
  ;

  with __deposito as  (
    select
        sum( de.deposito_montantefinal ) as deposito_montantefinal,
        count( de.deposito_id ) as depositos,
        count( de.deposito_id ) filter ( where de.deposito_tpaga_id = _const.maguita_tpaga_cheque ) as depositos_cheques
      from tweeks.deposito de
      where de.deposito_posto_id = _caixa.caixa_posto_id
        and de._tgrupo_id = _const.maguita_tgrupo_cnormal
        and de.deposito_estado = _const.maguita_deposito_estado_ativo
  ), __transacao as (
    select
        sum( tr.transacao_montante ) as transacao_montante,
        sum( tr.transacao_montante ) filter ( where tr.transacao_montante >= 0 ) as transacao_montantecredito,
        sum( abs( tr.transacao_montante ) ) filter ( where tr.transacao_montante < 0 )  as transacao_montantedebito
      from tweeks.transacao tr
      where tr.transacao_posto_id = _caixa.caixa_posto_id
        and tr.transacao_estado = _const.maguita_transacao_estado_ativo
  ), __coa as (
    select
        _de.depositos,
        _de.depositos_cheques,
        coalesce( _de.deposito_montantefinal, 0.0 ) as deposito_montantefinal,
        coalesce( _tr.transacao_montante, 0.0 ) as transacao_montante,
        coalesce( _tr.transacao_montantecredito, 0.0 ) as transacao_montantecredito,
        coalesce( _tr.transacao_montantedebito, 0.0 ) as transacao_montantedebito
      from __deposito _de, __transacao _tr
  ) select
      _c.*,
      _c.transacao_montante + _c.deposito_montantefinal as posto_montantefinal
      into _movimentos
    from __coa _c
    ;

  _caixa.caixa_estado                   := _const.maguita_caixa_estado_fechado;
  _caixa.caixa_dataatualizacao          := current_timestamp;
  _caixa.caixa_colaborador_atualizacao  := arg_colaborador_id;
  _caixa.caixa_quantidadecheque         := arg_caixa_quantidadecheque;
  _caixa.caixa_quantidadechequeposto    := arg_caixa_quantidadecheque;
  _caixa.caixa_montantefecho            := arg_caixa_montantefecho;
  _caixa.caixa_montantefechoposto       := _movimentos.posto_montantefinal;
  _caixa.caixa_observacao               := arg_caixa_observacao;

  select ( "returning" ).* into _caixa
    from lib.sets_up( _caixa );

  return lib.res_true(jsonb_build_object(
    'caixa', _caixa
  ));
end;
$$;


--
-- TOC entry 872 (class 1255 OID 17135)
-- Name: funct_pos_change_conta_anular(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_change_conta_anular(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para atualar as contas
    args := {
      arg_conta_id: ID,
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,
      arg_conta_observacao: OBSERVACAO
    }
   */

  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_conta_id uuid default args->>'arg_conta_id';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_conta_observacao varchar default args->>'arg_conta_observacao';

  _conta tweeks.conta;
  _const map.constant;
begin
  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );

  arg_conta_observacao := lib.str_nospace( arg_conta_observacao );

  if _conta.conta_estado  = _const.maguita_conta_estado_anulado then
    return lib.res_false( 'Essa conta já está anulado' );
  end if;

  if _conta.conta_estado != _const.maguita_conta_estado_aberto and arg_conta_observacao is null then
    return lib.res_false( 'É necessario informar uma obseravção para anular as contas fechadas e pagas' );
  end if;

  _conta.conta_estado                   := _const.maguita_conta_estado_anulado;
  _conta.conta_colaborador_atualizacao  := arg_colaborador_id;
  _conta.conta_dataatualizacao          := current_timestamp;
  _conta.conta_observacao               := arg_conta_observacao;

  select ( "returning" ).* into _conta
    from lib.sets_up( _conta )
  ;

  return lib.res_true( jsonb_build_object( 'conta', _conta ) );
end;
$$;


--
-- TOC entry 536 (class 1255 OID 17136)
-- Name: funct_pos_change_conta_fechar(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_change_conta_fechar(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa função fecha uma nova conta
      arg = {
        arg_espaco_auth: ID,
        arg_colaborador_id: ID,
        arg_tserie_id: ID,      
        deposito:{
          deposito_cliente_id
          deposito_caixa_id
          deposito_tpaga_id
          deposito_currency_id
          deposito_posto_id
          deposito_montantemoeda
          deposito_montantetroco
          deposito_data
          deposito_docref: DOCUMENTO-REF?
          deposito_observacao: OBSERVACAO?
        }

        conta_id: ID,
        conta_extension: {} | { reserva_id: UID }
        conta_mesa: { numero:NUM, descricao:TEXT, lotacao:NUM },

        conta_posto_id: ID,
        conta_desconto

        conta_titular: NOME-CLIENTE
        conta_titularnif: VARCHAR,
        conta_data: DATA,
        conta_cliente_id,

        //Relativos a GUIA
        guia_documentoperacao: CODIGO,
        guia_dataopeacao: DATA,
        guia_observacao: DESCRICAO
        guia_metadata: { ... any extras data }

        custos:[{
          custoguia_montante: MONTANTE,
          custoguia_descricao: DESCRICAO PARA O CUSTO
          custoguia_tcusto_id: 1 - DESPESA | 2 - RECEITA
        }]
      }
     */

    arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
    arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
    arg_tserie_id int2 default args->>'arg_tserie_id';

    arg_conta_id uuid default args->>'conta_id';
    arg_caixa_id uuid default args->>'de_caixa_id';
    _deposito_montantetroco double precision;


    _conta tweeks.conta;
    _const map.constant;
    _caixa tweeks.caixa;
    _res lib.res;
    _cambio record;
    _montante_amortizacao double precision;
    _deposito tweeks.deposito;
    _rec record;
    _guia tweeks.guia;
    _conta_estado record;
  begin
    _const := map.constant();
    _caixa := tweeks._get_caixa( arg_caixa_id );
    _conta := tweeks._get_conta( arg_conta_id );
    _conta := jsonb_populate_record( _conta, args );
    _conta.conta_data := coalesce( _conta.conta_data, current_date );
    _deposito := jsonb_populate_record( _deposito, args->'deposito' );

    
    if _conta.conta_id is null then 
        raise exception '%', 'Identificador da conta a ser fechada não foi informado!';
    end if;
    
    if _conta.conta_estado = _const.maguita_conta_estado_fechado then
        return lib.res_false( 'Essa conta já se encontra fechada!' );
    end if;
    
    if arg_tserie_id not in (
        _const.maguita_tserie_fatura,
        _const.maguita_tserie_faturarecibo,
        _const.maguita_tserie_guiasaida,
        _const.maguita_tserie_notacredito
    ) then
      return lib.res_false( 'Não pode fechar a conta o com tipo de serie selecionada!' );
    end if;
    
    if _conta.conta_posto_fecho is null then
      return lib.res_false( 'Necessario indicar o posto de fecho!' );
    end if;
    
    -- Na fatura recibo não pode haver conta corrente
    if arg_tserie_id = _const.maguita_tserie_faturarecibo and _deposito.deposito_montantemoeda is null then 
      return lib.res_false( 'O pagamento para as faturas/recibo é obrigatorio!' );
    end if;
    
    -- Os cliente finais só podem receber fatura/recibo ou nota de credito
    if true in (
        _conta.conta_cliente_id is null,
        _conta.conta_cliente_id = lib.to_uuid( 1 ) -- cliente final
    ) and arg_tserie_id not in (
      _const.maguita_tserie_faturarecibo
    ) then
      return lib.res_false( 'Só pode lançar nos cliente finais as futuras/recibos!');
    end if;
    
    
    -- Quando hover necessidade de efetuar o deposito então, deve-se obter a taxa de cambio para o dia
    if arg_tserie_id = _const.maguita_tserie_faturarecibo 
      or _deposito.deposito_montantemoeda is not null
    then
      if _deposito.deposito_tpaga_id = _const.maguita_tpaga_contacorrente then
        return lib.res_false( 'Tipo de pagamento invalido' );
      end if;
      
      -- Obter o cambio para a moeda selecionada
      select * into _cambio from tweeks.__load_cambio_day(
        arg_espaco_auth,
        _deposito.deposito_currency_id,
        _conta.conta_data,
        _const
      );
      
      if _cambio.cambio_id is null then
        return lib.res_false( 'Câmbio não foi encontrado!' );
      end if;
    end if;
    
    -- O valor do deposito nas conta de fatura/recibo deve ser o suficiente para cobrir o montante da fatura
    if arg_tserie_id = _const.maguita_tserie_faturarecibo then 
      if round( ( _cambio.cambio_taxa * _deposito.deposito_montantemoeda)::numeric, _const.money_round )  < round( _conta.conta_montante::numeric, _const.money_round ) then
        return lib.res_false( 'Montante para pagamento insuficiente' );
      end if;

      -- Se for para amortizar a conta a caixa tem que estar aberta
      if _caixa.caixa_estado != _const.maguita_caixa_estado_ativo then
        return lib.res_false( 'Pagamento rejeitado!' );
      end if;
    end if;

    -- Definir em aqual conta a fatura deve ser enviado
    _conta._tgrupo_id := case
      when arg_tserie_id = _const.maguita_tserie_faturarecibo then _const.maguita_tgrupo_cnormal
      when arg_tserie_id = _const.maguita_tserie_fatura then _const.maguita_tgrupo_ccorrente
      when arg_tserie_id = _const.maguita_tserie_guiasaida then _const.maguita_tgrupo_ccorrente
      when arg_tserie_id = _const.maguita_tserie_notacredito then _const.maguita_tgrupo_ccorrente
    end;
    
    -- Gerar a serie para a conta dependento do tipo do documento (fatura, faturarecibo, notacredito, guiasaida)
    _rec := tweeks.__sets_generate_documento( arg_espaco_auth, arg_tserie_id );
    _conta.conta_numerofatura := _rec.document;
    _conta.conta_serie := to_json( _rec );
    _conta.conta_serie_id = _rec.serie_id;

    _conta.conta_estado := _const.maguita_conta_estado_fechado;
    _conta.conta_imprensa := 1;
    _conta.conta_colaborador_fecho := arg_colaborador_id;
    _conta.conta_datafecho := current_timestamp;
    _conta.conta_cliente_id := coalesce( _conta.conta_cliente_id, lib.to_uuid( 1 ) );

    -- Gerar a Guia de saida
    _guia := jsonb_populate_record( _guia, args );
    _guia.guia_tguia_id := _const.maguita_tguia_saida;
    _guia.guia_espaco_saida := arg_espaco_auth;
    _guia.guia_toperacao_id := _const.maguita_toperacao_venda;
    _guia.guia_refclass := cluster.__format( 'tweeks.conta'::regclass );
    _guia.guia_refuid := _conta.conta_id;
    _guia.guia_refs := jsonb_build_object(
      'cliente', jsonb_build_object( 'cliente_id', _conta.conta_cliente_id ),
      'saida', jsonb_build_object( 'espaco_id', _conta.conta_espaco_auth )
    );

    _guia := tweeks.funct_sets_guia( jsonb_build_object(
      'guia', _guia,
      'custoguia', args->'custos',
      'arg_colaborador_id', arg_colaborador_id,
      'arg_espaco_auth', arg_espaco_auth
    ));

    -- Vicular a informaçao de guia na conta extension com a tag guia_id
    _conta.conta_extension := coalesce( _conta.conta_extension, jsonb_build_object() )
      || jsonb_build_object( 'guia_id', _guia.guia_uid );

    select ( "returning" ).* into _conta
      from lib.sets_up( _conta )
    ;

    
    -- Caso necessairio lançar o deposito viculado a conta
    if coalesce( _deposito.deposito_montantemoeda, 0.0 ) > 0 then
      
      _montante_amortizacao  := _deposito.deposito_montantemoeda * _cambio.cambio_taxa;
      if _montante_amortizacao > _conta.conta_montante and _conta._tgrupo_id != _const.maguita_tgrupo_ccorrente then
        _deposito_montantetroco := _montante_amortizacao - _conta.conta_montante;
      end if;

      _deposito_montantetroco := coalesce( _deposito_montantetroco, _deposito.deposito_montantetroco, 0.0 );

      _res := tweeks.funct_pos_reg_deposito(( args->'deposito' ) || jsonb_build_object(
          'arg_espaco_auth', arg_espaco_auth,
          'arg_colaborador_id', arg_colaborador_id,
          'arg_balance_accounts', false,
          'deposito_cliente_id', _conta.conta_cliente_id,
          'deposito_montantetroco', _deposito_montantetroco,
          '_tgrupo_id', _conta._tgrupo_id,
          'deposito_referencia', jsonb_build_object( 'conta_id', _conta.conta_id ), -- Vincula o deposito a conta
          'deposito_documento', _conta.conta_numerofatura,
          'deposito_serie', _conta.conta_serie,
          'deposito_serie_id', _conta.conta_serie_id,
          '_raise', true -- Criar exception para comportamentos indesejados
        ));
      
      if not _res.result then
        perform lib.result_exception(
            _res.message,
            detail := _res.data::text,
            hint := _res.error::text
          );
      else
        _deposito := jsonb_populate_record( null::tweeks.deposito, _res.data->'deposito' );
      end if;
    end if;

    return lib.res_true(
        message := '@tweeks.conta.invoice-closed-success',
        data := jsonb_build_object(
            'guia', _guia,
            'conta', tweeks._get_conta( _conta.conta_id ),
            'fatura', _conta.conta_numerofatura,
            'recibo', _deposito.deposito_documento
          )
      );
  end;
$$;


--
-- TOC entry 873 (class 1255 OID 17138)
-- Name: funct_pos_change_conta_proforma(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_change_conta_proforma(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: UUID,
      arg_espaco_auth: UUID,

      conta_id UUID,
      conta_cliente_id: UID,
      conta_proformavencimento: DATE
      conta_proformaextras
    }
   */
  arg_conta_id uuid default args->>'conta_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';

  _conta tweeks.conta;
  _const map.constant;
begin
  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );

  if _conta.conta_estado != _const.maguita_conta_estado_aberto then
    return lib.res_false( 'Não pode colocar uma conta em modo proforma para as cotas já fechada!' );
  end if;

  _conta.conta_proforma := true;

  select ( "returning" ).* into _conta
    from lib.sets( _conta, args  );

  return lib.res_true( jsonb_build_object(
    'conta', _conta
  ));
end;
$$;


--
-- TOC entry 506 (class 1255 OID 17139)
-- Name: funct_pos_generate_key(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_generate_key(args jsonb) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare
    /**
      arg_colaborador_id uuid
      arg_espaco_auth uuid
     */
    arg_colaborador_id uuid default args->>'arg_colaborador_id';
    arg_espaco_auth uuid default args->>'arg_espaco_auth';
    ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
    _key character varying;
  begin
    while _key is null loop
        _key :=  cluster.next( 'artigo.key/seq', ___branch::text, lpad := 9, lpad_char := '0' );
        _key := format( 'CTK-%s-%s', _key, lib.dset_random_text(32 ) );
        if exists(
            select *
              from tweeks.conta ct
              where ct.conta_chave = _key
                and ct._branch_uid = ___branch
        ) then
          _key := null;
        end if;
      end loop;
    return _key;
  end;
  $$;


--
-- TOC entry 409 (class 1255 OID 17140)
-- Name: funct_pos_load_artigo(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_artigo(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: UID,
      arg_espaco_auth: UID
      arg_classe_id: UID
      arg_artigo_nome:TXT
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_classe_id uuid default args->>'arg_classe_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  _const map.constant;
  _branch uuid not null default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
  _const := map.constant();
  return query
    
    with __stock as (
      select *
        from tweeks.__fluxo_stock(
          _classe_uid := arg_classe_id,
          _branch := _branch
        )
    ), __artigo as (
    select
        art.artigo_id,
        art.artigo_classe_id,
        art.artigo_nome,
        art.artigo_foto,
        art.artigo_stocknegativo,
        art.artigo_estado,
        s.stock_quantidade,
        l.link_metadata,
        u.unit_id,
        u.unit_code,
        u.unit_name,
        count( di.dispoe_id ) as artigos_extras
      from tweeks.artigo art
        inner join tweeks.link l on art.artigo_id =(  l.link_referencia->>'artigo_id' )::uuid
          and l.link_estado = _const.maguita_link_estado_ativo
          and l.link_tlink_id = _const.maguita_tlink_preco
          and l.link_espaco_destino = arg_espaco_auth
        left join __stock s on art.artigo_id = s.artigo_id and s.espaco_id = arg_espaco_auth
        left join tweeks.dispoe di on art.artigo_id = di.dispoe_artigo_id
          and di.dispoe_estado = _const.dispoe_estado_ativo
        left join tweeks.unit u on art.artigo_unit_id = u.unit_id

    where art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
      group by art.artigo_id,
        s.stock_quantidade,
        l.link_metadata,
        art.artigo_stocknegativo,
        art.artigo_nome,
        art.artigo_foto,
        u.unit_id
      order by case
          when s.stock_quantidade > 0 or art.artigo_stocknegativo then 1
          else 2
        end,
        art.artigo_nome
  ) select to_jsonb( a ) from __artigo a;
end;
$$;


--
-- TOC entry 539 (class 1255 OID 17141)
-- Name: funct_pos_load_artigo_composto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_artigo_composto(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  _const map.constant;
begin
  _const := map.constant();
  return query
    with recursive __artigo as (
      select
          art.artigo_id,
          art.artigo_nome,
          art.artigo_artigo_id as artigo_base,
          ab.artigo_nome as artigo_parent,
          art.artigo_compostoquantidade,
          1 as composicao_nivel
        from tweeks.artigo art
          inner join tweeks.artigo ab on art.artigo_artigo_id = ab.artigo_id
          inner join tweeks.link l on l.link_referencia @> lib.sets_ref( art )
            and l.link_espaco_destino = arg_espaco_auth
            and l.link_estado = _const.maguita_link_estado_ativo
          inner join tweeks.link l2 on l2.link_referencia @> lib.sets_ref( ab )
            and l2.link_espaco_destino = arg_espaco_auth
            and l2.link_estado = _const.maguita_link_estado_ativo
        where art.artigo_artigo_id is not null
      union all
        select
            _a.artigo_id,
            _a.artigo_nome,
            ip.artigo_id,
            ip.artigo_nome,
            _a.artigo_compostoquantidade * lk.artigo_compostoquantidade ,
            _a.composicao_nivel +1
          from __artigo _a
            inner join tweeks.artigo lk on _a.artigo_base = lk.artigo_id
            inner join tweeks.artigo ip on lk.artigo_artigo_id = ip.artigo_id
    ), __composto_group as (
      select
          _a.artigo_id,
          _a.artigo_nome,
          array_agg( to_jsonb( _a  ) ) as artigo_bases
        from __artigo _a
        group by
          _a.artigo_id,
          _a.artigo_nome
    ) select to_jsonb( _tg )
      from __composto_group _tg
    ;
end;
$$;


--
-- TOC entry 538 (class 1255 OID 17142)
-- Name: funct_pos_load_artigo_extras(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_artigo_extras(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_artigo_id: UID,
      arg_espaco_auth: UID,
      arg_colaborador_id: UID
    }
   */
  arg_artigo_id uuid not null default args->>'arg_artigo_id';
--   arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
--   arg_colaborador_id uuid not null default args->>'arg_colaborador_id';

    _const map.constant;

begin
  _const := map.constant();
  return query with __item as(
      select
          art.artigo_id,
          art.artigo_nome,
          l.link_metadata
        from tweeks.artigo art
          inner join tweeks.link l on to_jsonb( art ) @> l.link_referencia
            and l.link_estado = _const.maguita_link_estado_ativo
            and l.link_tlink_id = _const.maguita_tlink_preco
        where art.artigo_classe_id = _const.classe_itemextra
          and art.artigo_estado = _const.artigo_estado_ativo
    ), __extras as(
      select it.*
        from tweeks.dispoe d
          inner join __item it on d.dispoe_artigo_item = it.artigo_id
        where d.dispoe_artigo_id = arg_artigo_id
    ) select to_jsonb( e ) from __extras e;
end;
$$;


--
-- TOC entry 756 (class 1255 OID 17143)
-- Name: funct_pos_load_artigo_search(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_artigo_search(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      search_text:TXT,
      arg_espaco_auth
    }
   */
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  _search_text character varying default args->>'search_text';
  _search_text_like character varying;
  _const map.constant;
  ___branch uuid;
begin
  ___branch := tweeks.__branch_uid( null, arg_espaco_auth );
  
  _search_text := lib.str_nospace( lower( public.unaccent( _search_text ) ) );
  _search_text_like := format( '%s%s%s', '%', _search_text, '%' );

  _const := map.constant();
  return query with
    __ean as( select e.ean_artigo_id, array_agg( e.ean_code ) as ean_code from tweeks.ean e where e.ean_estado = _const.maguita_ean_estado_ativo group by e.ean_artigo_id ),
    __artigo as (
    select
        c.classe_id,
        c.classe_nome,
        u.unit_id,
        u.unit_code,
        u.unit_name,
        art.artigo_id,
        art.artigo_classe_id,
        art.artigo_nome,
        art.artigo_codigo,
        art.artigo_stocknegativo,
        art.artigo_estado,
        s.stock_quantidade,
        l.link_metadata,
        e.ean_code,
        count( di.dispoe_id ) as artigos_extras
      from tweeks.artigo art
        inner join tweeks.classe c on art.artigo_classe_id = c.classe_id
        inner join tweeks.link l on art.artigo_id =  ( l.link_referencia->>'artigo_id' )::uuid
          and l.link_estado = _const.maguita_link_estado_ativo
          and l.link_tlink_id = _const.maguita_tlink_preco
          and l.link_espaco_destino = arg_espaco_auth
        inner join tweeks.stock s on s.artigo_id = art.artigo_id
          and s.espaco_id = arg_espaco_auth
        left join tweeks.dispoe di on art.artigo_id = di.dispoe_artigo_id
          and di.dispoe_estado = _const.dispoe_estado_ativo
        left join __ean e on e.ean_artigo_id = art.artigo_id
        left join tweeks.unit u on art.artigo_unit_id = u.unit_id

    where art._branch_uid = ___branch
      group by art.artigo_id,
        c.classe_id,
        u.unit_id,
        s.stock_quantidade,
        l.link_metadata,
        art.artigo_stocknegativo,
        art.artigo_nome,
        e.ean_code
      order by case
          when s.stock_quantidade > 0 or art.artigo_stocknegativo then 1
          else 2
        end,
        art.artigo_nome
  ) select to_jsonb( a )
      from __artigo a
      where
        lower( public.unaccent( a.artigo_nome ) )  like _search_text_like
          or lower( public.unaccent( a.artigo_codigo ) )  like _search_text_like
          or  _search_text = any ( a.ean_code )
  ;
end
$$;


--
-- TOC entry 500 (class 1255 OID 17144)
-- Name: funct_pos_load_caixa_auth(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_caixa_auth(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: UUID,
      arg_espaco_auth: UUID,
      arg_posto_id:UUID
      auth: BOOLEAN
    }
   */
  arg_posto_id uuid not null default args->>'arg_posto_id';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
  _posto tweeks.posto;

begin
  _const := map.constant();

  select * into _posto from tweeks.posto;

  return query with
  __deposito as (
    select
        dep.deposito_caixa_id,
        dep.deposito_currency_id,
        cur.currency_id,
        cur.currency_name,
        cur.currency_code,
        sum( dep.deposito_montantefinal ) deposito_montantefinal,
        sum( dep.deposito_montante ) deposito_montante,
        sum( dep.deposito_montantemoeda ) deposito_montantemoeda,
        sum( dep.deposito_montantetroco ) deposito_montantetroco
      from tweeks.deposito dep
        inner join geoinfo.currency cur on dep.deposito_currency_id = cur.currency_id
      where dep.deposito_estado = _const.maguita_deposito_estado_ativo
        and dep._branch_uid = branch
      group by dep.deposito_caixa_id,
        dep.deposito_currency_id,
        cur.currency_id,
        cur.currency_name,
        cur.currency_code
  ),__deposito_caixa as (
      select
          dep.deposito_caixa_id,
          sum( dep.deposito_montantefinal ) as deposito_montantefinal,
          jsonb_object_agg(
              dep.currency_code, jsonb_build_object(
                  'deposito_montantemoeda', deposito_montantemoeda,
                  'deposito_montantefinal', deposito_montantefinal,
                  'deposito_montante', deposito_montante,
                  'deposito_montantetroco', deposito_montantetroco
              )
          ) as deposito_montantemoeda,
          sum( dep.deposito_montante ) as deposito_montante,
          sum( dep.deposito_montantefinal ) as deposito_montantefinal,
          sum( dep.deposito_montantetroco ) as deposito_montantetroco
        from __deposito dep
        group by
          dep.deposito_caixa_id
  ),__posto as (
    select
        c.caixa_id,
        c.caixa_estado,
        c.caixa_montanteinicial,
        c.caixa_montanteinicialposto,
        p.posto_caixamode,
        dep.*
      from tweeks.posto p
        inner join tweeks.caixa c on p.posto_id = c.caixa_posto_id
          and c.caixa_estado = _const.maguita_caixa_estado_ativo
          and case
            when p.posto_caixamode = _const.maguita_posto_caixamodo_pessoal then c.caixa_colaborador_id = arg_colaborador_id
            when p.posto_caixamode = _const.maguita_posto_caixamodo_espaco  then c.caixa_espaco_auth    = arg_espaco_auth
            when p.posto_caixamode = _const.maguita_posto_caixamodo_posto   then c.caixa_posto_id       = arg_posto_id
            else false
          end
        left join __deposito_caixa dep on c.caixa_id = dep.deposito_caixa_id
      where p.posto_id = arg_posto_id
        and p._branch_uid = branch
        and c._branch_uid = branch
  ) select to_jsonb( p )
    from __posto p;
end;
$$;


--
-- TOC entry 755 (class 1255 OID 17145)
-- Name: funct_pos_load_class(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_class(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_espaco_auth: UID,
      arg_colaborador_id: UID
    }
   */
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  _branch uuid not null default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
begin
  _const := map.constant();

  return query with
    __classe as (
      select
          c.classe_id,
          c.classe_classe_id,
          c.classe_nome,
          c.classe_codigo,
          c.classe_foto,
          count( distinct lart.link_id ) filter ( where lart.link_id is not null ) as classe_artigos
        from tweeks.classe c
          inner join tweeks.link lcla on c.classe_id = (lcla.link_referencia->>'classe_id')::uuid
            and lcla.link_estado = _const.maguita_link_estado_ativo
          inner join tweeks.artigo art on c.classe_id = art.artigo_classe_id
            and art.artigo_estado = _const.artigo_estado_ativo
          inner join tweeks.link lart on art.artigo_id = ( lart.link_referencia->>'artigo_id' )::uuid
            and lart.link_estado = _const.maguita_link_estado_ativo
--             and lart.link_espaco_destino = artigo_espaco_auth
        where lcla.link_espaco_destino = arg_espaco_auth
          and lcla.link_tlink_id = _const.maguita_tlink_classe
          and c._branch_uid = _branch
          and art._branch_uid = _branch
          and lcla._branch_uid = c._branch_uid
          and lart._branch_uid = c._branch_uid
        group by c.classe_id
    ) select  to_jsonb( c )
      from __classe c;
end;
$$;


--
-- TOC entry 543 (class 1255 OID 17146)
-- Name: funct_pos_load_cliente(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_cliente(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_posto_id uuid default args->>'arg_posto_id';
  _const map.constant;
  __branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
  _const := map.constant();

  --language=PostgreSQL
  return query
    with __cliente as (
      select
          c.cliente_id,
          c.cliente_titular,
          c.cliente_nif
        from tweeks.cliente c
        where ( c._branch_uid = __branch_uid and c.cliente_estado = _const.maguita_cliente_estado_ativo )

        order by
          case
            when c.cliente_id = lib.to_uuid( 1 ) then 1
            else 2
          end,
          c.cliente_titular
    ) select to_jsonb( _c ) from __cliente _c;
end
$$;


--
-- TOC entry 874 (class 1255 OID 17147)
-- Name: funct_pos_load_colaborador(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_colaborador(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver os colaboradores que tenha pelo menos um menu especificado
    filter := {
      posto_id: UUID,
      menus:[ CODE, CODE, CODE ]
    }
  **/
  arg_posto_id uuid default args->>'posto_id';
  arg_menus character varying[] default array(select e.text from jsonb_array_elements_text( args->'menus' ) e ( text ));
  _const map.constant;
begin
  _const := map.constant();
  return query with
    __espacos as ( select e.espaco_id, e.espaco_nome, e.espaco_estado from tweeks.espaco e ),
    __colaborador as (
        select
            co.colaborador_id,
            co.colaborador_nome,
            co.colaborador_email,
            co.colaborador_accesso,
            co.colaborador_foto,
            co.colaborador_estado
          from auth.colaborador co
            inner join auth.acesso ac on co.colaborador_id = ac.acesso_colaborador_propetario
            inner join auth.menu me on ac.acesso_menu_id = me.menu_id
          where me.menu_codigo = any( arg_menus )
            and ac.acesso_estado = _const.acesso_estado_ativo
            and co.colaborador_estado = _const.colaborador_estado_ativo
            and co.colaborador_accesso in (
              _const.colaborador_accesso_ativo,
              _const.colaborador_accesso_pendente
            )
    ),
    __posto as (
      select
          po.posto_id,
          array_agg( al.aloca_espaco_destino ) as posto_alocacao
        from tweeks.posto po
          inner join tweeks.aloca al on po.posto_id = al.aloca_posto_id
            and al.aloca_estado = _const.maguita_aloca_estado_ativo
        where po.posto_id = arg_posto_id
        group by po.posto_id
    ), __local as (
      select
          tr.trabalha_colaborador_proprietario,
          array_agg( to_jsonb( e ) ) as colaborador_workspace
        from tweeks.trabalha tr
          inner join __posto p on tr.trabalha_espaco_destino = any( p.posto_alocacao )
          inner join __espacos e on tr.trabalha_espaco_destino = e.espaco_id
        where tr.trabalha_estado = _const.maguita_trabalha_estado_ativo
        group by tr.trabalha_colaborador_proprietario
    ), __trabalhador as (
      select *
        from __local lo
          inner join __colaborador co on lo.trabalha_colaborador_proprietario = co.colaborador_id
    ) select to_jsonb( tr ) from __trabalhador tr;
end;
$$;


--
-- TOC entry 875 (class 1255 OID 17148)
-- Name: funct_pos_load_conta_aberto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_conta_aberto(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: UID*,
      arg_espaco_auth: UID?,
      arg_posto_id: UID*
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_posto_id uuid not null default args->>'arg_posto_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  _const map.constant;
begin
  _const := map.constant();
  return query
    with __conta as(
      select
          ct.conta_id,
          ct.conta_numero,
          ct.conta_montante,
          ct.conta_mesa,
          ct.conta_chave,
          c.colaborador_id,
          c.colaborador_nome,
          c.colaborador_apelido,
          e.espaco_id,
          e.espaco_nome,
          count( ve.venda_id ) as conta_vendas
        from tweeks.conta ct
          inner join auth.colaborador c on ct.conta_colaborador_id = c.colaborador_id
          inner join tweeks.espaco e on ct.conta_espaco_auth = e.espaco_id
          left join tweeks.venda ve on ct.conta_id = ve.venda_conta_id
            and ve.venda_estado = _const.maguita_venda_estado_aberto
            and ve.venda_venda_id is null
        where ct.conta_posto_id = arg_posto_id
          and ct.conta_estado = _const.maguita_conta_estado_aberto
          and ct.conta_espaco_auth = coalesce( arg_espaco_auth, ct.conta_espaco_auth )
          and not ct.conta_proforma
        group by
          c.colaborador_id,
          ct.conta_id,
          e.espaco_id
    ) select to_jsonb( ct ) from __conta ct;
end;
$$;


--
-- TOC entry 542 (class 1255 OID 17149)
-- Name: funct_pos_load_conta_data(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_conta_data(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa função devolve uma mesa juntamente com as conta associada que ainda esta aberta
      filter := {
        with_client:boolean
        arg_posto_id: ID
        arg_espaco_auth: ID
        arg_colaborador_id: ID
        arg_conta_id: ID
      }
     */

--     arg_posto_id uuid  not null default filter->>'arg_posto_id';
    arg_espaco_auth uuid  not null default filter->>'arg_espaco_auth';
    arg_conta_id uuid not null default filter->>'arg_conta_id';
    arg_colaborador_id uuid default filter->>'arg_colaborador_id';
    _with_client boolean default filter->>'with_client';

    _const map.constant;
    _client jsonb;
    _conta tweeks.conta;
    ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin

  _const := map.constant();

  if _with_client then
    select to_jsonb( c ) into _client
      from cliente c
        inner join tweeks.conta ct on c.cliente_id = ct.conta_cliente_id
      where ct.conta_id = arg_conta_id
    ;
  end if;

  if _client is null then
    _client := jsonb_build_object();
  end if;

  select * into _conta
    from tweeks.conta ct
    where ct.conta_id = arg_conta_id
  ;

  return query with
    __venda as (
      select
        v.venda_id,
        v.venda_conta_id,
        v.venda_venda_id,
        v.venda_quantidade,
        v.venda_custoquantidade,
        v.venda_custounitario,
        v.venda_montante,
        v.venda_montantesemimposto,
        v.venda_montantecomimposto,
        v.venda_montantetotal,
        v.venda_imposto,
        v.venda_impostoadicionar,
        v.venda_impostoretirar,
        v.venda_montanteagregado,
        v.venda_isencao,
        v.venda_estado,
        v.venda_estadopreparacao,
        v.venda_metadata,
        v.venda_descricao,
        v.venda_validade,
        v.venda_editado,
        v.venda_taxas,
        v.venda_lote,
        a.artigo_id,
        a.artigo_nome,
        a.artigo_codigo,
        a.artigo_compostoquantidade,
        a.artigo_artigo_id,
        u.unit_id,
        u.unit_code,
        u.unit_name,
        tx.taxa_percentagem,
        tx.taxa_taxa,
        tip.tipoimposto_id,
        tip.tipoimposto_codigo,
        tip.tipoimposto_nome
      from tweeks.venda v
        inner join tweeks.artigo a on v.venda_artigo_id = a.artigo_id
        left join tweeks.taxa tx on tx.taxa_id = any ( v.venda_taxas )
        left join tweeks.tipoimposto tip on tx.taxa_tipoimposto_id = tip.tipoimposto_id
        left join tweeks.unit u on a.artigo_unit_id = u.unit_id
      where v._branch_uid = ___branch
        and v.venda_estado in (
           _const.maguita_venda_estado_aberto,
           _const.maguita_venda_estado_fechado
        )
    ), __venda_group as (
      select
          v.venda_id as _venda_id,
          v.venda_conta_id as _venda_conta_id,
          coalesce( array_agg( vi order by vi.artigo_nome ) filter ( where vi.venda_id is not null ),
            array[]::record[]
          ) as venda_itens
        from  tweeks.venda v
          inner join tweeks.artigo a on v.venda_artigo_id = a.artigo_id
          left join __venda vi on v.venda_id = vi.venda_venda_id
        where v.venda_estado in ( _const.maguita_venda_estado_aberto,  _const.maguita_venda_estado_fechado )
          and v.venda_venda_id is null
          and v.venda_conta_id = arg_conta_id
          and v.venda_estado in (
            _const.maguita_venda_estado_aberto,
            _const.maguita_venda_estado_fechado
          )
        group by v.venda_id, a.artigo_id
    ), __conta as (
      select
          c.conta_id,
          c.conta_numero,
          c.conta_numerofatura,
          c.conta_montante,
          c.conta_mesa,
          c.conta_estado,
          c.conta_serie,
          c.conta_observacao,
          c.conta_extension,
          c.conta_props,
          c.conta_serie_id,
          c._tgrupo_id,
          c.conta_data,
          c.conta_dataregistro,
          c.conta_conta_docorigin,
          de.deposito_montante,
          de.deposito_montantetroco,
          de.deposito_montantefinal,
          de.deposito_montantemoeda,
          de.deposito_tpaga_id,
          corigen.conta_numerofatura as conta_documentoorigem,
          array_agg( to_jsonb( v )||to_jsonb( vg ) order by v.artigo_nome ) as conta_vendas
        from tweeks.conta c
          left join tweeks.conta corigen on c.conta_conta_docorigin = corigen.conta_id
          left join __venda_group vg on c.conta_id = vg._venda_conta_id
          left join __venda v on vg._venda_id = v.venda_id
          left join tweeks.deposito de on c.conta_id = (de.deposito_referencia->>'conta_id')::uuid
        where c.conta_id = arg_conta_id
          and c._branch_uid = ___branch
        group by c.conta_id, 
          de.deposito_id,
         corigen.conta_id
     ) select to_jsonb( c ) || _client from __conta c
  ;

  if _conta._tgrupo_id = _const.maguita_tgrupo_cnormal then
    return query
      with __deposito as (
        select
            de.deposito_id,
            de.deposito_montante,
            de.deposito_montantemoeda,
            de.deposito_montantetroco,
            de.deposito_montantefinal,
            de.deposito_taxacambio,
            cu.currency_code,
            cu.currency_id,
            cu.currency_name,
            tp.tpaga_id,
            tp.tpaga_designacao,
            p.posto_designacao,
            p.posto_id,
            cx.caixa_id
          from tweeks.deposito de
            inner join geoinfo.currency cu on de.deposito_currency_id = cu.currency_id
            inner join tweeks.tpaga tp on de.deposito_tpaga_id = tp.tpaga_id
            left join tweeks.caixa cx on de.deposito_caixa_id = cx.caixa_id
            left join tweeks.posto p on cx.caixa_posto_id = p.posto_id
          where (de.deposito_referencia->>'conta_id')::uuid = _conta.conta_id
            and de._branch_uid = ___branch
      ) select to_jsonb( _de )
          from __deposito _de
    ;
  end if;
end
$$;


--
-- TOC entry 921 (class 1255 OID 17150)
-- Name: funct_pos_load_conta_dia(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_conta_dia(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /** Essa função serve para devolver as compras do dia em uma data especifica
      filter := {
        arg_conta_data: DATE
        arg_posto_id: DATE
      }
     */
    _const map.constant;
    arg_conta_data date default filter->>'arg_conta_data';
    arg_posto_id uuid not null default filter->>'arg_posto_id';
begin

    _const := map.constant();
    arg_conta_data := coalesce( arg_conta_data, current_date );

    if arg_conta_data < current_date - make_interval( days := 7 ) then return; end if;

    return query
        with __conta as (
            select
                ct.conta_id,
                ct.conta_data,
                ct.conta_dataregistro,
                ct.conta_titular,
                ct.conta_titularnif,
                ct.conta_montante,
                ct.conta_numerofatura,
                ct.conta_numero,
                p.posto_designacao,
                p.posto_matricula,
                de.deposito_montante,
                de.deposito_montantemoeda,
                de.deposito_montantetroco,
                de.deposito_montantefinal,
                de.deposito_taxacambio,
                cu.currency_id,
                cu.currency_code,
                cu.currency_name,
                co.colaborador_id,
                co.colaborador_nome
            from tweeks.conta ct
                inner join tweeks.posto p on ct.conta_posto_fecho = p.posto_id
                inner join tweeks.deposito de on ( de.deposito_referencia->>'conta_id' )::uuid = ct.conta_id
                inner join geoinfo.currency cu on de.deposito_currency_id = cu.currency_id
                inner join auth.colaborador co on ct.conta_colaborador_fecho = co.colaborador_id
            where ct.conta_posto_fecho = arg_posto_id
              and ct.conta_estado = _const.maguita_conta_estado_fechado
              and ct._tgrupo_id = _const.maguita_tgrupo_cnormal
              and ct.conta_datafecho::date = arg_conta_data
        ) select to_jsonb( _ct )
        from __conta _ct
    ;
end
$$;


--
-- TOC entry 876 (class 1255 OID 17151)
-- Name: funct_pos_load_conta_proforma(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_conta_proforma(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver as compras do dia em uma data especifica
    filter := {
      arg_posto_id: DATE
      arg_espaco_id uuid
      arg_colaborador_id
    }
   */
  _const map.constant;
--   arg_posto_id uuid not null default filter->>'arg_posto_id';
  arg_colaborador_id uuid not null default filter->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';

  _posto tweeks.posto;
  __branch_uid uuid not null default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
--   _posto := tweeks._get_posto( arg_posto_id );
  _const := map.constant();

  return query
    with __conta as (
      select
          ct.conta_id,
          ct.conta_data,
          ct.conta_dataregistro,
          ct.conta_titular,
          ct.conta_titularnif,
          ct.conta_montante,
          ct.conta_numerofatura,
          ct.conta_numero,
          ct.conta_proformavencimento,
          ct.conta_proformaextras,
          cli.cliente_id,
          cli.cliente_titular,
          cli.cliente_nif,
          cli.cliente_documento,
          td.tdocumento_id,
          td.tdocumento_nome,
          co.colaborador_id,
          co.colaborador_nome,
          co.colaborador_apelido
        from tweeks.conta ct
          left join auth.colaborador co on coalesce( ct.conta_colaborador_fecho, ct.conta_colaborador_atualizacao, ct.conta_colaborador_id ) = co.colaborador_id
          left join tweeks.cliente cli on ct.conta_cliente_id = cli.cliente_id
          left join tweeks.tdocuemto td on cli.cliente_tdocument_id = td.tdocumento_id
        where ct._branch_uid = __branch_uid
          and ct.conta_estado = _const.maguita_conta_estado_aberto
          and ct.conta_proforma
    ) select to_jsonb( _ct )
        from __conta _ct
    ;
end
$$;


--
-- TOC entry 877 (class 1255 OID 17152)
-- Name: funct_pos_load_posto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_load_posto(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para devolver o cambio do dia de uma moeda
    filter := {
      arg_chave_temporaria: CHAVE;
    }
  */

  _const map.constant;
  _chave_doc jsonb;
  _posto tweeks.posto;
  _posto_disponivel boolean;
  _local cluster.cluster;
begin
  _const := map.constant();
  _local := cluster._get_cluster_local();
  select * into _chave_doc
    from tweeks.funct_load_chave( args );

  _posto := jsonb_populate_record( _posto, _chave_doc );
  _posto_disponivel := _chave_doc->>'posto_disponivel';

  if _chave_doc is not null and not _posto_disponivel or _posto.posto_id is null then
    return next _chave_doc;
    return;
  elseif _chave_doc is null then
    return;
  end if;

  return next _chave_doc;

  return query
    with __cambio as (
      select
        c.currency_id,
        c.currency_name,
        c.currency_code,
        cb.cambio_id,
        cb.cambio_taxa,
        cb.cambio_data,
        cb.cambio_estado,
        cb.cambio_dataatualizacao,
        cb.cambio_espaco_auth,
        rank( ) over ( partition by cb.cambio_currency_id, cb.cambio_espaco_auth order by cb.cambio_dataregistro desc ) as cambio_rank
      from tweeks.cambio cb
        inner join geoinfo.currency c on cb.cambio_currency_id = c.currency_id
      where cb.cambio_data <= current_timestamp::date
        and cb.cambio_estado != _const.maguita_cambio_estado_anulado
      order by cb.cambio_dataregistro desc
    ), __space_cambio as (
      select
          e.espaco_id,
          e.espaco_nome,
          e.espaco_nivel,
          e.espaco_vender,
          _local.cluster_identifier,
          _local.cluster_name,
          _local.cluster_domain,
          _local.cluster_port,
          array_agg( c ) as espaco_cambios
        from __cambio c
          inner join tweeks.espaco e on c.cambio_espaco_auth = e.espaco_id
            and e.espaco_estado = _const.maguita_espaco_estado_ativo
          inner join tweeks.aloca al on e.espaco_id = al.aloca_espaco_destino
            and al.aloca_posto_id = _posto.posto_id
            and al.aloca_estado = _const.maguita_aloca_estado_ativo
        where c.cambio_rank = 1
          and e.espaco_vender = _local.cluster_identifier
        group by al.aloca_id,
          e.espaco_id
    ) select to_jsonb( sc )
      from __space_cambio sc
  ;
end;
$$;


--
-- TOC entry 879 (class 1255 OID 17153)
-- Name: funct_pos_reg_caixa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_caixa(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para registar uma nova caixa
    args := {
      arg_espaco_auth: ID
      arg_posto_id: ID
      arg_colaborador_id: ID
      caixa_montanteinicial: MONTANTE
    }
  */

  arg_posto_id uuid not null default args->>'arg_posto_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_caixa_montanteinicial double precision not null default args->>'caixa_montanteinicial';

  _data record;
  _posto tweeks.posto;
  _caixa tweeks.caixa;
  _const map.constant;
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin

  select * into _posto
    from tweeks.posto
    where posto_id = arg_posto_id
  ;

  _const := map.constant();

  with __aloca as (
    select
      a.aloca_posto_id,
      sum( a.aloca_montante ) as aloca_montante
    from tweeks.aloca a
    where a.aloca_estado = _const.maguita_aloca_estado_ativo
      and a.aloca_posto_id = arg_posto_id
      and case
            when _posto.posto_caixamode = _const.maguita_posto_caixamodo_posto then true
            when _posto.posto_caixamode = _const.maguita_posto_caixamodo_espaco then a.aloca_espaco_destino = arg_espaco_auth
            when _posto.posto_caixamode = _const.maguita_posto_caixamodo_pessoal then a.aloca_espaco_destino = arg_espaco_auth
            else false
      end
    group by a.aloca_posto_id
  ), __caixa as (
    select
      cx.caixa_posto_id,
      mode() within group ( order by e.espaco_nome desc ) as espaco_nome,
      count( cx.caixa_id ) as posto_caixas
    from tweeks.caixa cx
           inner join tweeks.espaco e on cx.caixa_espaco_auth = e.espaco_id
    where cx.caixa_posto_id = arg_posto_id
      and cx.caixa_estado = _const.maguita_caixa_estado_ativo
    group by cx.caixa_posto_id
  ) select
      *,
      coalesce( aloca_montante, 0.0 ) as _aloca_montante
  into _data
  from tweeks.posto p
         left join __aloca al on p.posto_id = al.aloca_posto_id
         left join __caixa cx on p.posto_id = cx.caixa_posto_id
  where p.posto_id = arg_posto_id
  ;

  if  not _posto.posto_multiplecaixa and _data.posto_caixas > 0 then
    return lib.res_false(
        format( 'Esse posto só pode trabalhar com uma caixa a cada momento, por favor fechar primeiramente a caixa abertas atualmente!' )
      );
  end if;


  _caixa.caixa_colaborador_id := arg_colaborador_id;
  _caixa.caixa_posto_id := arg_posto_id;
  _caixa.caixa_montanteinicialposto := _data._aloca_montante;
  _caixa.caixa_montanteinicial := arg_caixa_montanteinicial;
  _caixa.caixa_espaco_auth := arg_espaco_auth;
  _caixa.caixa_code := tweeks.__generate_caixa_code( ___branch, arg_colaborador_id, arg_espaco_auth );

  select ( "returning" ).* into _caixa
    from lib.sets_in(_caixa  )
  ;

  _posto.posto_estado := _const.maguita_posto_estado_aberto;
  select ( "returning" ).* into _posto from lib.sets_up( _posto );

  return lib.res_true( jsonb_build_object(
      'caixa', _caixa,
      'posto', _posto
    ));
end
$$;


--
-- TOC entry 880 (class 1255 OID 17154)
-- Name: funct_pos_reg_cliente(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_cliente(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
    /**
      args := {
        arg_colaborador_id:UUID*
        arg_espaco_auth:UUID*

        cliente_id:UUID?
        cliente_estado:ESTADO?

        cliente_titular:NAME*
        cliente_tdocument_id:TDOC?
        cliente_nif: NIF?
        cliente_mail: MAIL?
        cliente_documento: DOC-NUMBER?

      }
     */
    arg_colaborador_id uuid default args->>'arg_colaborador_id';
    arg_espaco_auth uuid default args->>'arg_espaco_auth';
    _client tweeks.cliente;
    _data record;
    ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
    _exists record;
  begin
    _client := jsonb_populate_record( _client, args );

    with __uniques as (
      select
          f.cliente_code as "CODIGO",
          f.cliente_mail as "EMAIL",
          f.cliente_nif as "NIF",
          format( '%s-%s', f.cliente_tdocument_id, f.cliente_documento ) as "DOCUMENTO",
          jsonb_build_object(
            'CODIGO', _client.cliente_code,
            'NIF', _client.cliente_nif,
            'EMAIL', _client.cliente_mail,
            'DOCUMENTO', case
                when true in ( f.cliente_documento is null, f.cliente_tdocument_id is null ) then null
                else format( '%s-%s', _client.cliente_tdocument_id, _client.cliente_documento )
             end
          ) as _math
        from tweeks.cliente f
        where f._branch_uid = ___branch
          and ( _client.cliente_id is null or _client.cliente_id != f.cliente_id )
    ) select lib.duplicates( jsonb_agg( _uf ), _uf._math , true ) as dulicates  into _exists
        from __uniques _uf
        group by _uf._math
  ;

  if _exists.dulicates is not null then
    return lib.res_false( format( '(%s) estão duplicados!', _exists.dulicates ) );
  end if;

    select * into _client
      from tweeks.cliente c
      where c.cliente_id = _client.cliente_id
    ;

    if _client.cliente_id is null then
      _client.cliente_colaborador_id := arg_colaborador_id;
      _client.cliente_espaco_auth := arg_espaco_auth;
    else
      _client.cliente_colaborador_atualizacao := arg_colaborador_id;
      _client.cliente_dataatualizacao := current_timestamp;
    end if;

    select * into _data
      from lib.sets( _client, replacer := args );
      _client := _data."returning"
    ;

    return lib.res_true(jsonb_build_object(
      'cliente', _client,
      'opr', _data.operation
    ));
  end
$$;


--
-- TOC entry 883 (class 1255 OID 17155)
-- Name: funct_pos_reg_conta(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_conta(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função registra um nova conta
    arg = {

      -- obrigatorios
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,

      conta_posto_id: ID,

      -- opcional
      conta_mesa: { numero:NUM, descricao:TEXT, lotacao:NUM }
      conta_id: ID?
      conta_extension: {} | { reserva_id: UID }
      conta_chave: CHAVE

      conta_currency_id: ID,
      conta_tpaga_id: ID,

      conta_cliente_id:UID
      conta_titular: CLIENTE-NOME
      conta_titularnif: CLIENTE-NIF
      conta_data: DATA,

      -- requerido
      arg_vendas: [
        {
          venda_id?: UID,
          venda_artigo_id: UID,
          venda_quantidade: QUANT,
          venda_custounitario: COST
          venda_custoquantidade: COST

          + venda_editado
          + venda_isencao
          + venda_montante
          + venda_montanteagregado
          + venda_montantetotal
          + venda_imposto
          + venda_montantesemimposto
          + venda_montantecomimposto
          + venda_impostoadicionar
          + venda_impostoretirar

          + venda_descricao
          + venda_lote
          + venda_validade
          + venda_metadata

          arg_itens: [
              venda_id: UID
              venda_artigo_id: UID,
              venda_quantidade: QUANT,
              venda_custounitario: COST
              venda_custoquantidade: COST
              venda_descricao: DESCRICAO
              venda_lote: LOTE
              venda_validade: VALIDADE
              venda_metadata: {... any extras data}
            + venda_montantetotal
          ]
        }
      ]
    }
   */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_conta_id uuid default args->>'conta_id';
  arg_conta_chave character varying not null default args->>'conta_chave';
  arg_vendas jsonb not null default args->>'arg_vendas';

  _conta tweeks.conta;
  _const map.constant;
  _unsets jsonb[];
  _vendas uuid[] default array( select ( e.doc->>'venda_id' )::uuid from jsonb_array_elements( args->'arg_vendas' ) e ( doc ) where e.doc->>'venda_id' is not null);
  _sync jsonb;
  _reg_venda record;
  _change tweeks.conta;
  _branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );

  __conta_of_chave tweeks.conta;
begin
  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );
  
  if _conta.conta_id is null and exists(
    select *
      from tweeks.conta ct 
      where ct.conta_chave = arg_conta_chave
        and ct._branch_uid = _branch
  ) then
    return lib.res_false( 'Já existe uma conta com a mesma chave (atualize a pagina e tente novamente)!' );
  end if;
  
  -- Carregar a conta com a chave correspondente
  if _conta.conta_id is null and _conta.conta_chave is null then
    select * into __conta_of_chave
      from tweeks.conta ct
      where ct.conta_chave = arg_conta_chave
    ;
  end if;

  -- Tentitiva de criar uma segunda conta com a mensa chave (normalmente tentativa de duplo click na criação de uma nova conta)
  if __conta_of_chave.conta_id is not null and _conta.conta_id is null then
    args := args || lib.sets_ref( __conta_of_chave );
    _conta := jsonb_populate_record( __conta_of_chave, args );
  end if;


  if _conta.conta_id is null then
    _conta.conta_colaborador_id := arg_colaborador_id;
    _conta.conta_espaco_auth := arg_espaco_auth;
    _conta.conta_numero := cluster.next( 'conta.conta_numero/seq',
      sub := _branch::text,
      lpad_char := '0',
      lpad := 5
    );
  else
    _conta.conta_colaborador_atualizacao := arg_colaborador_id;
    _conta.conta_dataatualizacao := current_timestamp;
  
  end if;
  
  _change := json_populate_record( _conta, args::json );

  select ( "returning" ).* into _change
    from lib.sets( _conta, replacer := args )  sets
    where _conta::text != _change::text
  ;
  
  if _change.conta_id is not null then _conta := _change; end if;

  -- Canselar as vendas que não fazem mais parte de conta
  with recursive __venda as (
      select
          ve.venda_id,
          ve.venda_estado
        from tweeks.venda ve
        where ve.venda_conta_id = _conta.conta_id
          and ve.venda_venda_id is null
          and ve.venda_id != all( _vendas )
          and ve.venda_estado in (
            _const.maguita_venda_estado_aberto,
            _const.maguita_venda_estado_fechado
          )
      union all
        select
            ve.venda_id,
            ve.venda_estado
          from __venda vs
            inner join tweeks.venda ve on vs.venda_id = ve.venda_venda_id
          where vs.venda_estado in (
            _const.maguita_venda_estado_aberto,
            _const.maguita_venda_estado_fechado
          )
  ), __disable as(
    update tweeks.venda up
      set venda_estado = _const.maguita_venda_estado_canselado
      from __venda _v
      where up.venda_id = _v.venda_id
      returning *
  ) select array_agg( to_jsonb( d ) ) into _unsets
      from __disable d;


  _reg_venda :=  tweeks.funct_pos_reg_venda(
    jsonb_build_object(
      'arg_vendas', arg_vendas,
      'arg_message_error', true,
      'arg_espaco_auth', arg_espaco_auth,
      'arg_colaborador_id', arg_colaborador_id,
      'arg_conta_id', _conta.conta_id
    )
  );

  _sync := tweeks.funct_pos__sync_conta_amount(
    jsonb_build_object(
      'arg_conta_id', _conta.conta_id,
      'arg_colaborador_id', arg_colaborador_id,
      'arg_espaco_auth', arg_espaco_auth
    )
  );

  return lib.res_true( tweeks.funct_pos_load_conta_data( jsonb_build_object(
    'arg_posto_id', args->'conta_posto_id',
    'arg_espaco_auth', arg_espaco_auth,
    'arg_colaborador_id', arg_colaborador_id,
    'arg_conta_id', _conta.conta_id
  )) || jsonb_build_object(
    'sync', _sync,
    'sets', _reg_venda.data->'vendas',
    'unsets', coalesce( _unsets, array[]::jsonb[])
  ));


exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.res_exception( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 410 (class 1255 OID 17157)
-- Name: funct_pos_reg_deposito(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_deposito(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para registar uma nova amortizacao
    args := {
      arg_espaco_auth: ID,
      arg_colaborador_id: ID,

      deposito_montantetroco: TROCO*
      deposito_caixa_id: UID,
      deposito_tpaga_id: ID,
      deposito_currency_id: UID,
      deposito_posto_id: UID,
      deposito_cliente_id: UID,
      deposito_referencia: {conta_id}
      deposito_montantemoeda: MONTANTE,
      deposito_data: DATA,
      deposito_observacao: OBS?
      deposito_documento: DOC?
      deposito_docref: NUMERO DOC?,
      _tgrupo_id
    }
  */
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';

  _deposito tweeks.deposito;
  _posto tweeks.posto;
  _const map.constant;
  _cambio record;
  _caixa tweeks.caixa;
  _raise bool;
  _rec record;

begin

  _raise := args->>'_raise';

  _const := map.constant();
  _deposito := jsonb_populate_record( _deposito, args );


  if _deposito.deposito_posto_id is not null then
    _posto := tweeks._get_posto( _deposito.deposito_posto_id );
  end if;

  if _deposito.deposito_caixa_id is not null then
    _caixa := tweeks._get_caixa( _deposito.deposito_caixa_id );
    if _caixa.caixa_estado != _const.maguita_caixa_estado_ativo and _raise then
      raise exception 'Não pode registar um deposito numa caixa fechado!';
    elseif _caixa.caixa_estado != _const.maguita_caixa_estado_ativo then
      return lib.res_false( 'Não pode registar um deposito numa caixa fechado!' );
    end if;
  end if;
  _deposito.deposito_data := coalesce( _deposito.deposito_data, current_date );
  _deposito.deposito_colaborador_id := arg_colaborador_id;
  _deposito.deposito_espaco_auth := arg_espaco_auth;

  select * into _cambio from tweeks.__load_cambio_day(
    arg_espaco_auth,
    _deposito.deposito_currency_id,
    current_date,
    _const
  );

  if _cambio.cambio_id is null and _raise then
    raise exception '@tweeks.conta.cambio-not-found';
  elseif _cambio.cambio_id is null then
    return lib.res_false( 'Câmbio não foi encontrado!' );
  end if;

  _deposito.deposito_montante := _deposito.deposito_montantemoeda * _cambio.cambio_taxa;

  if coalesce( _deposito.deposito_montantetroco, 0.0 ) >= _deposito.deposito_montante and _raise then
    raise exception 'O montante de troco tem que ser inferior a montante cambiado!';
  elsif coalesce( _deposito.deposito_montantetroco, 0.0 ) >= _deposito.deposito_montante then
    return lib.res_false( 'O montante de troco tem que ser inferior a montante cambiado!' );
  end if;

  if _deposito.deposito_referencia is null or _deposito.deposito_documento is null then
    _rec := tweeks.__sets_generate_documento( arg_espaco_auth, 3 /* Recibo*/ );
    _deposito.deposito_documento := _rec.document;
    _deposito.deposito_serie := to_json( _rec );
    _deposito.deposito_serie_id := _rec.serie_id;
  end if;

--     if _deposito.deposito_referencia is null then
--         _deposito.deposito_documento := tweeks.__sets_generate_documento( arg_espaco_auth, 2 /*Fatura Recibo */  );
--     else
--         _deposito.deposito_documento := tweeks.__sets_generate_documento( arg_espaco_auth, 3 /* Recibo*/ );
--     end if;
--   --_deposito.deposito_documento := tweeks.__generate_deposito_serie( arg_espaco_auth );

  select ( "returning" ).* into _deposito
    from lib.sets( _deposito )
  ;

  return lib.res_true(
    jsonb_build_object(
      'deposito', _deposito
    )
  );
end;
$$;


--
-- TOC entry 882 (class 1255 OID 17158)
-- Name: funct_pos_reg_retalho(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_retalho(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /*
   args := {
      arg_colaborador_id,
      arg_espaco_auth,

      retalho_artigo_composto
      retalho_artigo_base
      retalho_composicao
      retalho_quantidade
   }
   */
    arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
    arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
    
    _artigo_base tweeks.artigo;
    _artigo_composto tweeks.artigo;
    _retalho tweeks.retalho;
    ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
    __stock record;
begin
    _retalho := jsonb_populate_record( _retalho, args );
    _artigo_base := tweeks._get_artigo( _retalho.retalho_artigo_base );
    _artigo_composto := tweeks._get_artigo( _retalho.retalho_artigo_composto );
    
    if _artigo_composto.artigo_artigo_id is null or _artigo_composto.artigo_compostoquantidade is null then
      return lib.res_false( 'O artigo selecionano para retalhar não é um artigo composto!' );
    end if;
    
    __stock := tweeks._get_stock( _retalho.retalho_artigo_composto, arg_espaco_auth );
    
    if __stock.stock_quantidade < _retalho.retalho_quantidade
        and not _artigo_composto.artigo_stocknegativo
    then
      return lib.res_false( 'Quantidade do artigo composto no armazem atual não é suficiente para retalhar!');
    end if;
    
    _retalho.retalho_codigo = tweeks.__generate_retalho_code( ___branch );
    _retalho.retalho_colaborador_id := arg_colaborador_id;
    _retalho.retalho_espaco_auth := arg_espaco_auth;
    
    select ( "returning" ).* into _retalho
      from lib.sets( _retalho );
    
    return lib.res_true(jsonb_build_object(
        'retalho', _retalho
    ));
end;
$$;


--
-- TOC entry 884 (class 1255 OID 17159)
-- Name: funct_pos_reg_venda(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_venda(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para associar mais vendas a conta
    args := {
      arg_colaborador_id: ID,
      arg_conta_id: ID,
      arg_espaco_auth: ID,
      arg_message_error: TRUE|FALSE,
      arg_venda_id: ID
      arg_vendas: [{
          venda_id?: UID,
          venda_artigo_id: UID,
          venda_quantidade: QUANT,
          venda_custounitario: COST
          venda_custoquantidade: COST

          + venda_editado BOOLEAN
          + venda_isencao BOOLEAN
          + venda_montante
          + venda_montanteagregado
          + venda_montantetotal
          + venda_imposto
          + venda_montantesemimposto
          + venda_montantecomimposto
          + venda_impostoadicionar
          + venda_impostoretirar

          + venda_descricao
          + venda_lote
          + venda_validade
          + venda_metadata
          + venda_taxas

          arg_itens: [
              venda_id: UID
              venda_artigo_id: UID,
              venda_quantidade: QUANT,
              venda_custounitario: COST
              venda_custoquantidade: COST
              venda_descricao: DESCRICAO
              venda_lote: LOTE
              venda_validade: VALIDADE
              venda_metadata: {... any extras data}
            + venda_montantetotal
          ]
        }
      ]
    }
   */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_conta_id uuid not null default args->>'arg_conta_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_vendas jsonb not null default args->>'arg_vendas';
  arg_message_error boolean default args->>'arg_message_error';

  _const map.constant;
  _conta tweeks.conta;
  _data record;
  _stocks record;
  _simple tweeks.venda;
  __vendas tweeks.venda[];

begin
  _const := map.constant();
  _conta := tweeks._get_conta( arg_conta_id );

  -- Quando a conta não esta aberta
  if _conta.conta_estado != _const.maguita_conta_estado_aberto and arg_message_error then
    raise exception '@conta.estado.not-closed';
  elseif  _conta.conta_estado != _const.maguita_conta_estado_aberto then
    return false ? '@conta.estado.not-closed';
  end if;

  _stocks := tweeks.__check_stock_on_venda( arg_espaco_auth, arg_vendas );

  if not _stocks.stocks  and arg_message_error then
    raise exception '%', _stocks.message;

  elsif not _stocks.stocks  then
    return lib.res_false(
      _stocks.message
    );
  end if;

  with recursive __element as (
    select
        row_number() over () as row,
           ( jsonb_populate_record( null::tweeks.venda, e.doc )).*,
--         ( e.doc->>'venda_artigo_id' )::uuid  as venda_artigo_id,
--         ( e.doc->>'venda_quantidade' )::double precision as venda_quantidade,
--         ( e.doc->>'venda_custounitario' )::double precision as venda_custounitario,
--         ( e.doc->>'venda_custoquantidade' )::double precision as venda_custoquantidade,
        ( e.doc )::jsonb  as document,
        coalesce( e.doc->'arg_itens', '[ ]'::jsonb )::jsonb as itens,
        false as _is_extension
      from jsonb_array_elements( arg_vendas ) e ( doc )
    union all
      select
          row,
          ( jsonb_populate_record( null::tweeks.venda, e.doc || jsonb_build_object(
              'venda_montanteagregado', 0,
              'venda_imposto', 0,
              'venda_montantesemimposto', 0,
              'venda_montantecomimposto', 0,
              'venda_imposto', 0,
              'venda_editado', false,
              'venda_taxas', jsonb_build_array()
            
            ))).*,
--           ( e.doc->>'venda_artigo_id' )::uuid  as venda_artigo_id,
--           ( e.doc->>'venda_quantidade' )::double precision as venda_quantidade,
--           ( e.doc->>'venda_custounitario' )::double precision as venda_custounitario,
--           ( e.doc->>'venda_custoquantidade' )::double precision as venda_custoquantidade,
          ( e.doc )::jsonb  as document,
          coalesce( e.doc->'arg_itens', '[]'::jsonb )::jsonb as itens,
          true as _is_extension
        from __element ep
          inner join jsonb_array_elements( ep.itens ) e( doc ) on jsonb_array_length( ep.itens ) > 0
        where jsonb_array_length( ep.itens ) > 0
          and ep.itens is not null
  ), __calcs as (
    select
        e.*,
        e.document as docreplacer,
        ve.venda_id as _venda_id,
        coalesce( ve.venda_dataregistro, now() ) as venda_dataregistro,
        coalesce( ve.venda_colaborador_id, arg_colaborador_id ) as venda_colaborador_id,
        coalesce( ve.venda_conta_id, arg_conta_id ) as venda_conta_id,
        coalesce( ve.venda_espaco_auth, arg_espaco_auth ) as venda_espaco_auth,
        case
          when art.artigo_preparacao then _const.maguita_venda_estadopreparacao_pendente
          else _const.maguita_venda_estadopreparacao_preparado
        end as venda_estadopreparacao
      from __element e
        inner join tweeks.artigo art on e.venda_artigo_id = art.artigo_id
        left join tweeks.venda ve on ve.venda_id = ( e.document->>'venda_id' )::uuid
      where ve.venda_id is null
        or( ve.venda_id is not null and true in (
          ve.venda_quantidade != e.venda_quantidade,
          ve.venda_custounitario != e.venda_custounitario,
          ve.venda_custoquantidade != e.venda_custoquantidade,
          ve.venda_montante != e.venda_montante,
          ve.venda_montanteagregado != e.venda_montanteagregado,
          ve.venda_montantetotal != e.venda_montantetotal,
          ve.venda_imposto != e.venda_imposto,
          ve.venda_montantesemimposto != e.venda_montantesemimposto,
          ve.venda_montantecomimposto != e.venda_montantecomimposto,
          ve.venda_impostoadicionar != e.venda_impostoadicionar,
          ve.venda_impostoretirar != e.venda_impostoretirar,
          ve.venda_descricao != e.venda_descricao,
          ve.venda_lote != e.venda_lote,
          ve.venda_validade != e.venda_validade,
          ve.venda_artigo_id != e.venda_artigo_id,
          ve.venda_metadata::text != e.venda_metadata::text
        ))
  ), __sets as (
    select "returning"::tweeks.venda, row, c._is_extension
      from __calcs c
        inner join lib.sets( _simple, replacer := (to_jsonb( c ) - 'venda_estado' - 'venda_id' - 'venda_taxas')
          || c.docreplacer
          ||  jsonb_build_object(
          'venda_colaborador_atualizacao', case
            when c._venda_id is null then null
            else arg_colaborador_id
          end,
          'venda_dataatualizacao', case
            when c._venda_id is null then null
            else current_timestamp
          end
        )) on true
      where not c._is_extension
    union all
      select _s."returning"::tweeks.venda, c.row, true
        from __sets sui
          inner join __calcs c on sui.row = c.row and c._is_extension
          inner join lib.sets( _simple, replacer := ( to_jsonb( c ) - 'venda_estado' - 'venda_id' - 'venda_taxas' )
              || c.docreplacer
              || jsonb_build_object(
            'venda_venda_id', (sui."returning"::tweeks.venda).venda_id,
            'venda_colaborador_atualizacao', case
              when c._venda_id is null then null
              else arg_colaborador_id
              end,
            'venda_dataatualizacao', case
              when c._venda_id is null then null
              else current_timestamp
            end
          )) _s on true
        where not sui._is_extension
  ) select array_agg( "returning" ) into __vendas from __sets;

  return lib.res_true( jsonb_build_object(
    'vendas', __vendas
  ));
end
$$;


--
-- TOC entry 885 (class 1255 OID 17161)
-- Name: funct_pos_reg_vendaimposto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_reg_vendaimposto(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para aplicar os imposto numa venda
    args := {
      arg_colaborador_id: ID,
      arg_venda_id: ID,
      arg_artigo_id: ID,
      arg_espaco_auth: ID
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_venda_id uuid not null default args->>'arg_venda_id';
  arg_artigo_id uuid not null default args->>'arg_artigo_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  _data record;
  _const map.constant;
  _venda tweeks.venda;

  arg_taxa_taxa double precision;
  arg_taxa_percentagem double precision;
  _taxa_agregada record;

  arg_venda_montantesemimposto double precision;
  arg_valor_retirar_bruto double precision;
  arg_valor_retirar_percentagem double precision;
  arg_imposto_multiplicador double precision;

  arg_venda_impostoadicionar double precision default 0.0;
  arg_venda_impostoretirar double precision default 0.0;
  icount int2 default 0;

begin

  _const := map.constant();
  _venda := tweeks._get_venda( arg_venda_id );

  _taxa_agregada := tweeks._get_impostos_taxa( arg_artigo_id, arg_espaco_auth );


  -- Retivar o valor bruto em seguida retivar o valor da percentagem
  arg_valor_retirar_bruto := _taxa_agregada.taxa_retirar;
  arg_valor_retirar_percentagem := rule.taxa_retirar_percentagem_adicionada(
    _venda.venda_montantetotal - arg_valor_retirar_bruto,
    _taxa_agregada.percentagem_retirar
  );

  arg_venda_montantesemimposto := _venda.venda_montantetotal - ( arg_valor_retirar_bruto + arg_valor_retirar_percentagem );

  -- Desativar todos os impostos que não vão mais ser aplicados
  update tweeks.impostovenda
    set impostovenda_estado = _const.impostovenda_estado_fechado,
        impostovenda_colaborador_atualizacao = arg_colaborador_id,
        impostovenda_dataatualizacao = current_timestamp
    where impostovenda_venda_id = _venda.venda_id
      and impostovenda_estado = _const.impostovenda_estado_ativo
  ;

  for _data in
    select
      ip.*,
      (txass::tweeks.taxa).*,
      tap.*
    from tweeks.imposto ip
      inner join tweeks.taplicar tap on ip.imposto_taplicar_id = tap.taplicar_id
      inner join tweeks.taxa txass on ip.imposto_tipoimposto_id = txass.taxa_tipoimposto_id
    where txass.taxa_id = any( _taxa_agregada.taxas )
      and ip.imposto_artigo_id = arg_artigo_id
      and ip.imposto_estado = _const.maguita_imposto_estado_ativo
  loop

    arg_taxa_taxa := 0;
    arg_taxa_percentagem := 0;
    arg_imposto_multiplicador := 1.0;
    arg_venda_impostoadicionar := 0;
    arg_venda_impostoretirar := 0;

    -- Quando a taxa a aplicar for
    if _data.taxa_percentagem is not null and _data.taxa_percentagem > 0.0 then
      arg_taxa_taxa :=  coalesce( arg_venda_montantesemimposto * ( _data.taxa_percentagem / 100.0 ), 0 );
      arg_taxa_percentagem := _data.taxa_percentagem;

    elsif _data.taxa_taxa is not null and _data.taxa_taxa > 0 then
      arg_taxa_taxa := _data.taxa_taxa;
      arg_taxa_percentagem := ( _data.taxa_taxa  * 100.0 ) / arg_venda_montantesemimposto;

    end if;

    -- Se o valor for zero então saltar a taxa
    if arg_taxa_taxa = 0 then continue; end if;

    if _data.taplicar_id = _const.taplicar_adicionar then
      arg_venda_impostoadicionar := arg_venda_impostoadicionar + arg_taxa_taxa;
    else
      arg_venda_impostoretirar := arg_venda_impostoretirar + arg_taxa_taxa;
    end if;

    if _data.taplicar_id = _const.taplicar_retirar then
      arg_imposto_multiplicador := -1.0;
    end if;

    insert into tweeks.impostovenda(
      impostovenda_venda_id,
      impostovenda_tipoimposto_id,
      impostovenda_espaco_auth,
      impostovenda_colaborador_id,
      impostovenda_valor,
      impostovenda_percentagem
    ) values (
      arg_venda_id,
      _data.taxa_tipoimposto_id,
      arg_espaco_auth,
      arg_colaborador_id,
      ( arg_taxa_taxa * arg_imposto_multiplicador ),
      arg_taxa_percentagem
    );
    icount := icount +1;
  end loop;

  update tweeks.venda
    set venda_montantesemimposto = arg_venda_montantesemimposto,
        venda_montantecomimposto = arg_venda_montantesemimposto + arg_venda_impostoadicionar + arg_venda_impostoretirar,
        venda_imposto = arg_venda_impostoadicionar + arg_venda_impostoretirar,
        venda_impostoadicionar = arg_venda_impostoretirar,
        venda_impostoretirar = arg_venda_impostoretirar
    where venda_id = arg_venda_id
    returning * into _venda
  ;

  return true ? jsonb_build_object(
    'venda', _venda
  );
end;
$$;


--
-- TOC entry 501 (class 1255 OID 17162)
-- Name: funct_pos_report_venda(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_pos_report_venda(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_posto_id uuid default args->>'arg_posto_id';
  arg_date_start date default args->>'arg_date_start';
  arg_date_end date default args->>'arg_date_end';
  branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
begin
  _const := map.constant();
  return query
    with __venda as (
      select
          art.artigo_id,
          art.artigo_nome,
          v.venda_custounitario,
          sum( v.venda_quantidade ) as venda_quantidade,
          sum( v.venda_montantecomimposto ) as venda_montantecomimposto,
          sum( v.venda_montantesemimposto ) as venda_montantesemimposto
        from tweeks.venda v
          inner join tweeks.artigo art on v.venda_artigo_id = art.artigo_id
          inner join tweeks.conta ct on v.venda_conta_id = ct.conta_id
        where v._branch_uid = branch
          and v.venda_estado = _const.maguita_venda_estado_fechado
          and ct.conta_estado = _const.maguita_conta_estado_fechado
          and ct.conta_datafecho::date >= coalesce( arg_date_start, ct.conta_datafecho::date )
          and ct.conta_datafecho::date <= coalesce( arg_date_end, ct.conta_datafecho::date )
          and ct.conta_posto_fecho = arg_posto_id
        group by art.artigo_id,
          v.venda_custounitario
    ) select to_jsonb( v2 )
        from __venda v2
    ;
end;
$$;


--
-- TOC entry 887 (class 1255 OID 17163)
-- Name: funct_reg_acerto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_acerto(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para efetuar o acerto do stock
    args = {
      arg_espaco_auth: ID
      arg_espaco_id: ID,
      arg_colaborador_id := ID,

      acerto_observacao: OBS
      arg_acerto: [{
        artigo_id:UUID,
        acerto_quantidade: QUANTIDADE
      }]
    }
  */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_id uuid not null default args->>'arg_espaco_id';
  arg_acerto_observacao varchar default args->>'acerto_observacao';

  arg_acerto_corecao double precision;

  _const map.constant;
  _stock record;
  _acerto tweeks.acerto;
  _new tweeks.acerto;

  _acerto_group uuid;
  _data record;
  acertos jsonb default jsonb_build_array();
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin
  _const := map.constant();

  for _data in
    select
        (e.doc->>'artigo_id')::uuid as artigo_id,
        (e.doc->>'acerto_quantidade')::double precision as acerto_quantidade
      from jsonb_array_elements( args->'arg_acerto' ) e( doc )
  loop

    _stock := tweeks._get_stock( _data.artigo_id, arg_espaco_id );
    arg_acerto_corecao := _stock.stock_quantidade - _data.acerto_quantidade;
    _acerto_group := public.uuid_generate_v4();
    _new.acerto_codigo := tweeks.__generate_acerto_code( ___branch );
    _new.acerto_colaborador_id :=    arg_colaborador_id;
    _new.acerto_quantidade :=        _data.acerto_quantidade;
    _new.acerto_quantidadeinicial := _stock.stock_quantidade;
    _new.acerto_correcao :=          arg_acerto_corecao;
    _new.acerto_observacao :=        arg_acerto_observacao;
    _new.acerto_espaco_auth :=       arg_espaco_auth;
    _new.acerto_oprgroup :=          _acerto_group;
    _new.acerto_artigo_id :=         _data.artigo_id;
    _new.acerto_espaco_id :=         arg_espaco_id;

    -- Save acerto
    select ( "returning" ).* into _acerto
      from lib.sets_in( _new )
    ;

    _stock := tweeks._get_stock( _data.artigo_id, arg_espaco_id );
    acertos := acertos || jsonb_build_object(
      'acerto', _acerto,
      'stock', _stock,
      'artigo', tweeks._get_artigo( _stock.stock_artigo_id )
    );
  end loop;

  return  true ? acertos;
end;
$$;


--
-- TOC entry 888 (class 1255 OID 17164)
-- Name: funct_reg_artigo(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_artigo(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare

    /**
      Essa funçao serve para registar os artigos associado aos seus item extras
      {
        ///PARA-QUANDO-FOR-COMPOSTO
            artigo_artigo_id: ID
            artigo_compostoquantidade:DOUBLE
        PARA-QUANDO-FOR-COMPOSTO//

        artigo_classe_id: ID,
        artigo_codigo: CODIGO,
        artigo_nome: NOME,
        artigo_preparacao: TRUE|FALSE,
        artigo_stocknegativo: TRUE|FALSE,
        artigo_foto: FOTO,
        artigo_descricao: DESCRICAO,

        --
        artigo_id: ID

        arg_colaborador_id: ID,
        arg_espaco_auth: ID

        arg_items: [
          @id/item_id,
          @id/item_id,
          @id/item_id
        ],

        arg_links: [
          { espaco_id: ID, precario_custo: CUSTO, precario_quantidade: QUANT_CUSTO, stock_minimo:QUANT }
        ],

        arg_imposto: [ {
            arg_tipoimposto_id: ID,
            arg_taplicar_id: ID,
            arg_imposto_valor: VALOR, # Por equanto envie null
            arg_imposto_percentagem: PERCENTAGEM, # Por enquanto envie null
        }],

        arg_ean_codes: [ { ean_code:*CODE, ean_dateout:DATE|NULL, ean_datein:DATE|NULL } ]
        arg_ean_disable: [ CODES ]
      }
     */

    arg_artigo_id uuid default args->>'artigo_id';
    arg_artigo_compostoid uuid default args->>'artigo_artigo_id';
    arg_artigo_compostoquantidade double precision default args->>'artigo_compostoquantidade';
    arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
    arg_classe_id uuid not null default args->>'artigo_classe_id';
    arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
    arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

    arg_artigo_codigo varchar not null  default lib.str_normalize( args->>'artigo_codigo' );

    _artigo tweeks.artigo;
    _const map.constant;
    _res_precario lib.result;
    _result lib.result;
    _branch uuid := tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
    _args tweeks.artigo;
begin

    _const := map.constant();
    _args := jsonb_populate_record( _args, args );
    _artigo := tweeks._get_artigo( _args.artigo_id );

    if _args.artigo_classe_id = _const.classe_itemextra then
        return false ? 'Não pode registar um item extra!';
    end if;

    -- Nome não pode ser duplicado
    if (
        select count( * ) > 0
        from tweeks.artigo art
        where lib.str_normalize( public.unaccent( lower ( art.artigo_nome ) ) ) = lib.str_normalize( public.unaccent( lower ( _args.artigo_nome ) ) )
          and art._branch_uid = _branch
          and art.artigo_id::text != coalesce( arg_artigo_id::text, art.artigo_id||'!?' )
    ) then
        return false ? 'Nome do artigo já existe!';
    end if;

    -- Quando o artigo for novo
    if _artigo.artigo_id is null then
      -- Avaliar a composição do artigo
      if arg_artigo_compostoid is not null and ( arg_artigo_compostoquantidade is null or arg_artigo_compostoquantidade = 0 ) then
        return false ? 'Para artigos composto, é necessario expecificar a quantidade do itens a compor';
      end if;

      _args.artigo_colaborador_id := arg_colaborador_id;
      _args.artigo_espaco_auth := arg_espaco_auth;
      _args.artigo_dataregistro := clock_timestamp();
    else
      _args.artigo_colaborador_id := _artigo.artigo_colaborador_id;
      _args.artigo_espaco_auth := _artigo.artigo_espaco_auth;
      _args.artigo_dataregistro := _artigo.artigo_dataregistro;
      _args.artigo_colaborador_atualizacao := arg_colaborador_id;
      _args.artigo_dataatualizacao := clock_timestamp();
    end if;

    -- Garantir que o codigo do artigo não seja duplicado
    if _args.artigo_codigo is not null and (
      select count( * ) > 0
      from tweeks.artigo art
      where lib.str_normalize( lower( art.artigo_codigo ) ) = lib.str_normalize( lower( _args.artigo_codigo ) )
        and art.artigo_id::text != coalesce( arg_artigo_id::text, art.artigo_id||'!?' )
        and art.artigo_espaco_auth = any( arg_espaco_child )
    ) then
      return false ? 'Código do artigo já existe!';
    elseif _args.artigo_codigo is null and _artigo.artigo_codigo is not null then
      _args.artigo_codigo := _artigo.artigo_codigo;
    end if;

    if _args.artigo_codigo is null then
      _args.artigo_codigo := tweeks.__generate_artigo_code( _args.artigo_classe_id );
    end if;

    select ( "returning" ).* into _artigo
      from lib.sets( _args, jsonb_build_object(
        'artigo_artigo_id', _args.artigo_artigo_id,
        'artigo_compostoquantidade', _args.artigo_compostoquantidade
      ))
    ;

    _result := tweeks.funct_reg_dispoe(
      jsonb_build_object(
        'arg_atrigo_id', _artigo.artigo_id,
        'arg_espaco_auth', arg_espaco_auth,
        'arg_colaborador_id', arg_colaborador_id,
        'arg_items', args->'arg_items'
      )
    );

    _res_precario := tweeks.funct_reg_precario(
        jsonb_build_object(
        'arg_espaco_auth', arg_espaco_auth,
        'arg_colaborador_id', arg_colaborador_id,
        'arg_forced', true,
        'arg_precario_referencia', lib.sets_ref( _artigo ),
        'arg_links', args->'arg_links'
      )
    );

    perform tweeks.funct_reg_imposto(
    jsonb_build_object(
        'arg_artigo_id', _artigo.artigo_id,
        'arg_colaborador_id', arg_colaborador_id,
        'arg_espaco_auth', arg_espaco_auth,
        'arg_imposto', args->'arg_imposto'
      )
    );

    perform tweeks.funct_reg_ean( jsonb_build_object(
      'arg_artigo_id', _artigo.artigo_id,
      'arg_espaco_auth', arg_espaco_auth,
      'arg_colaborador_id', arg_colaborador_id,
      'arg_ean_codes', coalesce( args->'arg_ean_codes', jsonb_build_array() ),
      'arg_ean_disable', coalesce( args->'arg_ean_disable', jsonb_build_array() )
    ));

    _result.message := _result.message || _res_precario.message || jsonb_build_object(
        'artigo', _artigo
    );

    return _result;

exception  when others then
    <<_ex>> declare e text; m text; d text; h text; c text;
    begin
        get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
        return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
    end;
end
$$;


--
-- TOC entry 889 (class 1255 OID 17166)
-- Name: funct_reg_cambio(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_cambio(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registar o valor cambio
    args := {
      arg_branch_uid: UID
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_currency_id
      arg_cambio_taxa: VALOR_TAXA,
      arg_cambio_data: DATE
    }
  */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_branch_uid uuid not null default args->>'arg_branch_uid';
  arg_currency_id int2 not null default args->>'arg_currency_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_cambio_taxa double precision not null default args->>'arg_cambio_taxa';
  arg_cambio_data date not null default args->>'arg_cambio_data';

  _const map.constant;
  _cambio tweeks.cambio;
  arg_cambio_estado int2;
  _data record;
begin

  if arg_branch_uid is null then arg_branch_uid := tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth ); end if;
  if arg_branch_uid is null then arg_branch_uid := tweeks.__branch_uid( null, arg_espaco_auth ); end if;
  if arg_branch_uid is null then arg_branch_uid := tweeks.__branch_uid( arg_colaborador_id, null ); end if;

  _const := map.constant();
  arg_cambio_data := current_date;

  select * into _data
    from  tweeks.cambio cb
    where cb.cambio_currency_id = arg_currency_id
        and cb.cambio_estado = _const.cambio_estado_ativo
        and cb.cambio_espaco_auth = arg_espaco_auth
    order by cb.cambio_dataregistro desc
  ;

  raise notice '%', to_jsonb( _data );



  if arg_currency_id = _const.currency_std
    and ( _data.cambio_id is not null or arg_cambio_taxa != 1 )
  then
    return false ? 'Câmbio de STN não pode ser atualizado!';
  end if;

  update tweeks.cambio
    set cambio_estado = _const.cambio_estado_fechado,
        cambio_dataatualizacao = current_timestamp,
        cambio_colaborador_atualizacao = arg_colaborador_id
    where cambio_estado = _const.cambio_estado_ativo
      and cambio_currency_id = arg_currency_id
      and cambio_espaco_auth = arg_espaco_auth
  ;

  insert into tweeks.cambio (
    cambio_colaborador_id,
    cambio_currency_id,
    cambio_taxa,
    cambio_espaco_auth
  ) values (
    arg_colaborador_id,
    arg_currency_id,
    arg_cambio_taxa,
    arg_espaco_auth
  ) returning * into _cambio;

  return true ? jsonb_build_object( 'cambio', _cambio  );

end;
$$;


--
-- TOC entry 891 (class 1255 OID 17167)
-- Name: funct_reg_classe(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_classe(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função cria uma nova classe
    args {
      arg_espaco_auth: ID
      arg_colaborador_id: ID
      arg_espacos:[{
        espaco_id: UID
      }]

      classe_id:UID     --Apenas para quando for editar
      classe_nome: NOME
      classe_foto: FOTO
      classe_classe_id: ID
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_classe_nome character varying not null default lib.str_normalize( args->>'classe_nome' );
  arg_classe_id uuid default args->>'classe_id';
  _arg_espacos jsonb[] default array( select e.doc from jsonb_array_elements( args->'arg_espacos' ) e( doc ) );
  arg_espacos_id uuid[] default array( select (e.doc->>'espaco_id')::uuid from jsonb_array_elements( args->'arg_espacos' ) e( doc ) );

  arg_espaco_child uuid[];

  _const map.constant;
  _classe tweeks.classe;
  _link tweeks.link;
  _links jsonb;

begin

  _const := map.constant();
  arg_espaco_child := rule.espaco_get_childrens_static( arg_espaco_auth );

  -- Verificar se existe a instancia da classe
  select * into _classe
    from tweeks.classe cla
    where public.unaccent( lower( lib.str_normalize( cla.classe_nome ) ) ) = public.unaccent( lower( lib.str_normalize( arg_classe_nome ) ))
  ;

  if _classe.classe_id = _const.classe_itemextra then
    return false ? 'Esse nome de categoria esta reservado!';
  end if;

  if arg_classe_id is not null then
    select * into _classe
      from tweeks.classe c
      where c.classe_id = arg_classe_id;
  end if;

  _classe.classe_colaborador_id := arg_colaborador_id;
  _classe.classe_espaco_auth := (args->>'arg_espaco_auth')::uuid;

  -- select * into _classe from tweeks.classe;
  select ( "returning" ).* into _classe
    from lib.sets( _classe, replacer :=  args )
  ;


  update tweeks.link
    set link_estado = _const.maguita_link_estado_fechado,
        link_colaborador_atualizacao = arg_colaborador_id,
        link_dataatualizacao = current_timestamp
    where link_estado = _const.maguita_link_estado_ativo
      and link_tlink_id = _const.maguita_tlink_classe
      and link_referencia @> lib.sets_ref( _classe )
      and link_espaco_destino = any( arg_espaco_child )
--       and link_espaco_destino != all( arg_espacos_id )
  ;

  -- Criar ligação com as classes
  select jsonb_agg( to_jsonb( e ) ) into _links
    from unnest( _arg_espacos ) e( doc )
      inner join tweeks.espaco esp on  e.doc @> lib.sets_ref( esp )
      inner join lib.sets( _row := null::tweeks.link, replacer := e.doc|| jsonb_build_object(
        'link_tlink_id', _const.maguita_tlink_classe,
        'link_espaco_destino', esp.espaco_id,
        'link_espaco_auth', arg_espaco_auth,
        'link_colaborador_id', arg_colaborador_id,
        'link_referencia', lib.sets_ref( _classe ),
        'link_nome', format( 'Ligação da categoria %I com %I', _classe.classe_nome, esp.espaco_nome ),
        'link_metadata', jsonb_build_object()
      ) ) on true
  ;

  return lib.result_true(jsonb_build_object(
    'classe', _classe,
    'links', _links
  ));
end;
$$;


--
-- TOC entry 546 (class 1255 OID 17168)
-- Name: funct_reg_colaborador(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_colaborador(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para cadastra novos colaboradores
    Ao cadastar o colaborador a senha é atribuida automaticamente em um random
    E gerado tambem um token que devera ser enviado pela aplicao ao email do colaborador cadastrado
    O email e o NIF tem que ser unico
    args := {
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,
      arg_espaco : [
        { arg_espaco_id: ID }
      ]
      arg_colaborador_email: EMAIL,
      arg_colaborador_nome: NOME,
      arg_colaborador_apelido: APELIDO,
      arg_colaborador_nif: NIF,
      arg_colaborador_datanascimento: DATA,
      arg_colaborador_ficha: FICHA,
      arg_colaborador_foto: FICHA,
      arg_tsexo_id: ID,
      arg_colaborador_senha: DEFAULT_SENHA_IF_EXIST,
      arg_colaborador_pin: DEFAULT_PIN_IF_SET,
      arg_branch_uid: UUID
      arg_colaborador_tipo
    }

   */
  arg_branch_uid uuid                       := args->>'arg_branch_uid';
  arg_colaborador_id uuid                   := args->>'arg_colaborador_id';
  arg_espaco_auth uuid                      := args->>'arg_espaco_auth';
  arg_colaborador_email character varying   := args->>'arg_colaborador_email';
  arg_colaborador_nome character varying    := args->>'arg_colaborador_nome';
  arg_colaborador_apelido character varying := args->>'arg_colaborador_apelido';
  arg_colaborador_nif character varying     := args->>'arg_colaborador_nif';
  arg_colaborador_datanascimento date       := args->>'arg_colaborador_datanascimento';
  arg_colaborador_ficha jsonb               := args->>'arg_colaborador_ficha';
  arg_colaborador_foto varchar               := args->>'arg_colaborador_foto';
  arg_tsexo_id int2                         := args->>'arg_tsexo_id';
  arg_colaborador_token text;
  arg_menu_list jsonb                       := args->>'arg_menu_list';
  arg_colaborador_pin varchar               := args->>'arg_colaborador_pin';
  arg_colaborador_senha varchar             := args->>'arg_colaborador_senha';
  arg_colaborador_tipo int2             := args->>'arg_colaborador_tipo';


  _const map.constant;
  _colaborador auth.colaborador;
  _res lib.result;

begin
  _const := map.constant();
  -- normalizar os dados do colaborador
  arg_colaborador_email := lower( lib.str_normalize( arg_colaborador_email ) );
  arg_colaborador_nif := lower( lib.str_normalize( arg_colaborador_nif ) );
  arg_colaborador_nome := lib.str_normalize( arg_colaborador_nome );
  arg_colaborador_apelido := lib.str_normalize( arg_colaborador_apelido );

  -- As informacoes do tipo texto tem que estar normalizados
  if arg_colaborador_email is null then
    return lib.result_false( '@auth.colaborador.invalid-mail' );
  end if;

  if arg_colaborador_nome is null then
    return lib.result_false( '@auth.colaborador.invalid-name' );
  end if;

  -- Garantir que nao exista o  NIF
  if (
       select count( * )
       from auth.colaborador co
       where co.colaborador_email =  arg_colaborador_email
     ) > 0 then
    return lib.result_false( '@auth.colaborador.email-exist' );
  end if;

  -- Garantir que o nif seja unico
  if (
       select count( * )
       from auth.colaborador co
       where co.colaborador_nif = arg_colaborador_nif
     ) > 0 then
    return lib.result_false( '@auth.colaborador.nif-exist' );
  end if;

  arg_colaborador_tipo := coalesce( arg_colaborador_tipo, _const.colaborador_tipo_user );
  insert into auth.colaborador(
    colaborador_colaborador_id,
    colaborador_email,
    colaborador_nome,
    colaborador_apelido,
    colaborador_nif,
    colaborador_datanascimento,
    colaborador_foto,
    colaborador_tsexo_id,
    colaborador_espaco_auth,
    colaborador_branch_uid,
    colaborador_tipo
  ) values (
     arg_colaborador_id,
     arg_colaborador_email,
     arg_colaborador_nome,
     arg_colaborador_apelido,
     arg_colaborador_nif,
     arg_colaborador_datanascimento,
     arg_colaborador_foto,
     arg_tsexo_id,
     arg_espaco_auth,
     arg_branch_uid,
     arg_colaborador_tipo
   ) returning * into _colaborador;

  perform auth.funct_reg_acesso(
      jsonb_build_object(
          'arg_colaborador_id', arg_colaborador_id,
          'arg_colaborador_propetario', _colaborador.colaborador_id,
          'arg_menu_list', arg_menu_list,
          '_branch_uid', arg_branch_uid
        )
    );

  perform tweeks.funct_reg_trabalha(
      jsonb_build_object(
          'arg_espaco_auth', arg_espaco_auth,
          'arg_colaborador_id', arg_colaborador_id,
          'arg_colaborador_propetario', _colaborador.colaborador_id,
          'arg_espaco', args->'arg_espaco'
      ));

  _res := auth.funct_change_colaborador_accesso_reativar(
      jsonb_build_object(
          'arg_colaborador_id', arg_colaborador_id,
          'arg_colaborador_reative', _colaborador.colaborador_id,
          'arg_colaborador_senha', arg_colaborador_senha,
          'arg_colaborador_pin', arg_colaborador_pin
        )
    );

  return lib.result_true(
        jsonb_build_object(
            'colaborador', lib.jsonb_values(
            to_jsonb( _colaborador ),
            'colaborador_id',
            'colaborador_tsexo_id',
            'colaborador_email',
            'colaborador_nif',
            'colaborador_nome',
            'colaborador_apelido',
            'colaborador_datanascimento',
            'colaborador_ficha',
            'colaborador_dataultimaatualizacasenha',
            'colaborador_accesso',
            'colaborador_estado',
            'colaborador_dataregisto'
          )
          ) || _res.message
    );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 569 (class 1255 OID 134419)
-- Name: funct_reg_conta_nota_credito(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_conta_nota_credito(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      conta_chave: CHAVE
      arg_colaborador_id: UID
      arg_espaco_auth: UID
      conta_id: UID,
      conta_posto_id: UID
      conta_observacao
      itens: [
        { venda_id:ID },
        { venda_id:ID },
        { venda_id:ID }...
      ]
    }
   */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_conta_id uuid default args->>'conta_id';
  arg_branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  __branch cluster.branch;
  _data record;
  _vendas record;
  _conta tweeks.conta;
  _conta_args tweeks.conta;
  _const map.constant;
  _conta_res lib.res;
  _conta_close_res lib.res;
  itens uuid[] default array( select (e.doc->>'venda_id')::uuid from jsonb_array_elements( args->'itens' ) e ( doc ) );
begin
  _const := map.constant();
  _conta_args := jsonb_populate_record( _conta_args, args );
  _conta_args.conta_posto_fecho := _conta_args.conta_posto_id;
  _conta := tweeks._get_conta( arg_conta_id );

  if _conta.conta_estado != _const.maguita_conta_estado_fechado then
    return  lib.res_false( 'Essa conta não se encontra fechada' );
  end if;


  with conta_origin as (
    select
        ct.*,
        ve.*,
        art.*,
        count( venc.venda_id ) > 0 as venda_ncexists
      from tweeks.conta ct
        inner join tweeks.venda ve on ct.conta_id = ve.venda_conta_id
          and ve._branch_uid = arg_branch_uid
          and ve.venda_estado = _const.maguita_venda_estado_fechado
        left join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id
          and art._branch_uid = arg_branch_uid
        left join tweeks.conta ctnc on ct.conta_id = ctnc.conta_conta_docorigin
          and ctnc.conta_estado = _const.maguita_conta_estado_fechado
          and ctnc._branch_uid = arg_branch_uid
        left join tweeks.venda venc on ctnc.conta_id = ve.venda_conta_id
          and venc.venda_venda_docorign = ve.venda_id
          and venc.venda_estado = _const.maguita_venda_estado_fechado
          and venc._branch_uid = arg_branch_uid
      where ct.conta_id = arg_conta_id
      group by ct.conta_id,
        art.artigo_id,
        ve.venda_id
  ), notacareito_usar as (
    select
        count( * ) filter (
          where not ct.venda_ncexists
            and ct.venda_id = any ( itens )
            and ct.venda_venda_id is null
        ) as notacredito_aplicartotal,

        array_agg( ct.venda_id ) filter (
          where not ct.venda_ncexists
            and ct.venda_id = any ( itens )
            and ct.venda_venda_id is null
        ) as notacredito_aplicar,

        count( * ) filter (
          where ct.venda_id = any ( itens )
            and ct.venda_venda_id is null
        ) as notacredito_usartotal,
       array_agg(
         jsonb_build_object(
           'artigo_id', ct.artigo_id,
           'artigo_codigo', ct.artigo_codigo,
           'artigo_nome', ct.artigo_nome,
           'venda_id', ct.venda_id,
           'venda_quantidade', ct.venda_quantidade,
           'venda_custounitario', ct.venda_custounitario
         )
       ) filter (
         where ct.venda_ncexists
           and ct.venda_id = any ( itens )
           and ct.venda_venda_id is null
       ) as notacredito_exists
      from conta_origin ct
  ) select * into _data
     from notacareito_usar
  ;

  if _data.notacredito_aplicartotal = 0 then
    return lib.res_false( 'Nenhum dos iten selecionado pode-se aplicar nota de credito sobre ele' );
  end if;

  if _data.notacredito_aplicartotal < _data.notacredito_usartotal then
    return lib.res_false( 'Alguns dos itens selecionados já têm notas de creditos aplicado sobre ele',
      jsonb_build_object(
          'notacredito_exists', _data.notacredito_exists
        )
    );
  end if;


  /*
    arg_vendas: [
        {
          venda_id?: UID,
          venda_artigo_id: UID,
          venda_quantidade: QUANT,
          venda_custounitario: COST
          venda_custoquantidade: COST

          + venda_editado
          + venda_isencao
          + venda_montante
          + venda_montanteagregado
          + venda_montantetotal
          + venda_imposto
          + venda_montantesemimposto
          + venda_montantecomimposto
          + venda_impostoadicionar
          + venda_impostoretirar

          + venda_descricao
          + venda_lote
          + venda_validade
          + venda_metadata

          arg_itens: [
              venda_id: UID
              venda_artigo_id: UID,
              venda_quantidade: QUANT,
              venda_custounitario: COST
              venda_custoquantidade: COST
              venda_descricao: DESCRICAO
              venda_lote: LOTE
              venda_validade: VALIDADE
              venda_metadata: {... any extras data}
            + venda_montantetotal
          ]
   */
  with __iten as (
    select
        iten.venda_artigo_id,
        iten.venda_quantidade * -1 as venda_quantidade,
        iten.venda_custounitario,
        iten.venda_custoquantidade,
        iten.venda_descricao,
        iten.venda_lote,
        iten.venda_validade,
        iten.venda_metadata,
        iten.venda_taxas,
        iten.venda_montantetotal * -1 as venda_montantetotal,
        iten.venda_id as venda_venda_docorign,
        iten.venda_venda_id as ___iten_venda_super
      from tweeks.venda iten
        inner join tweeks.artigo at on iten.venda_artigo_id = at.artigo_id
          and at._branch_uid = arg_branch_uid
      where iten.venda_venda_id = any( _data.notacredito_aplicar )
        and iten.venda_estado = _const.maguita_venda_estado_fechado
        and iten._branch_uid = arg_branch_uid
  ), __vendas as (
    select
        ve.venda_id as venda_venda_docorign,
        ve.venda_artigo_id,
        ve.venda_quantidade * -1 as venda_quantidade,
        ve.venda_custounitario,
        ve.venda_custoquantidade,
        ve.venda_editado,
        ve.venda_isencao,
        ve.venda_montante * -1 as venda_montante,
        ve.venda_montanteagregado * -1 as venda_montanteagregado,
        ve.venda_montantetotal * -1 as venda_montantetotal,
        ve.venda_imposto * -1 as venda_imposto,
        ve.venda_montantesemimposto * -1 as venda_montantesemimposto,
        ve.venda_montantecomimposto * -1 as venda_montantecomimposto,
        ve.venda_impostoadicionar * -1 as venda_impostoadicionar,
        ve.venda_impostoretirar * -1 as venda_impostoretirar,
        ve.venda_descricao,
        ve.venda_lote,
        ve.venda_validade,
        ve.venda_metadata,
        ve.venda_taxas,
        coalesce( jsonb_agg( to_jsonb( iten ) ) filter ( where iten.venda_venda_docorign is not null ), jsonb_build_array()) as arg_itens
      from tweeks.venda ve
        left join __iten iten on ve.venda_id = iten.___iten_venda_super

      where ve.venda_id = any( _data.notacredito_aplicar )
        and ve.venda_venda_id is null
      group by ve.venda_id
  ) select
        jsonb_agg( to_jsonb( ve ) ) as arg_vendas
        into _vendas
      from __vendas ve
  ;

  /*
   -- obrigatorios
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,

      conta_posto_id: ID,

      -- opcional
      conta_mesa: { numero:NUM, descricao:TEXT, lotacao:NUM }
      conta_id: ID?
      conta_extension: {} | { reserva_id: UID }
      conta_chave: CHAVE

      conta_currency_id: ID,
      conta_tpaga_id: ID,

      conta_cliente_id:UID
      conta_titular: CLIENTE-NOME
      conta_titularnif: CLIENTE-NIF
      conta_data: DATA,

      -- requerido
      arg_vendas
   */



  if _conta.conta_cliente_id is null or _conta.conta_cliente_id = _const.maguita_cliente_final and not exists(
      select *
      from tweeks.cliente c
      where c.cliente_id = _const.maguita_cliente_finalnotacredito
  ) then
      select * into __branch from cluster.branch where _branch_uid = arg_branch_uid;
      insert into tweeks.cliente(
          cliente_id,
          cliente_colaborador_id,
          cliente_colaborador_gerente,
          cliente_espaco_auth,
          cliente_titular,
          _branch_uid,
          cliente_code
      ) values (
           _const.maguita_cliente_finalnotacredito,
           _const.colaborador_system_data,
           __branch.branch_main_user,
           __branch.branch_main_workspace,
           'CONTA DE NOTA DE CREDITO',
           __branch._branch_uid,
           'NC100010'
       );
  end if;
  
  _conta_args.conta_cliente_id := _conta.conta_cliente_id;
  if _conta_args.conta_cliente_id is null or _conta_args.conta_cliente_id = _const.maguita_cliente_final then
      _conta_args.conta_cliente_id := _const.maguita_cliente_finalnotacredito;
  end if;


  _conta_res := tweeks.funct_pos_reg_conta(
    jsonb_build_object(
      'arg_colaborador_id', arg_colaborador_id,
      'arg_espaco_auth', _conta.conta_espaco_auth,
      'conta_posto_id', _conta_args.conta_posto_id,
      'conta_mesa', _conta_args.conta_mesa,
      'conta_extension', coalesce( _conta_args.conta_extension, jsonb_build_object()),
      'conta_chave', _conta_args.conta_chave,
      'conta_currency_id', null,
      'conta_tpaga_id', null,
      'conta_cliente_id', _conta_args.conta_cliente_id,
      'conta_titular', _conta.conta_titular,
      'conta_titularnif', _conta.conta_titularnif,
      'conta_data', current_date,
      'arg_vendas', _vendas.arg_vendas,
      'conta_conta_docorigin', _conta.conta_id,
      'conta_observacao', _conta_args.conta_observacao,
      'conta_espaco_notacredito', arg_espaco_auth
    )
  );

  raise notice '%', to_jsonb(_conta_res);
  
  if not _conta_res.result then
    return _conta_res;
  end if;

  /*
    Essa função fecha uma nova conta
      arg = {
        arg_espaco_auth: ID,
        arg_colaborador_id: ID,

        deposito:{
          deposito_cliente_id
          deposito_caixa_id
          deposito_tpaga_id
          deposito_currency_id
          deposito_posto_id
          deposito_montantemoeda
          deposito_montantetroco
          deposito_data
          deposito_docref: DOCUMENTO-REF?
          deposito_observacao: OBSERVACAO?
        }

        conta_id: ID,
        conta_extension: {} | { reserva_id: UID }
        conta_mesa: { numero:NUM, descricao:TEXT, lotacao:NUM },

        conta_posto_id: ID,
        conta_desconto

        conta_titular: NOME-CLIENTE
        conta_titularnif: VARCHAR,
        conta_data: DATA,
        conta_cliente_id,

        //Relativos a GUIA
        guia_documentoperacao: CODIGO,
        guia_dataopeacao: DATA,
        guia_observacao: DESCRICAO
        guia_metadata: { ... any extras data }

        custos:[{
          custoguia_montante: MONTANTE,
          custoguia_descricao: DESCRICAO PARA O CUSTO
          custoguia_tcusto_id: 1 - DESPESA | 2 - RECEITA
        }]
   */
  
  _conta_close_res := tweeks.funct_pos_change_conta_fechar(
    jsonb_build_object(
      'arg_colaborador_id', arg_colaborador_id,
      'arg_espaco_auth', _conta.conta_espaco_auth,
      'arg_tserie_id', _const.maguita_tserie_notacredito,
      'conta_conta_docorigin', _conta.conta_id,
      'conta_id', _conta_res.data->>'conta_id',
      'conta_extension', jsonb_build_object(),
      'conta_posto_id',  _conta_args.conta_posto_id,
      'conta_posto_fecho',  _conta_args.conta_posto_id,
      'conta_desconto', ( _conta.conta_desconto ),
      'conta_titular', _conta.conta_titular,
      'conta_titularnif', _conta.conta_titularnif,
      'conta_data', coalesce( _conta_args.conta_data, now()::date),
      'conta_cliente_id', _conta_args.conta_cliente_id,
      'guia_documentoperacao', format('NC-%s',  to_char( clock_timestamp(), 'YYYYMMDDHHMISS-US')),
      'guia_observacao', 'Guia de devolução ao stock ao efeturar uma nota de credito',
      'guia_metadata', coalesce( _conta_res.data, jsonb_build_object() ),
      'custos', jsonb_build_array(),
      'conta_chave', _conta_args.conta_chave,
      'arg_group_id', _conta._tgrupo_id
    )
  );

  return _conta_close_res;
end
$$;


--
-- TOC entry 892 (class 1255 OID 17170)
-- Name: funct_reg_dispoe(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_dispoe(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para efetuar o registro da disposicao
    args = {
      arg_colaborador_id: ID,
      arg_espaco_auth: ID
      arg_atrigo_id: ID,
      arg_items: [
        @+id/item_id,
        @+id/item_id,
        @+id/item_id
      ]
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  arg_artigo_id uuid not null default args->>'arg_atrigo_id';
  arg_items jsonb not null default args->'arg_items';

  arg_items_id uuid [] default array( select item_id::uuid from jsonb_array_elements_text( arg_items ) doc ( item_id ) );
  ativated_dispoe tweeks.dispoe[];
  desativated_dispoe tweeks.dispoe[];
  _const map.constant;
begin
  _const := map.constant();



  -- Desativar todos os item atualmente associado ao produto que não faz para da nova disposicao
  with desativateds as (
    update tweeks.dispoe
      set dispoe_estado = _const.dispoe_estado_fechado,
          dispoe_dataatualizacao =   current_timestamp,
          dispoe_colaborador_atualizacao = arg_colaborador_id
      where dispoe_artigo_id = arg_artigo_id
        and dispoe_estado = _const.dispoe_estado_ativo
        and dispoe_artigo_item != all( arg_items_id )
        and dispoe_espaco_auth = any( arg_espaco_child )
      returning *
  ) select array_agg( desa ) into desativated_dispoe
    from desativateds  desa
  ;

  -- Registar os novos itens
  with ativated as (
    insert into tweeks.dispoe (
      dispoe_artigo_id,
      dispoe_artigo_item,
      dispoe_colaborador_id,
      dispoe_espaco_auth
    ) select
        arg_artigo_id,
        it.artigo_id,
        arg_colaborador_id,
        arg_espaco_auth
      from tweeks.artigo it
        left join tweeks.dispoe d on it.artigo_id = d.dispoe_artigo_item
          and d.dispoe_estado = _const.dispoe_estado_ativo
          and d.dispoe_artigo_id = arg_artigo_id
      where it.artigo_id = any ( arg_items_id )
      group by it.artigo_id
      having count( d.dispoe_id ) = 0
      returning *
  ) select array_agg( ins ) into ativated_dispoe
    from ativated ins
  ;

  return true? jsonb_build_object(
    'dispoe_desativated', desativated_dispoe,
    'dispoe_ativated',  ativated_dispoe,
    'dispoe', array (
      select disp
        from tweeks.dispoe disp
        where disp.dispoe_artigo_id = arg_artigo_id
          and disp.dispoe_estado = _const.dispoe_estado_ativo
    )
  );
end;
$$;


--
-- TOC entry 886 (class 1255 OID 17171)
-- Name: funct_reg_ean(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_ean(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**

    Essa função serve para registar varios ean de uma vez
    args := {
      arg_artigo_id: UUID,
      arg_espaco_auth: UUID,
      arg_colaborador_id: UUID,
      arg_ean_codes: [
        { ean_code:CODE, ean_dateout:DATE, ean_datein:DATE }
      ]
      arg_ean_disable: [ CODES ]
    }
   */
  arg_artigo_id uuid not null default args->>'arg_artigo_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_ean_codes jsonb not null default args->'arg_ean_codes';
  arg_ean_disable character varying[] not null default array( select jsonb_array_elements_text(args->'arg_ean_disable') );
  _const map.constant;
  _data record;
  _ean tweeks.ean;
  __eans tweeks.ean[] default array[]::tweeks.ean[];
begin
  _const := map.constant();

  for _data in
    with ___ean as (
      select eandoc.*, ea.ean_id as persitent_ean_id
        from jsonb_array_elements( arg_ean_codes ) e( document )
          left join jsonb_populate_record( null::tweeks.ean, e.document ) eandoc on true
          left join tweeks.ean ea on ea.ean_code = eandoc.ean_code
    ) select *
      from ___ean
  loop
    if _data.persitent_ean_id is not null then
      update tweeks.ean
        set ean_datein = _data.ean_datein,
            ean_dateout = _data.ean_dateout,
            ean_artigo_id = arg_artigo_id
        where ean_id = _data.persitent_ean_id
        returning * into _ean
      ;
      __eans := __eans || _ean;
    else
      insert into tweeks.ean(
        ean_artigo_id,
        ean_espaco_auth,
        ean_colaborador_id,
        ean_code,
        ean_dateout,
        ean_datein
      ) values (
        arg_artigo_id,
        arg_espaco_auth,
        arg_colaborador_id,
        _data.ean_code,
        _data.ean_dateout,
        _data.ean_datein
      ) returning * into _ean;
      __eans := __eans || _ean;
    end if;
  end loop;


  if jsonb_array_length( args->'arg_ean_disable' ) > 0 then
    update tweeks.ean
      set ean_estado = _const.maguita_ean_estado_ativo,
          ena_dateupdate = current_timestamp,
          ean_colaborador_atualizacao = arg_colaborador_id
      where ean_code = any( arg_ean_disable );
  end if;

  return lib.result_true( jsonb_build_object(
      'eans', __eans,
      'disable', array( select e from tweeks.ean e where e.ean_code = any ( arg_ean_disable ))
  ));
end;
$$;


--
-- TOC entry 893 (class 1255 OID 17172)
-- Name: funct_reg_entrada(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_entrada(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa funcao serve para registar as entradas de produto
    args = {
      arg_colaborador_id: *ID,
      arg_espaco_destino: *ID,
      arg_espaco_auth: *ID,



      arg_entradas: [
        artigo_id: *ID,
        entrada_quantidade: *QT,
        entrada_lote: LOTE,
        entrada_validade: LOTE,
        entrada_descricao: DESCRICAO
        entrada_custounitario: PRECO
        entrada_metadata: { ... any extras data }
      ]

      //Relativos a GUIA
      guia_refuid: FORNECEDOR-ID
      guia_documentoperacao: CODIGO,
      guia_dataopeacao: DATA,
      guia_observacao: DESCRICAO
      guia_metadata: { ... any extras data }

      custos:[{
        custoguia_montante: MONTANTE,
        custoguia_descricao: DESCRICAO PARA O CUSTO
        custoguia_tcusto_id: 1 - DESPESA | 2 - RECEITA
      }]
    }
   */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_destino uuid not null default args->>'arg_espaco_destino';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_entrada_codigofatura character varying default args->>'arg_entrada_codigofatura';

  arg_entrada_next int ;

  _entreda tweeks.entrada;
  _new tweeks.entrada;
  __entreda tweeks.entrada[] default array[]::tweeks.entrada[];
  _espaco tweeks.espaco;
  _entrada_group uuid;
  _const map.constant;
  _data record;
  _guia tweeks.guia;
  _branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin

  _const := map.constant();

  _espaco := tweeks._get_espaco( arg_espaco_destino );

  if arg_entrada_codigofatura is null then
    arg_entrada_codigofatura := lib.str_nospace( to_char( arg_entrada_next, '"EN#"000-000' ) );
  end if;

  _entrada_group := public.uuid_generate_v4();

  _guia := jsonb_populate_record( _guia, args );
  _guia.guia_tguia_id := _const.maguita_tguia_entrada;
  _guia.guia_espaco_entrada := arg_espaco_destino;
  _guia.guia_toperacao_id := _const.maguita_toperacao_entrada;
  _guia.guia_refclass := cluster.__format( 'tweeks.fornecedor'::regclass );
  _guia.guia_refs := jsonb_build_object(
      'fornecedor', jsonb_build_object( 'fornecedor_id', _guia.guia_refuid ),
      'destino', jsonb_build_object( 'espaco_id', arg_espaco_destino )
  );

  _guia := tweeks.funct_sets_guia( jsonb_build_object(
    'guia', _guia,
    'custoguia', args->'custos',
    'arg_colaborador_id', arg_colaborador_id,
    'arg_espaco_auth', arg_espaco_auth

  ));

  for _data in
    select
        ( e.doc->>'artigo_id' )::uuid as artigo_id,
        ( e.doc->>'entrada_descricao' ) as entrada_descricao,
        ( e.doc->>'entrada_quantidade' )::double precision as entrada_quantidade,
        ( e.doc->>'entrada_custounitario' )::double precision entrada_custounitario,
        ( e.doc->>'entrada_metadata' )::json entrada_metadata,
        ( e.doc->>'entrada_lote' )::character varying as  entrada_lote,
        ( e.doc->>'entrada_validade' )::date as  entrada_validade
      from jsonb_array_elements( args->'arg_entradas' ) e( doc )
  loop
    _new.entrada_descricao :=       _data.entrada_descricao;
    _new.entrada_artigo_id :=       _data.artigo_id;
    _new.entrada_custounitario :=        _data.entrada_custounitario;
    _new.entrada_quantidade :=      _data.entrada_quantidade;
    _new.entrada_lote :=          _data.entrada_lote;
    _new.entrada_validade :=      _data.entrada_validade;
    _new.entrada_metadata :=      _data.entrada_metadata;

    _new.entrada_espaco_destino :=  arg_espaco_destino;
    _new.entrada_espaco_auth :=     arg_espaco_auth;
    _new.entrada_colaborador_id :=  arg_colaborador_id;
    _new.entrada_guia_id :=         _guia.guia_uid;

    select ( "returning" ).* into _entreda
      from lib.sets_in( _new )
    ;
  end loop;

  return true? jsonb_build_object(
    'guia', _guia,
    'entrada', array(
      select ent
        from tweeks.entrada ent
        where ent.entrada_guia_id = _guia.guia_uid
          and ent.entrada_estado = _const.entrada_estado_ativo
    ),'custoguia', array(
      select cg
        from tweeks.custoguia cg
        where cg.custoguia_guia_uid = _guia.guia_uid
          and cg.custoguia_estado = _const.maguita_custoguia_estado_ativo
    )
  );
end;
$$;


--
-- TOC entry 894 (class 1255 OID 17173)
-- Name: funct_reg_espaco(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_espaco(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $_$
declare
  /**
    Essa função serve para registar os espaços
    args = {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_espaco_vender: BOOLEAN,
      arg_espaco_posto_admin: UUID
      arg_espaco_nome: NOME,
      arg_espaco_descricao: NOME,
      arg_espaco_gerarfatura: BOOLEAN,
      arg_espaco_configurar: BOOLEAN,
      arg_branch_uid: UID
    }
   */

  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_vender character varying default args->>'arg_espaco_vender';
  arg_espaco_nome character varying default lib.str_normalize( args->>'arg_espaco_nome' );
  arg_espaco_gerarfatura boolean default lib.str_normalize( args->>'arg_espaco_gerarfatura' );
  arg_espaco_configurar boolean default lib.str_normalize( args->>'arg_espaco_configurar' );
  arg_espaco_descricao character varying default lib.str_normalize( args->>'arg_espaco_descricao' );
  arg_branch_uid uuid default args->>'arg_branch_uid';
  arg_espaco_posto_admin uuid default args->>'arg_espaco_posto_admin';

  _espaco tweeks.espaco;
  _const map.constant;

begin
  _const := map.constant();

  if (
    select count( * ) > 0
      from tweeks.espaco esp
      where lib.str_normalize( lower( esp.espaco_nome ) ) = lib.str_normalize( lower( arg_espaco_nome ) )
  ) then
    return false ? '@espaco.nome.already-exist';
  end if;

  _espaco.espaco_codigo := cluster.next( 'espaco.codigo/seq',
      sub := arg_branch_uid::text,
      lpad := 2,
      lpad_char := '0',
      --language=PostgreSQL
      exist := format( 'select * from tweeks.espaco where espaco_codigo = $1 and coalesce( _branch_uid, espaco_branch_uid ) = (%L)::uuid', arg_branch_uid ),
      exist_limit := 1000
    );

  insert into tweeks.espaco (
    espaco_branch_uid,
    espaco_espaco_id,
    espaco_espaco_auth,
    espaco_colaborador_id,
    espaco_nome,
    espaco_descricao,
    espaco_gerarfatura,
    espaco_configurar,
    espaco_vender,
    espaco_codigo,
    espaco_posto_admin
  ) values (
    arg_branch_uid,
    arg_espaco_auth,
    arg_espaco_auth,
    arg_colaborador_id,
    arg_espaco_nome,
    arg_espaco_descricao,
    arg_espaco_gerarfatura,
    arg_espaco_configurar,
    arg_espaco_vender,
    _espaco.espaco_codigo,
    arg_espaco_posto_admin
  ) returning * into _espaco;

  perform tweeks.funct_reg_cambio(
    jsonb_build_object(
      'arg_espaco_auth', _espaco.espaco_id,
      'arg_branch_uid', arg_branch_uid,
      'arg_colaborador_id', arg_colaborador_id,
      'arg_currency_id', _const.currency_std,
      'arg_cambio_taxa', 1,
      'arg_cambio_data', make_date( 2000, 01, 01 )
  ));

  return true ? jsonb_build_object(
    'espaco', _espaco
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$_$;


--
-- TOC entry 881 (class 1255 OID 17174)
-- Name: funct_reg_fornecedor(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_fornecedor(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registar um novo fornecedor no sistema
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_fornecedor_nif: ID,
      arg_fornecedor_nome: NOME,
      arg_fornecedor_email: EMAIL,
      arg_fornecedor_contacto: CONTACTO,
      arg_fornecedor_endereco: ENDERECO
    }
  */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_fornecedor_nif character varying default lib.str_normalize( lib.str_nospace( args->>'arg_fornecedor_nif') );
  arg_fornecedor_email character varying default lib.str_nospace( lower( args->>'arg_fornecedor_email' ) );
  arg_fornecedor_nome character varying not null default  lib.str_normalize( args->>'arg_fornecedor_nome' );
  arg_fornecedor_contacto character varying not null default lib.str_normalize( lib.str_nospace( args->>'arg_fornecedor_contacto' ) );
  arg_fornecedor_endereco character varying not null default lib.str_nospace( args->>'arg_fornecedor_endereco' );

  _fornecedor tweeks.fornecedor;
  _branch uuid  default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );

begin

  -- Garantir que tanto o email quanto o nif seja unico
  if(
    select count( * ) > 0
      from tweeks.fornecedor fo
      where fo.fornecedor_nif = arg_fornecedor_nif
  ) then
    return false? 'NIF já existe!';
  end if;

  if(
    select count( * ) > 0
      from tweeks.fornecedor fo
      where fo.fornecedor_email = arg_fornecedor_email
  ) then
    return false? 'Email já existe!';
  end if;
  
  _fornecedor.fornecedor_code := tweeks.__generate_fornecedor_code( _branch );

  insert into tweeks.fornecedor (
    fornecedor_colaborador_id,
    fornecedor_espaco_auth,
    fornecedor_nif,
    fornecedor_nome,
    fornecedor_email,
    fornecedor_contacto,
    fornecedor_endereco,
    fornecedor_code
  ) values (
    arg_colaborador_id,
    arg_espaco_auth,
    arg_fornecedor_nif,
    arg_fornecedor_nome,
    arg_fornecedor_email,
    arg_fornecedor_contacto,
    arg_fornecedor_endereco,
    _fornecedor.fornecedor_code
  ) returning * into _fornecedor;

  return true ? jsonb_build_object(
    'fornecedor', _fornecedor
  );
end;
$$;


--
-- TOC entry 895 (class 1255 OID 17175)
-- Name: funct_reg_imposto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_imposto(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_artigo_id: ID,
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,
      arg_imposto: [
        { arg_tipoimposto_id: ID,
          arg_taplicar_id: ID,
          arg_imposto_valor: VALOR, # Por equanto envie null
          arg_imposto_percentagem: PERCENTAGEM, # Por enquanto envie null
        }
      ]
    }
   */
  arg_artigo_id uuid not null default args->>'arg_artigo_id';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_imposto jsonb not null default args->>'arg_imposto';
  arg_tipoimposto_id uuid[] default array( select ( ele.doc->>'arg_tipoimposto_id')::uuid from jsonb_array_elements( arg_imposto ) ele( doc ) );
  _const map.constant;
begin

  _const := map.constant();

  -- Primeiro desativar as associação dos impostos atual
  update tweeks.imposto
    set imposto_estado = _const.maguita_imposto_estado_fechado,
        imposto_dataregistro = current_timestamp,
        imposto_colaborador_atualizacao = arg_colaborador_id
    where imposto_artigo_id = arg_artigo_id
      and imposto_estado = _const.maguita_imposto_estado_ativo
  ;

  insert into tweeks.imposto(
    imposto_tipoimposto_id,
    imposto_artigo_id,
    imposto_taplicar_id,
    imposto_espaco_auth,
    imposto_colaborador_id,
    imposto_percentagem,
    imposto_valor
  ) select
      ( el.doc->>'arg_tipoimposto_id' )::uuid,
      arg_artigo_id,
      ( el.doc->>'arg_taplicar_id' )::int2,
      arg_espaco_auth,
      arg_colaborador_id,
      ( el.doc->>'arg_imposto_percentagem' )::double precision,
      ( el.doc->>'arg_imposto_valor' )::double precision
    from jsonb_array_elements( arg_imposto ) el( doc )
  ;

  return true ? jsonb_build_object(
    'imposto', array(
      select ip
        from tweeks.imposto ip
        where ip.imposto_artigo_id = arg_artigo_id
          and ip.imposto_estado = _const.maguita_imposto_estado_ativo
    )
  );
end;
$$;


--
-- TOC entry 896 (class 1255 OID 17176)
-- Name: funct_reg_item(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_item(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
    /**
      Essa funçao serve para registar um item
      {
        arg_espaco_auth: ID
        arg_colaborador_id: ID

        artigo_id: ID
        artigo_nome: *NOME
        artigo_descricao: DESCRICAO
        precario_custo: *CUSTO
        precario_quantida: *QUANT
      }
     */

    arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
    arg_espaco_auth uuid not null default args->>'arg_espaco_auth';

    arg_artigo_id uuid default args->>'artigo_id';
    arg_artigo_stocknegativo boolean default args->>'artigo_stocknegativo';
    arg_artigo_nome character varying default args->>'artigo_nome';
    arg_precario_custo double precision default args->>'precario_custo';
    arg_precario_quantidade double precision default args->>'precario_quantidade';

    _result lib.result;
    _const map.constant;
    arg_artigo_codigo varchar;
    _artigo tweeks.artigo;
begin
    _const := map.constant();
    arg_artigo_stocknegativo := coalesce( arg_artigo_stocknegativo, true );
    args := args || jsonb_build_object(
      'artigo_stocknegativo', arg_artigo_stocknegativo
    );

    arg_precario_quantidade := coalesce( arg_precario_quantidade, 1 );
    if (
        select count( * ) > 0
        from tweeks.artigo it
        where lib.str_normalize( lower( it.artigo_nome ) ) = lib.str_normalize( lower( arg_artigo_nome ) )
          and it.artigo_classe_id = _const.classe_itemextra
          and it.artigo_id::text != coalesce( arg_artigo_id::text, it.artigo_id::text||'!?')
    ) then
        return false? 'Nome do item já existe!';
    end if;

    -- Durante o registro
    if arg_artigo_id is null then
        while arg_artigo_codigo is null loop
            arg_artigo_codigo :=  format( 'item#%s', (random() * 999999 )::int );
            if( select count( * ) > 0 from tweeks.artigo where artigo_codigo = arg_artigo_codigo ) then
                arg_artigo_codigo := null;
            end if;
        end loop;

        _artigo := jsonb_populate_record( _artigo, args );
        _artigo.artigo_espaco_auth := arg_espaco_auth;
        _artigo.artigo_colaborador_id := arg_colaborador_id;
        _artigo.artigo_codigo := arg_artigo_codigo;
        _artigo.artigo_stocknegativo := arg_artigo_stocknegativo;
        _artigo.artigo_classe_id := _const.classe_itemextra;

        select ("returning").* into _artigo from lib.sets(_artigo );

    elsif arg_artigo_id is not null then
      _artigo := tweeks._get_artigo( arg_artigo_id );
      _artigo := jsonb_populate_record( _artigo, to_jsonb( _artigo )|| args );
      _artigo.artigo_colaborador_atualizacao := arg_colaborador_id;
      _artigo.artigo_dataatualizacao := now();

      -- Update artigos infos
      select ("returning").* into _artigo
        from lib.sets(_artigo )
        ;
    end if;

    _result := tweeks.funct_reg_precario(
      jsonb_build_object(
        'arg_espaco_auth', arg_espaco_auth,
        'arg_forced', false,
        'arg_colaborador_id', arg_colaborador_id,
        'arg_precario_referencia', jsonb_build_object( 'artigo_id', _artigo.artigo_id ),
        'arg_links', json_build_array( jsonb_build_object(
           'espaco_id', arg_espaco_auth,
           'stock_minimo', null,
           'precario_custo', arg_precario_custo,
           'precario_quantidade', arg_precario_quantidade
         ))
      )
    );

    _result.message := _result.message || jsonb_build_object(
      'artigo', _artigo
    );

    return _result;

exception  when others then
    <<_ex>> declare e text; m text; d text; h text; c text;
    begin
        get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
        return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
    end;
end;
$$;


--
-- TOC entry 897 (class 1255 OID 17177)
-- Name: funct_reg_link_associacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_link_associacao(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para
    args := {
      arg_colaborador_id: ID,
      arg_espaco_auth: ID
      arg_link_nome: NOME,
      arg_link_referencia: REF,
      arg_link_referenciareplace: boolean | default true, -- indica se todos os links apara esse referencia atual vão deixar de existir
      arg_links: [
        { arg_espaco_destino: ID  }
      ]
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );
  arg_links jsonb not null default  args->'arg_links';
  arg_espacos uuid[] not null default array( select ( el.doc->>'arg_espaco_destino' )::uuid from jsonb_array_elements( arg_links ) el( doc ));
  arg_link_referenciareplace boolean default args->>'arg_link_referenciareplace';

  arg_link_referencia jsonb not null default args->>'arg_link_referencia';
  arg_link_nome character varying not null default args->>'arg_link_nome';

  _const map.constant;
  _link tweeks.link;
  _data record;
  arg_artigo_id uuid default arg_link_referencia->>'artigo_id';
  _artigo tweeks.artigo;
  _classe tweeks.classe;
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _aux record;
begin
  arg_link_referenciareplace := coalesce( arg_link_referenciareplace, true );
  _const := map.constant();

  if arg_artigo_id is not null then
    _artigo := tweeks._get_artigo( arg_artigo_id );
    _classe := tweeks._get_classe( _artigo.artigo_classe_id );
  end if;

  -- Desativar desacociar todos dos espaços filhos que não estao na lista
  with aux as (
    -- listar todos os links que devem ser mortos
    select *
      from tweeks.link
      where link_referencia @> arg_link_referencia
        and link_estado = _const.maguita_link_estado_ativo
        and link_tlink_id = _const.maguita_tlink_associacao
        and link_espaco_destino != all ( arg_espacos )
        and link_espaco_auth = any( arg_espaco_child )
        and _branch_uid = ___branch
        and arg_link_referenciareplace
  )
  update tweeks.link
    set link_estado = _const.maguita_link_estado_fechado,
        link_dataatualizacao = current_timestamp,
        link_colaborador_atualizacao = arg_colaborador_id
    where link_id in ( select link_id from aux )
      or link_link_associacao in ( select link_id from aux )
  ;

  for _data in
    select
        ( it.doc->>'arg_espaco_destino' )::uuid as arg_espaco_destino,
        ( it.doc->>'arg_link_custo' )::numeric as arg_link_custo,
        ( it.doc->>'arg_link_quantidadecusto' )::numeric arg_link_quantidadecusto
      from jsonb_array_elements( arg_links ) it ( doc )
        left join tweeks.link l on it.doc @> jsonb_build_object( 'arg_espaco_destino', l.link_espaco_destino )
          and l.link_referencia @> arg_link_referencia
          and l.link_estado = _const.maguita_link_estado_ativo
          and l.link_tlink_id = _const.maguita_tlink_associacao
          and l._branch_uid = ___branch
      where l.link_id is null
  loop

    -- Lincar os protudos ao espaço
    insert into tweeks.link (
      link_tlink_id,
      link_referencia,
      link_espaco_auth,
      link_espaco_destino,
      link_colaborador_id,
      link_posicao,
      link_nome,
      link_estado
    ) values (
      _const.maguita_tlink_associacao,
      arg_link_referencia,
      arg_espaco_auth,
      _data.arg_espaco_destino,
      arg_colaborador_id,
      -1,
      arg_link_nome,
      _const.maguita_link_estado_ativo
    ) returning * into _link ;

    if coalesce( _data.arg_link_quantidadecusto, 0 ) = 0 or coalesce( _data.arg_link_custo, 0 ) = 0 then
      _data.arg_link_quantidadecusto := null;
      _data.arg_link_custo := null;
    end if;
    -- Linkar tambem a classe quando for linkar o produto (adicionar o link da classe ao espaco se ainda não houver)
    if _artigo.artigo_id is not null and (
      select count( * ) = 0
        from tweeks.link lk
        where lk.link_espaco_destino = _data.arg_espaco_destino
          and lk.link_referencia @> rule.classe_referencia( _classe.classe_id )
          and lk.link_tlink_id = _const.maguita_tlink_associacao
          and lk.link_estado = _const.maguita_link_estado_ativo
          and lk._branch_uid = ___branch
    ) then
      -- Criar o link para o destino
      perform tweeks.funct_reg_link_associacao( jsonb_build_object(
        'arg_colaborador_id', arg_colaborador_id,
        'arg_espaco_auth', arg_espaco_auth,
        'arg_link_nome', _classe.classe_nome,
        'arg_link_referencia', rule.classe_referencia( _classe.classe_id ),
        'arg_link_referenciareplace', false,
        'arg_links', json_build_array( json_build_object(
          'arg_espaco_destino', _data.arg_espaco_destino
        ))
      ));
    end if;

    -- Quando for artigo linkar também os tipos de imposto ao espaco
    for _aux in
      select *
        from tweeks.imposto ip
          inner join tweeks.tipoimposto tip on ip.imposto_tipoimposto_id = tip.tipoimposto_id
          left join tweeks.link lk on lk.link_referencia @> rule.tipoimposto_referencia( tip.tipoimposto_id )
            and lk.link_estado = _const.maguita_link_estado_ativo
            and lk.link_espaco_destino = _data.arg_espaco_destino
            and lk.link_tlink_id = _const.maguita_tlink_associacao
        where _artigo.artigo_id is not null
          and ip._branch_uid = ___branch
          and lk._branch_uid = ___branch
          and ip.imposto_artigo_id = _artigo.artigo_id
          and ip.imposto_estado = _const.maguita_imposto_estado_ativo
          and lk.link_id is null
    loop
      perform tweeks.funct_reg_link_associacao( jsonb_build_object(
          'arg_colaborador_id', arg_colaborador_id,
          'arg_espaco_auth', arg_espaco_auth,
          'arg_link_nome', _aux.tipoimposto_nome,
          'arg_link_referencia', rule.tipoimposto_referencia( _aux.tipoimposto_id ),
          'arg_link_referenciareplace', false,
          'arg_links', json_build_array( json_build_object(
            'arg_espaco_destino', _data.arg_espaco_destino
          ))
        ));
    end loop;
  end loop;

  return  true ? jsonb_build_object(
    'link', array(
      select l
        from tweeks.link l
        where l.link_referencia @> arg_link_referencia
          and l.link_estado = _const.maguita_link_estado_ativo
          and l.link_tlink_id = _const.maguita_tlink_associacao
          and l._branch_uid = ___branch
    )
  );
end;
$$;


--
-- TOC entry 899 (class 1255 OID 17179)
-- Name: funct_reg_link_tecla(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_link_tecla(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para registar as link
    args := {
      arg_link_id: ID,
      arg_link_associacao: ID,
      arg_tlink_id: ID,
      arg_artigo_id: ID,
      arg_espaco_auth: ID,
      arg_espaco_destino: ID,
      arg_colaborador_id: ID,
      arg_link_posicao: POSICAO,
      arg_link_nome: NOME,
      arg_link_config: JSON,
    }
  */

  arg_link_id uuid default args->>'arg_link_id';
  arg_link_associacao uuid not null default args->>'arg_link_associacao';
  arg_artigo_id uuid default args->>'arg_artigo_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_destino uuid not null default args->>'arg_espaco_destino';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id' ;

  arg_tlink_id int2 default args->>'arg_tlink_id';
  arg_link_posicao int2 not null default args->>'arg_link_posicao';
  arg_link_nome character varying not null default args->>'arg_link_nome';
  arg_link_config jsonb not null default args->'arg_link_config';

  arg_link_estado int2;

  _const map.constant;
  _link tweeks.link;
  _link_associacao tweeks.link;
  _artigo tweeks.artigo;

begin

  lock table tweeks.link in share mode;
  lock table tweeks.artigo in share mode;

  _const := map.constant();
  _link := tweeks._get_link( arg_link_id );
  _link_associacao := tweeks._get_link( arg_link_associacao );
  _artigo := tweeks._get_artigo( arg_artigo_id );

  -- Garantir que a link estejá livre
  if (
    select count( * ) > 0
      from tweeks.link a
      where a.link_espaco_destino = arg_espaco_destino
        and coalesce( a.link_link_id, -1 ) = coalesce( arg_link_id, -1 )
        and a.link_posicao = arg_link_posicao
        and a.link_estado = _const.acerto_estado_ativo
  ) then
    return false ? '@tweeks.link.position-is-occupied';
  end if;

  -- Garantir que link do produto não entra nenhuma sub-link
  if _link.link_referencia->>'artigo_id' is not null then
    return false ? '@tweeks.link.is-a-article';
  end if;

  if _link.link_estado != _const.link_estado_ativo then
    return false ? '@tweeks.link.is-closed';
  end if;

  if _artigo.artigo_id is not null then
    arg_link_nome := _artigo.artigo_nome;
  end if;

  insert into tweeks.link (
    link_link_id,
    link_link_associacao,
    link_tlink_id,
    link_referencia,
    link_espaco_destino,
    link_espaco_auth,
    link_colaborador_id,
    link_posicao,
    link_nome,
    link_config,
    link_extras
  ) values (
    arg_link_id,
    arg_link_associacao,
    arg_tlink_id,
    jsonb_build_object( 'artigo_id', arg_artigo_id ),
    arg_espaco_destino,
    arg_espaco_auth,
    arg_colaborador_id,
    arg_link_posicao,
    arg_link_nome,
    arg_link_config,
    _link_associacao.link_extras
  ) returning * into _link;

  return true ? jsonb_build_object(
    'link', _link
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 900 (class 1255 OID 17180)
-- Name: funct_reg_mesa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_mesa(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para cadastrar uma nova mesa
    args := {
      arg_colaborador_id: ID,
      arg_mesa_numero: NUMERO,
      arg_mesa_lotacao: NUMERO,
      arg_mesa_descricao: DESCRICAO,
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_mesa_numero varchar not null default lib.str_normalize( args->>'arg_mesa_numero' );
  arg_mesa_descricao varchar default lib.str_normalize( args->>'arg_mesa_descricao' );
  arg_mesa_lotacao int2 default args->>'arg_mesa_lotacao';

  _mesa tweeks.mesa;

begin

  -- Garantir que o numero de mesa seja unico
  if (
    select count( * ) > 0
    from tweeks.mesa m
    where m.mesa_numero =  arg_mesa_numero
  ) then
    return false ? '@mesa.numero.already-exist';
  end if;

  insert into tweeks.mesa (
    mesa_colaborador_id,
    mesa_lotacao,
    mesa_numero,
    mesa_designacao
  ) values (
    arg_colaborador_id,
    arg_mesa_lotacao,
    arg_mesa_numero,
    arg_mesa_descricao
  ) returning * into _mesa;

  return true ? jsonb_build_object(
    'mesa', _mesa
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 902 (class 1255 OID 17181)
-- Name: funct_reg_posto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_posto(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
    declare
      /**
        Essa função serve para criar uma posto para o colaborador
        args := {
          arg_posto_id: UUID
          arg_espaco_auth: ID,
          arg_espaco_destino: [ID, ID, ID],
          arg_colaborador_id: ID
          arg_posto_multiplecaixa: BOOLEAN
    
          arg_posto_matricula:  MATRICULA (CHAVE TEMPORARIA),
          arg_posto_designacao: DESIGNACAO,
          arg_tposto_id: ID,
          arg_posto_multipleuser: BOOLEAN,
          arg_posto_designcao: ID,
          arg_posto_montanteinicial: MONTANTE_INICIAL,
          posto_authmode: AUTH-MODE,
          posto_caixamode: CAIXA-MODE,
        }
      */
    
      arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
      arg_posto_id uuid default args->>'arg_posto_id';
      arg_espaco_destino uuid[] not null default array( select e.text from jsonb_array_elements_text( args->'arg_espaco_destino') e( text ));
      arg_posto_designacao character varying not null default args->>'arg_posto_designacao';
      arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
      arg_tposto_id int2 not null default args->>'arg_tposto_id';
      arg_posto_multiplecaixa boolean default args->>'arg_posto_multiplecaixa';
      arg_posto_matricula character varying default   args->>'arg_posto_matricula';
      arg_posto_montanteinicial float default         args->>'arg_posto_montanteinicial';
      arg_posto_authmode int2 not null default        args->>'posto_authmode';
      arg_posto_caixamode int2 not null default       args->>'posto_caixamode';
    
      _const map.constant;
      _posto tweeks.posto;
    
    begin
    
      _const := map.constant();
    
      if arg_posto_id is null then
        if (
          select count( * ) > 0
          from tweeks.posto p
          where p.posto_matricula = arg_posto_matricula
        ) then
          return false ? 'Código do posto já existe!';
        end if;
    
        _posto.posto_espaco_auth := arg_espaco_auth;
        _posto.posto_tposto_id := arg_tposto_id;
        _posto.posto_colaborador_id := arg_colaborador_id;
        _posto.posto_designacao := arg_posto_designacao;
        _posto.posto_multiplecaixa := coalesce( arg_posto_multiplecaixa, true );
        _posto.posto_matricula := arg_posto_matricula;
        _posto.posto_chave := tweeks.__generate_posto_chave();
        _posto.posto_authmode := arg_posto_authmode;
        _posto.posto_caixamode := arg_posto_caixamode;
    
        select ( "returning" ).* into _posto from lib.sets_in( _posto );
    
        update tweeks.chave
        set chave_definitiva = _posto.posto_chave
        where chave_temporarai = _posto.posto_matricula
        ;
      else
        select ( "returning" ).* into _posto
        from tweeks.posto p
          inner join lib.sets_up( p, replacer := args||jsonb_build_object(
            'posto_tposto_id', arg_tposto_id,
            'posto_designacao', arg_posto_designacao,
            'posto_multiplecaixa', coalesce( arg_posto_multiplecaixa, true ),
            'posto_authmode', arg_posto_authmode,
            'posto_caixamode', arg_posto_caixamode
          )) up on true
        where p.posto_id = arg_posto_id
        ;
      end if;
    
      -- Desativar os antigos espaços alocados ao posto
      update tweeks.aloca
      set aloca_estado = _const.maguita_aloca_estado_fechado,
          aloca_colaborador_atualizacao = arg_colaborador_id,
          aloca_dataatualizacao = current_timestamp
      where aloca_posto_id = _posto.posto_id
        and aloca_espaco_destino != all( arg_espaco_destino )
      ;
    
      -- Criar nova alocaçoes
      insert into tweeks.aloca(
        aloca_posto_id,
        aloca_espaco_destino,
        aloca_espaco_auth,
        aloca_colaborador_id,
        aloca_montante
      ) select
          _posto.posto_id,
          n.next,
          arg_espaco_auth,
          arg_colaborador_id,
          coalesce( arg_posto_montanteinicial, 0 )
      from unnest( arg_espaco_destino ) n( next )
             left join tweeks.aloca al on n.next = al.aloca_espaco_destino
        and al.aloca_posto_id = _posto.posto_id
        and al.aloca_estado = _const.maguita_aloca_estado_ativo
      where al.aloca_id is null
      ;
    
      return true ? jsonb_build_object(
          'posto', _posto,
          'aloca', array(
              select to_jsonb( a )
              from tweeks.aloca a
              where a.aloca_posto_id = _posto.posto_id
                and a.aloca_estado = _const.maguita_aloca_estado_ativo
            )
        );
    end;
    $$;


--
-- TOC entry 903 (class 1255 OID 17182)
-- Name: funct_reg_precario(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_precario(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registrar e atualizar os preços dos itens
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_forced: boolean,
      arg_precario_referencia: {
        artigo_id: ID,
      },
      arg_links :[
        {  espaco_id: *ID,
           stock_minimo: QUNT
           precario_custo: CUSTO,
           precario_quantidade: QUANT_CUSTO }
      ]
    }
  */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';

  arg_precario_referencia jsonb not null default args->>'arg_precario_referencia';
  arg_forced boolean default args->>'arg_forced';
  arg_artigo_id uuid;

  arg_espacos_destino uuid[] default array ( select ( e.doc->>'espaco_id' )::uuid from jsonb_array_elements( args->'arg_links') e( doc ) );
  arg_espaco_child uuid[] default rule.espaco_get_childrens_static( arg_espaco_auth );

  _const map.constant;
  _artigo tweeks.artigo;
  _branch uuid := tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );

begin
  _const := map.constant();
  arg_forced := coalesce( arg_forced, false );

  arg_artigo_id := arg_precario_referencia->>'artigo_id';


  if not arg_forced and arg_artigo_id is not null then
    _artigo := tweeks._get_artigo( arg_artigo_id );

    -- Alterar o preço apenas quando o artigo não estiver em nenhuma conta aberta
    if (
         select count( * ) > 0
         from tweeks.venda ag
         where ag.venda_artigo_id = arg_artigo_id
           and ag.venda_estado in ( _const.maguita_venda_estado_aberto )
          and ag._branch_uid = _branch
       ) then
      return false ? '@tweeks.artigo.price-can-not-update-open-account';
    end if;
  end if;

  -- Desativar o precario atual
  update tweeks.link
    set link_estado = _const.maguita_link_estado_fechado,
        link_dataatualizacao = now(),
        link_colaborador_atualizacao = arg_colaborador_id
    where link_referencia @> arg_precario_referencia
      and link_estado = _const.maguita_link_estado_ativo
      and link_espaco_destino = any( arg_espaco_child )
      and _branch_uid = _branch
      and link_tlink_id = _const.maguita_tlink_preco   
  ;

   -- Criar os novos precarios
   insert into tweeks.link(
      link_tlink_id,
      link_espaco_destino,
      link_espaco_auth,
      link_colaborador_id,
      link_referencia,
      link_posicao,
      link_nome,
      link_metadata
    ) select
      (map.constant()).maguita_tlink_preco,
      ( lp.doc->>'espaco_id' )::uuid,
      arg_espaco_auth,
      arg_colaborador_id,
      arg_precario_referencia,
      0,
      format( 'Preço de %s para %s', _artigo.artigo_nome, e.espaco_nome ),
      jsonb_build_object(
          'precario_custo', ( lp.doc->>'precario_custo' )::double precision,
          'stock_minimo', ( lp.doc->>'stock_minimo' )::double precision,
          'precario_quantidade', (lp.doc->>'precario_quantidade')::double precision
      )
      from jsonb_array_elements( args->'arg_links' ) lp( doc )
        inner join tweeks.espaco e on (lp.doc->>'espaco_id')::uuid = e.espaco_id
    ;
  
  return lib.result_true(jsonb_build_object(
    'precario', array(
        select to_jsonb( l )
          from tweeks.link l
          where l.link_espaco_destino = any( arg_espacos_destino )
            and (l.link_referencia ->>'artigo_id')::uuid = (arg_precario_referencia->>'artigo_id')::uuid
            and l.link_estado = _const.maguita_link_estado_ativo
            and l.link_tlink_id = _const.maguita_tlink_preco
            and l._branch_uid = _branch
    )
  ));
end;
$$;


--
-- TOC entry 904 (class 1255 OID 17183)
-- Name: funct_reg_stock(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_stock(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id: ID,
      arg_artigo_id: ID,
      arg_espacao_id: ID,
      arg_stock_quantidade: QUANT,
    }
   */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_artigo_id uuid not null default args->>'arg_artigo_id';
  arg_espacao_id uuid not null default args->>'arg_espacao_id';
  arg_stock_quantidade double precision default args->>'arg_stock_quantidade';

  _stock tweeks.stock;

begin

  -- Garantir que não existe um estock desse produto para o local já definico
  if (
    select count( * ) > 0
      from tweeks.stock st
      where st.stock_espacao_id = arg_espacao_id
        and st.stock_artigo_id = arg_artigo_id
  ) then
    return false ? 'Stock já existe!';
  end if;

  -- Criar o novo stock
  insert into tweeks.stock(
    stock_artigo_id,
    stock_espacao_id,
    stock_colaborador_id
  )  values (
    arg_artigo_id,
    arg_espacao_id,
    arg_colaborador_id
  ) returning * into _stock;


  -- Atualizar o stock se a quantidade de stock for diferente que zero
  if arg_stock_quantidade then
    perform tweeks.funct_reg_acerto(
      jsonb_build_object(
        'arg_colaborador_id', arg_colaborador_id,
        'arg_artigo_id', arg_artigo_id,
        'arg_espaco_id', arg_espacao_id,
        'arg_acerto_quantidade', arg_stock_quantidade,
        'arg_acerto_observacao', 'Acerto inicial para começar o stock com uma quantidade expeficica dos produto.'
      )
    );
  end if;

  return true ? jsonb_build_object(
    'stock', _stock
  );
end;
$$;


--
-- TOC entry 905 (class 1255 OID 17184)
-- Name: funct_reg_taxa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_taxa(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_espaco_auth: ID,
      arg_colaborador_id: ID,
      arg_tipoimposto_id: ID,
      arg_taxa_percentagem: ID,
      arg_taxa_taxa: VALOR
    }
   */

  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_tipoimposto_id uuid default args->>'arg_tipoimposto_id';
  arg_taxa_percentagem double precision default args->>'arg_taxa_percentagem';
  arg_taxa_taxa double precision default args->>'arg_taxa_taxa';

  _const map.constant;
  _taxa tweeks.taxa;
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
begin

  _const := map.constant();

  -- Desativar todas as taxas atual
  update tweeks.taxa
    set taxa_estado = _const.taxa_estado_fechado,
        taxa_dataatualizacao = current_timestamp,
        taxa_colaborador_atualizacao = arg_colaborador_id
    where taxa_espaco_auth = arg_espaco_auth
      and taxa_tipoimposto_id = arg_tipoimposto_id
      and taxa_estado = _const.taxa_estado_ativo
      and _branch_uid = ___branch
  ;

  -- Criar o novo imposto
  insert into tweeks.taxa (
    taxa_tipoimposto_id,
    taxa_colaborador_id,
    taxa_percentagem,
    taxa_taxa,
    taxa_espaco_auth
  ) values (
    arg_tipoimposto_id,
    arg_colaborador_id,
    arg_taxa_percentagem,
    arg_taxa_taxa,
    arg_espaco_auth
  ) returning * into _taxa;

  return true ? jsonb_build_object(
    'taxa', _taxa
  );

end;
$$;


--
-- TOC entry 878 (class 1255 OID 17185)
-- Name: funct_reg_trabalha(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_trabalha(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para registar os locas que um colaborador pode trabalhar
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,
      arg_colaborador_propetario: ID,
      arg_espaco : [
        { arg_espaco_id: ID }
      ]
    }
  */
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid  not null default args->>'arg_espaco_auth';
  arg_espaco_child uuid[ ] default rule.espaco_get_childrens( arg_espaco_auth );
  arg_colaborador_propetario uuid default args->>'arg_colaborador_propetario';
  arg_espaco uuid[ ] not null default array ( select ( el.doc->>'arg_espaco_id' )::uuid from jsonb_array_elements( args->'arg_espaco' ) el ( doc ) );
  _const map.constant;
  __branch_uid uuid;
  _branch  tweeks.branch;
begin
  _const := map.constant();
  _branch := tweeks._get_branch_by_colaborador( arg_colaborador_propetario );


  -- Fechar todos os espaços em que o colaborador não vai mais trabalhar
  update tweeks.trabalha
    set trabalha_estado = _const.maguita_trabalha_estado_fechado,
        trabalha_colaborador_atualizacao = arg_colaborador_id,
        trabalha_dataatualizacao = current_timestamp
    where trabalha_estado = _const.maguita_trabalha_estado_ativo
      and trabalha_colaborador_proprietario = arg_colaborador_propetario
      and trabalha_espaco_auth = any( arg_espaco_child )

  ;

  insert into tweeks.trabalha (
    trabalha_colaborador_id,
    trabalha_colaborador_proprietario,
    trabalha_perfil_id,
    trabalha_espaco_destino,
    trabalha_espaco_auth,
    _branch_uid
  ) select arg_colaborador_id,
      arg_colaborador_propetario,
      null,
      es.arg_espaco_id,
      arg_espaco_auth,
     __branch_uid
    from unnest( arg_espaco ) es ( arg_espaco_id )
  ;

  return true ? jsonb_build_object(
    'trabalha', array(
      select tr
        from tweeks.trabalha tr
        where tr.trabalha_estado = _const.maguita_trabalha_estado_ativo
          and tr.trabalha_colaborador_proprietario = arg_colaborador_propetario
    )
  );
end;
$$;


--
-- TOC entry 906 (class 1255 OID 17186)
-- Name: funct_reg_transacao_movimentacao_posto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_transacao_movimentacao_posto(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para transacionar o valor de um posto
    args := {
      arg_espaco_auth: ID
      arg_posto_id: ID,
      arg_tmovimento_id: ID,
      arg_colaborador_id: ID,
      arg_transacao_zerar: BOOLEAN,
      arg_transacao_montante: float,

      arg_transacao_documento: NULL,
      arg_transacao_observacao: NULL
    }
   */
  arg_posto_id uuid := args->>'arg_posto_id';
  arg_espaco_auth uuid not null := args->>'arg_espaco_auth';
  arg_tmovimento_id int2 := args->>'arg_tmovimento_id';
  arg_colaborador_id uuid := args->>'arg_colaborador_id';
  arg_transacao_zerar boolean := args->>'arg_transacao_zerar';
  arg_transacao_montante double precision := args->>'arg_transacao_montante';
  arg_transacao_documento varchar := args->>'arg_transacao_documento';
  arg_transacao_observacao varchar := args->>'arg_transacao_observacao';

  _const map.constant;
  _posto tweeks.posto;
  _transacao tweeks.transacao;
  _caixa tweeks.caixa;

begin
  _const := map.constant();
  _posto := tweeks._get_posto( arg_posto_id );

  select * into _caixa
    from tweeks.caixa cx
    where cx.caixa_posto_id = _posto.posto_id
      and cx.caixa_estado = _const.caixa_estado_ativo
  ;

  arg_transacao_zerar := coalesce( arg_transacao_zerar, false );

  -- Quando for para zerar a conta então montate aqui sera de zero
  if arg_transacao_zerar then
    arg_transacao_montante := 0;
  end if;

  -- Quando houver documentos
  if arg_transacao_documento is null and _caixa.caixa_id is not null then
    arg_transacao_documento := lib.str_nospace( to_char( _caixa.caixa_id, '"CX#"000-000' ) );

  elseif arg_transacao_documento is null then
    arg_transacao_documento := lib.str_nospace( to_char( nextval( 'tweeks.seq_transacao_movimento' ), '"MV#"000-000' ) );
  end if;

  -- Garantir que quando for deito o montante a debitar menor igaul ao montante no posto
  if arg_tmovimento_id = _const.tmovimento_debito and arg_transacao_montante > _posto.posto_montante then
    return false ? '@tweeks.transacao.montante-insuficient';
  end if;

  _transacao := rule.transacao_create(
      arg_espaco_auth,
      arg_posto_id,
      _const.toperacao_movimento,
      arg_tmovimento_id,
      arg_colaborador_id,
      arg_transacao_montante,
      arg_transacao_documento,
      null,
      arg_transacao_zerar,
      arg_transacao_observacao
    );

  return true ? jsonb_build_object(
    'transacao', _transacao
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 907 (class 1255 OID 17187)
-- Name: funct_reg_transferencia(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_reg_transferencia(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registar uma transferencia de stock
    args := {
      arg_espaco_auth: *ID
      arg_colaborador_id: *ID,
      arg_espaco_origem: *ID,
      arg_espaco_destino: *ID,

      arg_transferencia_data: DATA,
      arg_transferencia_documento: DOC,
      arg_transferencia_observacao: OBS,
      arg_transferencias:[ {
        artigo_id: *ID,
        transferencia_quantidade: *QUANT
      }]
    }
  */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_espaco_origem uuid not null default args->>'arg_espaco_origem';
  arg_espaco_destino uuid not null default args->>'arg_espaco_destino';


  arg_transferencia_data date default args->>'arg_transferencia_data';
  arg_transferencia_documento character varying default lib.str_normalize( args->>'arg_transferencia_documento' );
  arg_transferencia_observacao character varying default lib.str_nospace( args->>'arg_transferencia_observacao' );
  arg_transferencias jsonb default args->'arg_transferencias';

  _espaco_origem tweeks.espaco;
  _espaco_destino tweeks.espaco;
  _const map.constant;
  _data record;

begin

  _const := map.constant();

  arg_transferencia_documento := coalesce( arg_transferencia_documento, upper( lib.dset_random_name( 2, 9 ) ) );
  _espaco_origem := tweeks._get_espaco( arg_espaco_origem );
  _espaco_destino := tweeks._get_espaco( arg_espaco_destino );

  if _espaco_origem.espaco_estado = _const.maguita_espaco_estado_fechado then
    return false ? '@tranferencia.espaco.origem.estatado-fechado';
  end if;

  if _espaco_destino.espaco_estado = _const.maguita_espaco_estado_fechado then
    return false ? '@tranferencia.espaco.destino.estatado-fechado';
  end if;

  with __transferencia as (
    select
        ( e.doc->>'artigo_id' )::uuid as artigo_id,
        ( e.doc->>'transferencia_quantidade' )::double precision as transferencia_quantidade
      from jsonb_array_elements( arg_transferencias ) e( doc )
  ), __esgotado as (
      select *
        from __transferencia tr
          inner join tweeks.artigo art on tr.artigo_id = art.artigo_id
          inner join tweeks._get_stock( art.artigo_id, arg_espaco_origem ) s on art.artigo_id = s.stock_artigo_id
            and s.stock_espaco_id = arg_espaco_origem
        where s.stock_quantidade < tr.transferencia_quantidade
  ) select
      count( * ) as esgotado_total,
      string_agg( format( '%s disponivel: %s, em falta: %s', artigo_nome, e.stock_quantidade, e.transferencia_quantidade - e.stock_quantidade ), ', ' ) as esgotado_message
      into _data
    from __esgotado e
  ;

--   if _data.esgotado_total > 0 then
--     return lib.result_false( format( 'Quantidade dos artigos disponivel insuficiente para a transferencia.<br/> Artigos: %s', _data.esgotado_message ));
--   end if;

  with  __args as (
    select
        ( e.doc->>'artigo_id' )::uuid as artigo_id,
        ( e.doc->>'transferencia_quantidade' )::double precision as transferencia_quantidade
      from jsonb_array_elements( arg_transferencias ) e( doc )
  ), __transferencia as (
      select a.*
      from __args a
  ), __register as (
    insert into tweeks.transferencia (
        transferencia_espaco_auth,
        transferencia_artigo_id,
        transferencia_espaco_origem,
        transferencia_espaco_destino,
        transferencia_colaborador_id,
        transferencia_quantidade,
        transferencia_data,
        transferencia_documento,
        transferencia_observacao
  ) select
       arg_espaco_auth,
       artigo_id,
       arg_espaco_origem,
       arg_espaco_destino,
       arg_colaborador_id,
       t.transferencia_quantidade,
       arg_transferencia_data,
       arg_transferencia_documento,
       arg_transferencia_observacao
      from __transferencia t
    returning *
  ) select
      array_agg( r ) as transferencias
      into _data
    from __register r
  ;

  return true?jsonb_build_object(
    'transferencia', _data.transferencias
  );

end;
$$;


--
-- TOC entry 908 (class 1255 OID 17188)
-- Name: funct_report_caixa(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_caixa(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Relatorio sobre as caixa e posto de venda
    filter := {
      arg_data_registro: { start: DATE, end: DATE }
      arg_posto_id: ID,
      arg_colaborador_vendedor: ID,
      arg_espaco_venda: ID,
      arg_espaco_auth: ID

    }
  */

  arg_data_registro_start date default filter->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter->'arg_data_registro'->>'end';

  arg_posto_id uuid default filter->>'arg_posto_id';
  arg_espaco_venda uuid default filter->>'arg_espaco_venda';
  arg_caixa_estado uuid default filter->>'arg_caixa_estado';
  arg_colaborador_vendedor uuid default filter->>'arg_colaborador_vendedor';

  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  _const map.constant;
begin
  _const := map.constant();

  return query
    with report as (
      with caixa_amortizacao as (
        select
            am.amortizacao_caixa_id,
            count( am.amortizacao_id ) as caixa_totalcobrado,
            sum( am.amortizacao_montante ) as caixa_montantefaturado
          from tweeks.amortizacao am
          where am.amortizacao_estado = _const.amortizacao_estado_ativo
            and am.amortizacao_espaco_auth = any( arg_espaco_child )
          group by am.amortizacao_caixa_id

      ), caixa_conta as (
        select
            ct.conta_caixa_fechopagamento,
            count( ct.conta_id ) as caixa_contasaberta
          from tweeks.conta ct
          where ct.conta_estado in ( _const.conta_estado_pago, _const.conta_estado_fechado )
            and ct.conta_espaco_auth = any( arg_espaco_child )
          group by ct.conta_caixa_fechopagamento

      ), caixa_conta_fecho as (
        select ct.conta_caixa_fechopagamento,
            count( ct.conta_id ) as caixa_contafechada
          from tweeks.conta ct
          where ct.conta_estado in ( _const.conta_estado_pago, _const.conta_estado_fechado )
            and ct.conta_espaco_auth = any( arg_espaco_child )
          group by ct.conta_caixa_fechopagamento
      ) select
            cx.*,
            co.*,
            pos.*,
            esp.*,
            lib.str_nospace( to_char( cx.caixa_id, '"CX#"000-000' ) ) as caixa_codigo,

            format( '%s %s', co.colaborador_nome, co.colaborador_apelido ) as colaborador_nomecompleto,
            case when cx.caixa_estado = _const.caixa_estado_fechado then cx.caixa_dataatualizacao end as caixa_datafecho,
            cxa.caixa_totalcobrado as caixa_totalcobrado,
            coalesce( cxa.caixa_montantefaturado, 0 ) as caixa_montantefaturado,
            coalesce( cxc.caixa_contasaberta, 0 ) as caixa_contasaberta,
            coalesce( cxcf.caixa_contafechada, 0 ) as caixa_contafechada,
            case
              when cx.caixa_estado = _const.cambio_estado_ativo then 'Ativo'
              when cx.caixa_estado = _const.cambio_estado_fechado then 'Fechado'
            end as caixa_estadodesc
        from tweeks.caixa cx
          inner join auth.colaborador co on cx.caixa_colaborador_id = co.colaborador_id
          inner join tweeks.posto pos on cx.caixa_posto_id = pos.posto_id
          inner join tweeks.espaco esp on pos.posto_espaco_destino = esp.espaco_id
          left join caixa_amortizacao cxa on cx.caixa_id = cxa.amortizacao_caixa_id
          left join caixa_conta cxc on cx.caixa_id = cxc.conta_caixa_fechopagamento
          left join caixa_conta_fecho cxcf on cx.caixa_id = cxcf.conta_caixa_fechopagamento
        where cx.caixa_dataregistro::date between coalesce( arg_data_registro_start, cx.caixa_dataregistro::date ) and coalesce( arg_data_registro_end, cx.caixa_dataregistro::date )
          and cx.caixa_estado = coalesce( arg_caixa_estado, cx.caixa_estado )
          and pos.posto_id = coalesce( arg_posto_id, pos.posto_id )
          and esp.espaco_id = coalesce( arg_espaco_venda, esp.espaco_id )
          and cx.caixa_colaborador_id = coalesce( arg_colaborador_vendedor, cx.caixa_colaborador_id )
          and cx.caixa_espaco_auth = any( arg_espaco_child )
        order by cx.caixa_estado desc,
          cx.caixa_dataregistro desc
    ) select
          lib.jsonb_values( to_jsonb( r ),
            'caixa_id',
            'caixa_codigo',
            'caixa_montanteinicial',
            'caixa_montantefecho',
            'caixa_quantidadecheque',
            'caixa_observacao',
            'caixa_dataregistro',
            'posto_designacao',
            'espaco_nome',
            'posto_designacao',
            'espaco_descricao',
            'colaborador_nomecompleto',
            'caixa_datafecho',
            'caixa_totalcobrado',
            'caixa_montantefaturado',
            'caixa_contasaberta',
            'caixa_contafechada',
            'caixa_estadodesc',
            'colaborador_nome'
          )
      from report r;
end;
$$;


--
-- TOC entry 909 (class 1255 OID 17189)
-- Name: funct_report_compra_entrada(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_compra_entrada(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para processar o relatório de compras (entradas)
    arg_data_operacao :{ start: date, end :date },
    arg_data_registro :{ start: date, end :date },
    arg_espaco_id: ID,
    arg_classe_id: ID,
    arg_fornecedor_id: ID,
    arg_artigo_id: ID,
   */
  arg_data_operacao_start date default filter ->'arg_data_operacao'->>'start';
  arg_data_operacao_end date default filter ->'arg_data_operacao'->>'end';

  arg_data_registro_start date default filter ->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter ->'arg_data_registro'->>'end';

  arg_espaco_id uuid default filter ->>'arg_espaco_id';
  arg_classe_id uuid default filter ->>'arg_classe_id';
  arg_fornecedor_id uuid default filter ->>'arg_fornecedor_id';
  arg_artigo_id uuid default filter ->>'arg_artigo_id';

  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

begin
  return query
    with report as (

    select
          art.*,
          ent.*,
          fo.*,
          esp.*,
          col.*
        from tweeks.entrada ent
          inner join tweeks.artigo art on ent.entrada_artigo_id = art.artigo_id
          inner join tweeks.fornecedor fo on ent.entrada_fornecedor_id = fo.fornecedor_id
          inner join tweeks.espaco esp on ent.entrada_espaco_destino = esp.espaco_id
          inner join auth.colaborador col on ent.entrada_colaborador_id = col.colaborador_id
        where ent.entrada_data between coalesce( arg_data_operacao_start, ent.entrada_data ) and coalesce( arg_data_operacao_end, ent.entrada_data )
          and ent.entrada_dataregistro between coalesce( arg_data_registro_start, ent.entrada_dataregistro ) and coalesce( arg_data_registro_end, ent.entrada_dataregistro )
          and esp.espaco_id = coalesce( arg_espaco_id, esp.espaco_id )
          and art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
          and fo.fornecedor_id = coalesce( arg_fornecedor_id, fo.fornecedor_id )
          and art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
          and ent.entrada_espaco_auth = any( arg_espaco_child )
    )
    select
      lib.jsonb_values(
        to_jsonb( r ),
          'artigo_id',
          'artigo_codigo',
          'artigo_nome',
          'artigo_custo',
          'artigo_stock',
          'artigo_preparacao',

          'entrada_id',
          'entrada_codigofatura',
          'entrada_data',
          'entrada_quantidade',
          'entrada_montante',
          'entrada_descricao',
          'entrada_estado',
          'entrada_dataregistro',

          'colaborador_nome',
          'colaborador_apelido',

          'fornecedor_id',
          'fornecedor_nif',
          'fornecedor_nome',

          'espaco_nome'
        )
      from report r
  ;
end;
$$;


--
-- TOC entry 910 (class 1255 OID 17190)
-- Name: funct_report_estatistica_posto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_estatistica_posto(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função devolve os relatorio do posto todos
    -- columns
      Data,
      Posta,
      Espaço,
      Caixa,
      Montante, -- Montante geradao
      Pagos,    -- Montante pago
      Contas    -- Total de contas abertas


    filter := {
      arg_data_registro: { start: DATE, end: DATE }
      arg_posto_id: ID,
      arg_colaborador_vendedor: ID,
      arg_espaco_venda: ID,
      arg_periodo_required:  { "key": "dd-mm-yyyy", "label": "dd", "title": "dia dd 'de' Mon 'de' YYYY", "interval": INTERVAL }



    }
  */

  arg_data_registro_start date default filter->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter->'arg_data_registro'->>'end';

  arg_periodo_required_key character varying := filter->'arg_periodo_required'->>'key';
  arg_periodo_required_label character varying := filter->'arg_periodo_required'->>'label';
  arg_periodo_required_title character varying := filter->'arg_periodo_required'->>'title';
  arg_periodo_required_interval interval not null := filter->'arg_periodo_required'->>'interval';


  arg_posto_id uuid default filter->>'arg_posto_id';
  arg_espaco_venda uuid default filter->>'arg_espaco_venda';
  arg_colaborador_vendedor uuid default filter->>'arg_colaborador_vendedor';

  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  _data record;
  _const map.constant;

begin

  select min( cx.caixa_dataregistro::date ) as absolut_start, max( cx.caixa_dataregistro::date) as max_date    into _data
    from tweeks.caixa cx
  ;

  if arg_data_registro_start is not null and arg_data_registro_start > _data.absolut_start then
    _data.absolut_start := arg_data_registro_start;
  end if;

  if _data.absolut_start > current_date then
    _data.absolut_start := current_date;
  end if;

  _data.max_date := current_date;
  if arg_data_registro_end is not null and arg_data_registro_end < current_date and arg_data_registro_end >= _data.absolut_start then
    _data.max_date := arg_data_registro_end;
  end if;


  _const := map.constant();
  return query
      with recursive dates( data ) as (
          values ( _data.absolut_start )
        union all
          select d.data + arg_periodo_required_interval
            from dates d
            where d.data + arg_periodo_required_interval <= _data.max_date
      )
      select lib.jsonb_values( to_jsonb( pos ) || to_jsonb( cx )|| to_jsonb( co ) || to_jsonb( pos ),
        'caixa_id',
        'caixa_montanteinicial',
        'caixa_montantefecho',
        'caixa_quantidadecheque',
        'caixa_observacao',
        'caixa_dataregistro',
        'posto_designacao',
        'espaco_nome',
        'posto_designacao',
        'espaco_descricao',
        'colaborador_nome'
      ) || jsonb_build_object(
        'colaborador_nomecompleto', format( '%s %s', co.colaborador_nome, co.colaborador_apelido ),
        'caixa_datafecho', case when cx.caixa_estado = _const.caixa_estado_fechado then cx.caixa_dataatualizacao end,
        'caixa_totalcobrado', cxa.caixa_totalcobrado,
        'caixa_montantepagamento', coalesce( cxa.caixa_montantepagamento, 0 ),
        'caixa_contasaberta', coalesce( cxc.caixa_contasaberta, 0 ),
        'caixa_contafechada', coalesce( cxcf.caixa_contafechada, 0 ),
        'caixa_estado', case
            when cx.caixa_estado = _const.cambio_estado_ativo then 'Ativo'
            when cx.caixa_estado = _const.cambio_estado_fechado then 'Fechado'
          end
      )
      from dates dt
        inner join tweeks.posto post on true
          and post.posto_espaco_destino = any( arg_espaco_child )
        left join tweeks.caixa cx on post.posto_id = cx.caixa_posto_id
          and cx.caixa_espaco_auth = any( arg_espaco_child )
        left join tweeks.amortizacao amort on cx.caixa_id = amort.amortizacao_caixa_id
          and amort.amortizacao_espaco_auth = any( arg_espaco_child )
        left join tweeks.conta ct on cx.caixa_id = ct.conta_caixa_id
          and ct.conta_espaco_auth = any( arg_espaco_child )
        left join tweeks.conta ctclose on cx.caixa_id = ct.conta_caixa_fechopagamento
          and ct.conta_espaco_auth = any( arg_espaco_child )
    ;
end;
$$;


--
-- TOC entry 890 (class 1255 OID 17191)
-- Name: funct_report_estatistica_venda(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_estatistica_venda(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Esse relatório gera a estatistica de venda
    filter := {
      arg_periodo_required: { "key": KEY, "label": NAME, "title": TITLE },
      arg_estatistica_tipo: { "key": KEY, "title": TITLE, "class": CLASSE }
      arg_data_operacao: { start: DATE, end: DATE },
      arg_data_registro: { start: DATE, end: DATE },
      arg_artigo_id: ID,
      arg_classe_id: ID,
      arg_show_empty: 1 | 0
      arg_periodos: PERIODO
   */

  arg_periodo_requiere_key character varying not null default filter ->'arg_periodo_required'->>'key';
  arg_periodo_requiere_label character varying not null default filter ->'arg_periodo_required'->>'label';
  arg_periodo_requiere_title character varying not null default filter ->'arg_periodo_required'->>'title';
  arg_periodo_requiere_interval interval not null default filter ->'arg_periodo_required'->>'interval';
  arg_periodo_requiere_increment interval not null default filter ->'arg_periodo_required'->>'increment';
  arg_periodo_requiere_length text not null default filter ->'arg_periodo_required'->>'length';
  arg_periodo_requiere_loop integer not null default filter ->'arg_periodo_required'->>'loop';
  arg_periodo_requiere_type text not null default filter ->'arg_periodo_required'->>'type';

  arg_estatistica_tipo_key character varying not null default filter ->'arg_estatistica_tipo'->>'key';
  arg_estatistica_tipo_title character varying not null default filter ->'arg_estatistica_tipo'->>'title';
  arg_estatistica_tipo_class character varying not null default filter ->'arg_estatistica_tipo'->>'class';

  arg_data_registro_start date default filter ->'arg_data_registro'->>'start';
  arg_data_registro_end date default   filter ->'arg_data_registro'->>'end';

  arg_artigo_id uuid default filter->>'arg_artigo_id';
  arg_posto_id uuid default filter->>'arg_posto_id';
  arg_classe_id uuid default filter->>'arg_classe_id';
  arg_periodos int2 default filter->>'arg_periodos';
  arg_show_empty boolean default filter->>'arg_show_empty';

  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  _const map.constant;
begin
  _const := map.constant();

  -- Garantir que a data não ultrapassa o limite de tempo para o periodo
  -- Pirodo Diario 30 dias = 1 mes

  if  arg_estatistica_tipo_class = 'Money' then
    arg_periodo_requiere_loop := 8;
  end if;

  -- Periodo Mensal 365 dias = 12 meses = 1 ano
  if arg_data_registro_end::timestamptz - arg_data_registro_start::timestamptz >= arg_periodo_requiere_interval then
    return;
  end if;


  arg_show_empty := coalesce( arg_show_empty, true );
  arg_periodos := coalesce( arg_periodos, arg_periodo_requiere_loop );

  -- Determinar a data limite inferior
  if arg_data_registro_start is null and arg_data_registro_end is null then
    arg_data_registro_start := current_date - ( arg_periodo_requiere_increment * arg_periodos );
  elseif  arg_data_registro_start is null then
    arg_data_registro_start := arg_data_registro_end - ( arg_periodo_requiere_increment * ( arg_periodos ) );
  end if;

  -- Determinar a data limit superior
  if arg_data_registro_end is null then
    arg_data_registro_end := arg_data_registro_start + ( arg_periodo_requiere_increment * ( arg_periodos ) );
  end if;

  --   raise exception 'start: %, end: %', arg_data_registro_start, arg_data_registro_end;



  return query
    with recursive periode ( date, loop ) as (
      values ( arg_data_registro_start, 1 )
      union all
      select ( p.date + arg_periodo_requiere_increment )::date, p.loop +1
      from periode p
      where p.date < arg_data_registro_end
    ), reporte as (
      select
        to_char( p2.date, arg_periodo_requiere_key ) as key,
        to_char( p2.date, arg_periodo_requiere_label ) as label,
        to_char( p2.date, arg_periodo_requiere_title ) as period_title,
        art.*,
        coalesce( count( distinct ct.conta_id ), 0 ) as conta_quantidade,
        coalesce( count( distinct ve.venda_id ), 0 ) as venda_totalvenda,
        coalesce( sum( ve.venda_quantidade ), 0 ) as venda_quantidade,
        coalesce( sum( ve.venda_montantetotal ), 0 ) as venda_montante
      from periode p2
        left join tweeks.conta ct on to_char( p2.date, arg_periodo_requiere_key ) = to_char( ct.conta_dataregistro, arg_periodo_requiere_key )
          and ct.conta_estado =  _const.conta_estado_pago
          and ct.conta_espaco_auth = any( arg_espaco_child )
        left join tweeks.venda ve on ct.conta_id = ve.venda_conta_id
          and ve.venda_estado =  _const.venda_estado_fechado
          and ve.venda_espaco_auth = any( arg_espaco_child )
        left join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id
          and art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
          and art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
        left join tweeks.caixa cx on ct.conta_caixa_fechopagamento = cx.caixa_id
          and cx.caixa_posto_id = coalesce( arg_posto_id, cx.caixa_posto_id )
          and cx.caixa_espaco_auth = any( arg_espaco_child )
      group by art.artigo_id,
        p2.date
      having arg_show_empty or count( ve.venda_id ) > 0
    )
      select
        jsonb_build_object(
        'header', array(
          select
            jsonb_build_object(
              'key', p.key,
              'label', p.label,
              'class', arg_estatistica_tipo_class,
              'length', arg_periodo_requiere_length,
              'title', format( '%s em %s', arg_estatistica_tipo_title, p.period_title ),
              'sumRow', true
            )
            from reporte p
            group by p.key, p.label, p.period_title
            order by p.key asc
        ) || array [
          jsonb_build_object( 'key', 'sum', 'label', 'SUN', 'class', arg_estatistica_tipo_class, 'title', 'Somatorio', 'sumRow', true, 'length', 'normal' )
        ]
      )
    union all
      select jsonb_build_object(
          'artigo_id', p.artigo_id,
          'artigo_nome', p.artigo_nome,
          'artigo_codigo', p.artigo_codigo,
          'artigo_montantetotalvendido', sum( p.venda_montante ),
          'artigo_quantidadetotalvendida', sum( p.venda_quantidade ),
          'sum', sum( ( to_jsonb( p ) ->> ( arg_estatistica_tipo_key ) ) ::double precision ),
          'avg', avg( ( to_jsonb( p ) ->> ( arg_estatistica_tipo_key ) ) ::double precision )
        ) || jsonb_object_agg( p.key, to_jsonb( p ) ->> ( arg_estatistica_tipo_key ) )
        from reporte p
        where p.artigo_id is not null
        group by
          p.artigo_id,
          p.artigo_codigo,
          p.artigo_nome
  ;
end;
$$;


--
-- TOC entry 911 (class 1255 OID 17193)
-- Name: funct_report_stock_movimentos(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_stock_movimentos(filter jsonb DEFAULT NULL::jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Esse relatorio apresenta as movimentações em stock
    filters := {
      arg_data_operacao: {start: date, end: date }
      arg_data_registro: {start: date, end: date }
      arg_tmovimento_id: ID,
      arg_toperacao_stock: ID
      arg_artigo_id: ID
    }
  */

  arg_data_registro_start date default filter->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter->'arg_data_registro'->>'end';
  arg_data_operacao_start date default filter->'arg_data_registro'->>'start';
  arg_data_operacao_end date default filter->'arg_data_registro'->>'end';

  arg_tmovimento_id int2 default filter->>'arg_tmovimento_id';
  arg_toperacao_stock int2 default filter->>'arg_toperacao_stock';
  arg_artigo_id uuid default filter->>'arg_artigo_id';
  arg_classe_id uuid default filter->>'arg_classe_id';

  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  arg_columns text[] default array[
      'movimento_id',
      'movimento_data',
      'movimento_documento',
      'movimento_quantidade',
      'movimento_quantidadeinicia',
      'movimento_quantidadefinal',
      'movimento_dataregistro',
      'artigo_nome',
      'artigo_codigo',
      'espaco_nome',
      'colaborador_nome',
      'stock_quantidade',
      'artigo_stock',
      'tmovimento_designacao',
      'toperacao_designacao'
    ];

  _const map.constant;
begin
  _const := map.constant();
  return query
    with report as (
      select
        mv.*,
        tm.*,
        a.*,
        e.*,
        col.*,
        top.*,
        format( '%s %s', col.colaborador_nome, col.colaborador_apelido ) as colaborador_nomecompleto
      from tweeks.movimento mv
        inner join tweeks.stock s on mv.movimento_stock_id = s.stock_id
        inner join tweeks.artigo a on s.stock_artigo_id = a.artigo_id
        inner join tweeks.espaco e on s.stock_espacao_id = e.espaco_id
        inner join auth.colaborador col on mv.movimento_colaborador_id = col.colaborador_id
        inner join tweeks.toperacao top on mv.movimento_toperacao_id = top.toperacao_id
        inner join tweeks.tmovimento tm on mv.movimento_tmovimento_id = tm.tmovimento_id
      where mv.movimento_estado != _const.movimento_estado_canselado
        and tm.tmovimento_id = coalesce( arg_tmovimento_id, tm.tmovimento_id )
        and mv.movimento_toperacao_id = coalesce( arg_toperacao_stock, mv.movimento_toperacao_id )
        and mv.movimento_data between coalesce( arg_data_operacao_start, mv.movimento_data ) and coalesce( arg_data_operacao_end, mv.movimento_data )
        and mv.movimento_dataregistro::date between coalesce( arg_data_registro_start, mv.movimento_dataregistro::date ) and coalesce( arg_data_registro_end, mv.movimento_dataregistro::date )
        and a.artigo_id = coalesce( arg_artigo_id, a.artigo_id )
        and a.artigo_classe_id = coalesce( arg_classe_id, a.artigo_classe_id )
        and mv.movimento_espaco_auth = any( arg_espaco_child )
      order by mv.movimento_dataregistro desc
    )
    select lib.jsonb_values( rp , variadic arg_columns )
    from report rp
  ;
end;
$$;


--
-- TOC entry 913 (class 1255 OID 17194)
-- Name: funct_report_transacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_transacao(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Essa função serve para devolver dados para relatório de transação
    filter := {
      arg_data_registro: { start: DATE, end: DATE },
      arg_posto_id: ID,
      arg_tmovimento_id: ID,
      arg_toperacao_montante: ID,
      arg_colaborador_id: ID,
      arg_transacao_zerar: ID,
    }
   */
  _const map.constant;
  arg_data_registro_start date default filter->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter->'arg_data_registro'->>'end';

  arg_posto_id uuid default filter->>'arg_posto_id';
  arg_colaborador_id uuid default filter->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  arg_tmovimento_id int2 default filter->>'arg_tmovimento_id';
  arg_toperacao_montante int2 default filter->>'arg_toperacao_montante';
  arg_transacao_zerar boolean default filter->>'arg_transacao_zerar';
  arg_documento character varying default filter->>'arg_documento';


begin

  _const := map.constant();

  return query
    with report as (
      select *,
        case
          when trans.transacao_zerar then 'Zerado'
          else 'Lançado'
          end as transacao_zerardesignacao,
        lib.str_normalize( format( '%s %s', col.colaborador_nome, col.colaborador_apelido ) ) as colaborador_nomecompleto,
        case when t.tmovimento_id = _const.tmovimento_credito then trans.transacao_montante end as transacao_montantecredito,
        case when t.tmovimento_id = _const.tmovimento_debito then trans.transacao_montante end as transacao_montantedebito
      from tweeks.transacao trans
             inner join tweeks.posto pos on trans.transacao_posto_id = pos.posto_id
             inner join tweeks.tmovimento t on trans.transacao_tmovimento_id = t.tmovimento_id
             inner join tweeks.toperacao top on trans.transacao_toperacao_id = top.toperacao_id
             inner join auth.colaborador col on trans.transacao_colaborador_id = col.colaborador_id
      where trans.transacao_dataregistro::date between coalesce( arg_data_registro_start,  trans.transacao_dataregistro::date ) and coalesce( arg_data_registro_end,  trans.transacao_dataregistro::date )
        and pos.posto_id = coalesce( arg_posto_id, pos.posto_id )
        and t.tmovimento_id = coalesce( arg_tmovimento_id, t.tmovimento_id )
        and top.toperacao_id = coalesce( arg_toperacao_montante, top.toperacao_id )
        and trans.transacao_zerar = coalesce( arg_transacao_zerar, trans.transacao_zerar )
        and col.colaborador_id = coalesce( arg_colaborador_id, col.colaborador_id )
        and lower( public.unaccent( trans.transacao_documento ) ) like '%'||lower( public.unaccent( coalesce( arg_documento, trans.transacao_documento) ) )||'%'
        and trans.transacao_espaco_auth = any( arg_espaco_child )
      order by trans.transacao_dataregistro asc
    ) select
      lib.jsonb_values( to_jsonb( r ) ,
        'transacao_documento',
        'transacao_zerardesignacao',
        'transacao_montante',
        'transacao_montantecredito',
        'transacao_montantedebito',
        'transacao_montanteinicial',
        'transacao_montantefinal',
        'transacao_observacao',
        'transacao_dataregistro',
        'posto_designacao',
        'tmovimento_designacao',
        'toperacao_designacao',
        'colaborador_nome',
        'colaborador_apelido',
        'colaborador_nomecompleto'
      ) from report r;
end;
$$;


--
-- TOC entry 914 (class 1255 OID 17195)
-- Name: funct_report_venda(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_venda(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
    /** Relatorio de vendas
      filter := {
        arg_data_operacao:{ start: DATE, end: DATE },
        arg_data_registro:{ start: DATE, end: DATE },
        arg_artigo_id: ID
        arg_posto_id: ID,
        arg_colaborador_vendedor: ID,
        arg_currency_pagamento: ID,
        arg_colaborador_vendedor: ID,
        arg_tpaga_id: ID,
        arg_classe_id: ID,
        arg _conta_fatura: FATURA,
      }
     */

    arg_data_operacao_start date default filter->'arg_data_operacao'->>'start';
    arg_data_operacao_end date default filter->'arg_data_operacao'->>'end';

    arg_data_registro_start date default filter->'arg_data_registro'->>'start';
    arg_data_registro_end date default filter->'arg_data_registro'->>'end';

    arg_artigo_id uuid default filter->>'arg_artigo_id';
    arg_posto_id uuid default filter->>'arg_posto_id';
    arg_colaborador_vendedor uuid default filter->>'arg_colaborador_vendedor';
    arg_classe_id uuid default filter->>'arg_classe_id';

    arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
    arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

    arg_currency_pagamento int2 default filter->>'arg_currency_pagamento';
    arg_tpaga_id int2 default filter->>'arg_tpaga_id';
    arg_conta_montante_start double precision default filter->'arg_conta_montante'->>'start';
    arg_conta_montante_end double precision default filter->'arg_conta_montante'->>'end';
    arg_conta_fatura character varying default filter->>'arg_conta_fatura';

    _const map.constant;

begin
    _const := map.constant();

    return query
        with report as (
            select ve.*,
                   art.*,
                   ct.*,
                   col.*,
                   trim( format( '%s %s', col.colaborador_nome, col.colaborador_apelido ) ) as colaborador_nomecompleto,
                   string_agg( it.artigo_nome, ', ' ) as venda_itens
            from tweeks.venda ve
                     inner join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id
                     inner join tweeks.conta ct on ve.venda_conta_id = ct.conta_id
                     inner join tweeks.caixa cx on ct.conta_caixa_fechopagamento = cx.caixa_id
                     inner join auth.colaborador col on coalesce ( ct.conta_colaborador_atualizacao, ct.conta_colaborador_id ) = col.colaborador_id
                     left join tweeks.agrega agg on ve.venda_id = agg.agrega_venda_id
                      and agg.agrega_estado = _const.agrega_estado_fechado
                    left join tweeks.artigo it on agg.agrega_artigo_item = it.artigo_id

            where ct.conta_estado = _const.conta_estado_pago
              and ve.venda_estado = _const.venda_estado_fechado
              and ct.conta_data between coalesce( arg_data_operacao_start, ct.conta_data ) and coalesce( arg_data_operacao_end, ct.conta_data )
              and ct.conta_dataregistro::date between coalesce( arg_data_registro_start, ct.conta_dataregistro::date ) and coalesce( arg_data_registro_end, ct.conta_dataregistro::date )
              and cx.caixa_posto_id = coalesce( arg_posto_id, cx.caixa_posto_id )
              and coalesce( ct.conta_colaborador_atualizacao, ct.conta_colaborador_id ) = coalesce( arg_colaborador_vendedor, ct.conta_colaborador_atualizacao, ct.conta_colaborador_id )
              and ct.conta_currency_id = coalesce( arg_currency_pagamento, ct.conta_currency_id )
              and ct.conta_tpaga_id = coalesce( arg_tpaga_id, ct.conta_tpaga_id )
              and ct.conta_montante between  coalesce( arg_conta_montante_start, ct.conta_montante ) and coalesce( arg_conta_montante_end, ct.conta_montante )
              and art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
              and art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
              and lower( ct.conta_numerofatura ) like '%' ||lower( coalesce( arg_conta_fatura, ct.conta_numerofatura ) ) ||'%'
              and ct.conta_espaco_auth = any( arg_espaco_child )
            group by
                art.artigo_id,
                ct.conta_id,
                ve.venda_id,
                col.colaborador_id
        ) select lib.jsonb_values( r,
            'venda_id',
            'venda_quantidade',
            'venda_montente',
            'venda_montanteagregado',
            'venda_montantetotal',
            'venda_custounitario',
            'venda_imposto',
            'venda_montantecomimposto',

            'artigo_nome',
            'artigo_codigo',

            'conta_numerofatura',
            'conta_titular',
            'conta_montante',
            'conta_data',

            'conta_dataregistro',
            'colaborador_nome',
            'colaborador_nomecompleto',
            'venda_itens'
         )
        from report r
    ;
end;
$$;


--
-- TOC entry 915 (class 1255 OID 17196)
-- Name: funct_report_venda_artigo(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_venda_artigo(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Relatorio de vendas
    filter := {
      arg_data_operacao:{ start: DATE, end: DATE },
      arg_data_registro:{ start: DATE, end: DATE },
      arg_artigo_id: ID
      arg_posto_id: ID,
      arg_colaborador_vendedor: ID,
      arg_currency_pagamento: ID,
      arg_colaborador_vendedor: ID,
      arg_tpaga_id: ID,
      arg_classe_id: ID,
      arg _conta_fatura: FATURA,
    }
   */

  arg_data_operacao_start date default filter->'arg_data_operacao'->>'start';
  arg_data_operacao_end date default filter->'arg_data_operacao'->>'end';

  arg_data_registro_start date default filter->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter->'arg_data_registro'->>'end';

  arg_artigo_id uuid default filter->>'arg_artigo_id';
  arg_posto_id uuid default filter->>'arg_posto_id';
  arg_colaborador_vendedor uuid default filter->>'arg_colaborador_vendedor';
  arg_classe_id uuid default filter->>'arg_classe_id';
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  arg_currency_pagamento int2 default filter->>'arg_currency_pagamento';
  arg_tpaga_id int2 default filter->>'arg_tpaga_id';
  arg_conta_montante_start double precision default filter->'arg_conta_montante'->>'start';
  arg_conta_montante_end double precision default filter->'arg_conta_montante'->>'end';
  arg_conta_fatura character varying default filter->>'arg_conta_fatura';


  _const map.constant;

begin
  _const := map.constant();

  return query
    with __vendas ( venda_id, venda_conta_id, venda_artigo_id, venda_quantidade, venda_custounitario, venda_montente, venda_dataregistro, venda_modalidade, venda_tmodalidade, venda_gmodalidade  ) as (
      select v.venda_id, v.venda_conta_id, v.venda_artigo_id, v.venda_quantidade, v.venda_custounitario, v.venda_montente, v.venda_dataregistro, 'Venda directa'::text, 1, 1
        from tweeks.venda v
        where v.venda_estado = _const.venda_estado_fechado
    union all
      select ag.agrega_id, ve.venda_conta_id, ag.agrega_artigo_item, ag.agrega_quantidade, ag.agrega_custounitario, ag.agrega_montante, ag.agrega_dataregistro, 'Item Extras'::text, case when ag.agrega_montante > 0 then 2 else  3 end, 2
        from tweeks.agrega ag
          inner join tweeks.venda ve on ag.agrega_venda_id = ve.venda_id
        where ag.agrega_estado = _const.agrega_estado_fechado
          and ve.venda_estado = _const.venda_estado_fechado
    ), report as (
      select art.*,
         _v.venda_custounitario as venda_custounitario,
         sum( _v.venda_quantidade ) as venda_quantidade,
         sum( _v.venda_montente ) as venda_montente,
        _v.venda_modalidade as  venda_modalidade
      from tweeks.artigo art
        inner join __vendas _v on art.artigo_id = _v.venda_artigo_id
        inner join tweeks.conta ct on _v.venda_conta_id = ct.conta_id
        inner join tweeks.caixa cx on ct.conta_caixa_fechopagamento = cx.caixa_id

      where ct.conta_estado = _const.conta_estado_pago
        and ct.conta_data between coalesce( arg_data_operacao_start, ct.conta_data ) and coalesce( arg_data_operacao_end, ct.conta_data )
        and ct.conta_dataregistro::date between coalesce( arg_data_registro_start, ct.conta_dataregistro::date ) and coalesce( arg_data_registro_end, ct.conta_dataregistro::date )
        and cx.caixa_posto_id = coalesce( arg_posto_id, cx.caixa_posto_id )
        and coalesce( ct.conta_colaborador_atualizacao, ct.conta_colaborador_id ) = coalesce( arg_colaborador_vendedor, ct.conta_colaborador_atualizacao, ct.conta_colaborador_id )
        and ct.conta_currency_id = coalesce( arg_currency_pagamento, ct.conta_currency_id )
        and ct.conta_tpaga_id = coalesce( arg_tpaga_id, ct.conta_tpaga_id )
        and ct.conta_montante between  coalesce( arg_conta_montante_start, ct.conta_montante ) and coalesce( arg_conta_montante_end, ct.conta_montante )
        and art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
        and art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
        and lower( ct.conta_numerofatura ) like '%' ||lower( coalesce( arg_conta_fatura, ct.conta_numerofatura ) ) ||'%'
        and ct.conta_espaco_auth = any( arg_espaco_child )
      group by
        art.artigo_id,
        _v.venda_custounitario,
        _v.venda_modalidade,
        _v.venda_tmodalidade,
        _v.venda_gmodalidade
      order by art.artigo_nome asc,
         _v.venda_modalidade
    ) select lib.jsonb_values( r,
        'artigo_codigo',
        'artigo_nome',
        'venda_quantidade',
        'venda_custounitario',
        'venda_montente',
        'venda_modalidade',
        'venda_tmodalidade',
        'venda_gmodalidade'
      )
    from report r
  ;
end;
$$;


--
-- TOC entry 916 (class 1255 OID 17197)
-- Name: funct_report_venda_conta(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_report_venda_conta(filter jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  /** Relatorio de vendas
    filter := {
      arg_data_operacao:{ start: DATE, end: DATE },
      arg_data_registro:{ start: DATE, end: DATE },
      arg_artigo_id: ID
      arg_posto_id: ID,
      arg_colaborador_vendedor: ID,
      arg_currency_pagamento: ID,
      arg_colaborador_vendedor: ID,
      arg_tpaga_id: ID,
      arg_classe_id: ID,
      arg_conta_montante: {start: START, end: END },
      arg_conta_fatura: FATURA
    }
   */

  arg_data_operacao_start date default filter->'arg_data_operacao'->>'start';
  arg_data_operacao_end date default filter->'arg_data_operacao'->>'end';

  arg_data_registro_start date default filter->'arg_data_registro'->>'start';
  arg_data_registro_end date default filter->'arg_data_registro'->>'end';

  arg_artigo_id uuid default filter->>'arg_artigo_id';
  arg_posto_id uuid default filter->>'arg_posto_id';
  arg_colaborador_vendedor uuid default filter->>'arg_colaborador_vendedor';
  arg_classe_id uuid default filter->>'arg_classe_id';
  arg_espaco_auth uuid not null default filter->>'arg_espaco_auth';
  arg_espaco_child uuid[] not null default rule.espaco_get_childrens( arg_espaco_auth );

  arg_currency_pagamento int2 default filter->>'arg_currency_pagamento';
  arg_tpaga_id int2 default filter->>'arg_tpaga_id';

  arg_conta_montante_start double precision default filter->'arg_conta_montante'->>'start';
  arg_conta_montante_end double precision default filter->'arg_conta_montante'->>'end';
  arg_conta_fatura character varying default filter->>'arg_conta_fatura';


  _const map.constant;

begin
  _const := map.constant();

  return query
    with report as (
      select
        ct.*,
        cx.*,
        pos.*,
        col.*,
        cu.*,
        tp.*,
        trim( format( '%s %s', col.colaborador_nome, col.colaborador_apelido ) ) as colaborador_nomecompleto,
        sum( ve.venda_montanteagregado ) as venda_montanteagregado,
        sum( ve.venda_montente ) as venda_montente,
        sum( ve.venda_montantetotal ) as venda_montantetotal,
        string_agg( distinct art.artigo_nome, ', ' ) as venta_artigos

      from tweeks.conta ct
        inner join tweeks.caixa cx on ct.conta_caixa_fechopagamento = cx.caixa_id
        inner join tweeks.posto pos on cx.caixa_posto_id = pos.posto_id
        inner join auth.colaborador col on ct.conta_colaborador_id = col.colaborador_id
        left join tweeks.tpaga tp on ct.conta_tpaga_id = tp.tpaga_id
        left join geoinfo.currency cu on ct.conta_currency_id = cu.currency_id
        left join tweeks.venda ve on ct.conta_id = ve.venda_conta_id
          and ve.venda_estado in ( _const.venda_estado_fechado )
        left join tweeks.artigo art on ve.venda_artigo_id = art.artigo_id

      where ct.conta_estado in ( _const.conta_estado_pago, _const.conta_estado_fechado )
        and art.artigo_id = coalesce( arg_artigo_id, art.artigo_id )
        and art.artigo_classe_id = coalesce( arg_classe_id, art.artigo_classe_id )
        and ct.conta_data between coalesce( arg_data_operacao_start, ct.conta_data ) and coalesce( arg_data_operacao_end, ct.conta_data )
        and ct.conta_dataregistro::date between coalesce( arg_data_registro_start, ct.conta_dataregistro::date ) and coalesce( arg_data_registro_end, ct.conta_dataregistro::date )
        and cx.caixa_posto_id = coalesce( arg_posto_id, cx.caixa_posto_id )
        and cx.caixa_colaborador_id = coalesce( arg_colaborador_vendedor, cx.caixa_colaborador_id )
        and ct.conta_currency_id = coalesce( arg_currency_pagamento, ct.conta_currency_id )
        and ct.conta_tpaga_id = coalesce( arg_tpaga_id, ct.conta_tpaga_id )
        and ve.venda_montente between coalesce( arg_conta_montante_start, ve.venda_montente ) and coalesce( arg_conta_montante_end, ve.venda_montente )
        and lower( ct.conta_numerofatura ) like '%' || lower( coalesce( arg_conta_fatura, ct.conta_numerofatura ) ) || '%'
        and ct.conta_espaco_auth = any( arg_espaco_child )
      group by
        ct.conta_id,
        cx.caixa_id,
        pos.posto_id,
        col.colaborador_id,
        cu.currency_id,
        tp.tpaga_id
    )
    select jsonb_build_object(
               'header', array(
            select jsonb_build_object(
                       'key', r.currency_code,
                       'label', r.currency_code,
                       'class', 'Money',
                       'key', r.currency_code,
                       'sumRow', true
                     )
            from report r
            group by r.currency_code,
                     r.currency_name
          )
             )
    union all
    select
        lib.jsonb_values(
            to_jsonb( rp ),
            'conta_id',
            'conta_numerofatura',
            'conta_titular',
            'conta_data',
            'conta_montante',
            'conta_montanteamortizado',
            'conta_montantetroco',
            'conta_imprensa',
            'conta_dataregistro',
            'posto_id',
            'posto_designacao',
            'colaborador_nome',
            'caixa_id',
            'currency_code',
            'currency_code',
            'tpaga_designacao',
            'colaborador_nomecompleto',
            'venda_montanteagregado',
            'venda_montente',
            'venda_montantetotal',
            'venta_artigos'
          ) || jsonb_build_object (
            rp.currency_code, rp.conta_montantemoeda
          )
    from report rp
  ;
end;
$$;


--
-- TOC entry 898 (class 1255 OID 17198)
-- Name: funct_sets_autorizacao(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_autorizacao(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    {
      arg_colaborador_id: UID
      arg_espaco_auth: UID
      arg_autorizacao_continue: AUTORIZACAO

      autorizacao_uid: UID
      autorizacao_espaco_uid: UID
      autorizacao_designacao:DESIG
      autorizacao_numero:NUMERO,
      series: [
        {
          serie_id uuid not null,
          serie_tserie_id int2 not null,
          serie_espaco_id uuid not null,
          serie_designacao character varying not null,
          serie_numero character varying not null,
          serie_quantidade int not null,
          serie_numcertificacao,
          serie_numatorizacao
        }
      ]
    }
   */
  _autorizacao tweeks.autorizacao;
  _autorizacao_continue tweeks.autorizacao;
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _res_serie jsonb default jsonb_build_array();
  _next record;
  _data record;

begin
  _autorizacao := jsonb_populate_record( _autorizacao, args );
  _autorizacao_continue := jsonb_populate_record( _autorizacao_continue, args->'_autorizacao_continue' );
  
  if _autorizacao.autorizacao_uid is null then
    _autorizacao.autorizacao_colaborador_uid := arg_colaborador_id;
    _autorizacao.autorizacao_espaco_auth := arg_espaco_auth;
    _autorizacao._branch_uid := arg_branch_uid;
    _autorizacao.autorizacao_dataregistro := now();
    _autorizacao.autorizacao_ano := extract( years from now() );
  else
    _autorizacao.autorizacao_colaborador_atualizacao := arg_colaborador_id;
    _autorizacao.autorizacao_dataatualizacao := now();
  end if;
  
  if _autorizacao_continue.autorizacao_uid is null and exists(
    select *
      from jsonb_array_elements( args->'series' ) e ( doc )
        inner join jsonb_populate_record( null::tweeks.serie, e.doc ) sdoc on true
        inner join tweeks.serie s on sdoc.serie_numero = s.serie_numero
          and s.serie_tserie_id = sdoc.serie_tserie_id
          and s._branch_uid = arg_branch_uid
          and s.serie_espaco_auth = arg_espaco_auth
        inner join tweeks.autorizacao a on s.serie_autorizacao_uid = a.autorizacao_uid
          and a._branch_uid = arg_branch_uid
          and a.autorizacao_ano = _autorizacao.autorizacao_ano
          and a.autorizacao_espaco_auth = arg_espaco_auth
      where a.autorizacao_uid != _autorizacao_continue.autorizacao_uid
  ) then
    return lib.res_false( 'Já existe serie com essa numeração registrada' );
  end if;
  
  select ( "returning" ).* into _autorizacao
    from lib.sets( _autorizacao )
  ;
  
  for _data in (
    select
        e.document || jsonb_build_object(
          'arg_colaborador_id', arg_colaborador_id,
          'arg_espaco_auth', arg_espaco_auth,
          'serie_autorizacao_uid', _autorizacao.autorizacao_uid
        ) as document_serie
      from jsonb_array_elements( args->'series' ) e ( document )
  ) loop
    select * into _next
      from tweeks.funct_sets_serie( _data.document_serie ) e;
  
    _res_serie := _res_serie || jsonb_build_object(
      'serie', _data.document_serie,
      'result', _next
    );
  end loop;
  
  return lib.res_true( jsonb_build_object(
    'autorizacao', _autorizacao,
    'series', _res_serie
  ));
end;
$$;


--
-- TOC entry 918 (class 1255 OID 17199)
-- Name: funct_sets_autorizacao_continue(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_autorizacao_continue(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    {
      arg_colaborador_id: UID
      arg_espaco_auth: UID
      autorizacao_uid: UID
    }
   */
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_branch_uid uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );

  _autorizacao tweeks.autorizacao;
  _const map.constant;
  _data record;
begin
  _autorizacao := tweeks.__get_autorizacao( ( args->>'autorizacao_uid' )::uuid );
  _const := map.constant();
  with __serie as (
    select
        serie_tserie_id,
        serie_espaco_id,
        serie_designacao,
        serie_numero,
        serie_quantidade,
        serie_numcertificacao,
        serie_numatorizacao,
        case 
          when _autorizacao.autorizacao_ano = extract( years from current_date)::int then serie_sequencia
          else 0
        end serie_sequencia
      from tweeks.serie se
      where se.serie_autorizacao_uid = _autorizacao.autorizacao_uid
        and se.serie_estado = _const.maguita_serie_estado_fechado
        and se.serie_fechoautorizacao
        and se._branch_uid = arg_branch_uid
  ) select
        jsonb_agg( to_jsonb( _s ) ) as series
        into _data
      from __serie _s;

  return tweeks.funct_sets_autorizacao( jsonb_build_object(
    'arg_colaborador_id', arg_colaborador_id,
    'arg_espaco_auth', arg_espaco_auth,
    '_autorizacao_continue', _autorizacao,
    'autorizacao_uid', null,
    'autorizacao_espaco_uid', _autorizacao.autorizacao_espaco_uid,
    'autorizacao_designacao', _autorizacao.autorizacao_designacao,
    'autorizacao_numero', _autorizacao.autorizacao_numero,
    'series', _data.series
  ));
end;
$$;


--
-- TOC entry 919 (class 1255 OID 17200)
-- Name: funct_sets_branch(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_branch(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args: {
       branch_uid?
       arg_colaborador_id : UID,
       arg_espaco_id : UID
       branch_tbranch_id
       branch_name
       branch_path
       branch_user := { ESTRUTURA DE CRIAÇÃO DO COLABORADOR | ESTRUTURA DE ATUALIZACAO DE COLABORADOR  }
       branch_workspace := { ESTRUTURA DE CRIAÇÃO DO ESPACO | ESTRUTURA DE ATUALIZACAO DE ESPACO  }
       branch_licence
       branch_clusters
       branch_grants : { menu: [ MENU-ID-1, MENU-ID-2, MENU-ID-3, MENU-ID-4 ] }
    }
   */
  _result record;
  _branch tweeks.branch;
  OPERATION_INSERT char default 'I';
  OPERATION_UPDATE char default 'U';
  _colaborator lib.result;
  _espaco lib.result;
  _args tweeks.branch;
  _const map.constant;
  _all_space record;
  _arg_menu_list jsonb;

  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_id uuid default args->>'arg_espaco_id';
begin
  _const := map.constant();
  _args := jsonb_populate_record( _args, args );

  if _args.branch_uid is null then
    _args.branch_user := jsonb_build_object( 'creator', _args.branch_user );
    _args.branch_workspace := jsonb_build_object( 'creator', _args.branch_workspace );
  else
    select * into _branch
    from tweeks.branch b
    where b.branch_uid = _args.branch_uid
    ;
    _args.branch_user := _branch.branch_user || jsonb_build_object( 'updater', _args.branch_user );
    _args.branch_workspace := _branch.branch_workspace || jsonb_build_object( 'updater', _args.branch_workspace );
  end if;

  select
    s.*,
    ( s."returning"::tweeks.branch).*
  into _result
  from lib.sets( _args ) s
  ;

  _branch := _result."returning";

  -- Quando um novo branch for criado
  if ( regexp_split_to_array( upper( _result.operation ), '' ) )[1] = OPERATION_INSERT then

    _espaco := tweeks.funct_reg_espaco( (_branch.branch_workspace->'creator')||jsonb_build_object(
        'arg_branch_uid', _branch.branch_uid
      ));

    if not _espaco.result then
      raise exception '%', _espaco;
    end if;

    _branch.branch_main_workspace := ( _espaco.message->'espaco'->>'espaco_id');

    _colaborator := tweeks.funct_reg_colaborador(  ( _branch.branch_user->'creator' )|| jsonb_build_object(
        'arg_branch_uid', _branch.branch_uid,
        'arg_colaborador_tipo', _const.colaborador_tipo_user_master,
        'arg_espaco', jsonb_build_array(
            jsonb_build_object( 'arg_espaco_id', _branch.branch_main_workspace )
          )
      ));

    if not _colaborator.result then
      raise exception '%', _colaborator;
    end if;

    _branch.branch_main_user :=  ( _colaborator.message->'colaborador'->>'colaborador_id');

    with __news_space as (
      select *
        from tweeks.espaco e
          left join tweeks.trabalha tr on e.espaco_id = tr.trabalha_espaco_destino
            and tr.trabalha_estado = _const.transferencia_estado_ativo
            and tr.trabalha_colaborador_proprietario = lib.to_uuid( 2 )
        where tr.trabalha_id is null
          and e.espaco_nivel <= 1
    ) insert into tweeks.trabalha(
      trabalha_espaco_destino,
      trabalha_espaco_auth,
      trabalha_colaborador_proprietario,
      trabalha_colaborador_id
    ) select
        n.espaco_id,
        lib.to_uuid( 1 ),
        lib.to_uuid( 2 ),
        lib.to_uuid( 1 )
      from __news_space n
    ;

    -- Mapear o colaborador e o espaco principal no branch
    select (  "returning" ).* into _branch
    from lib.sets_up( _branch, ref := lib.sets_ref( _branch) )
    ;
  else
    _arg_menu_list := _branch.branch_user->'updater'->'arg_menu_list';

    _colaborator := tweeks.funct_change_colaborador(  ( _branch.branch_user->'updater' )|| jsonb_build_object(
        'arg_colaborador_tipo', _const.colaborador_tipo_user_master,
        'arg_espaco', jsonb_build_array(
            jsonb_build_object( 'arg_espaco_id', _branch.branch_main_workspace )
          )
      ));

    perform auth.funct_reg_acesso(
        jsonb_build_object(
            'arg_colaborador_id', arg_colaborador_id,
            'arg_colaborador_propetario', _branch.branch_main_user,
            'arg_menu_list', _arg_menu_list,
            '_branch_uid', _branch.branch_uid
          )
      );
    _espaco  := tweeks.funct_change_espaco( _branch.branch_workspace->'updater' || jsonb_build_object(
      'xBranch', true
    ));
  end if;

  return lib.res_true( jsonb_build_object(
    'branch', _branch
    ) || coalesce( _colaborator.message, jsonb_build_object() ) || coalesce( _espaco.message, jsonb_build_object() ) );
end
$$;


--
-- TOC entry 920 (class 1255 OID 17201)
-- Name: funct_sets_fornecedor(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_fornecedor(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registar um novo fornecedor no sistema
    args := {
      arg_espaco_auth: ID
      arg_colaborador_id: ID,

      fornecedor_id: UID | NULL
      fornecedor_nif: ID,
      fornecedor_nome: NOME,
      fornecedor_email: EMAIL,
      fornecedor_contacto: CONTACTO,
      fornecedor_endereco: ENDERECO
    }
  */

  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';
  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';

  __fornecedor tweeks.fornecedor;
  _exists record;
  ___branch uuid  default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );

begin
  __fornecedor := jsonb_populate_record( __fornecedor, args );

  if __fornecedor.fornecedor_id is null then
    __fornecedor.fornecedor_espaco_auth := arg_espaco_auth;
    __fornecedor.fornecedor_colaborador_id := arg_colaborador_id;
    while __fornecedor.fornecedor_code is null loop
        __fornecedor.fornecedor_code := cluster.next( 'fornecedor/seq', lpad := 2, lpad_char := '0', sub :=  ___branch::text );
      if exists(
        select *
          from tweeks.fornecedor f
          where f.fornecedor_code = __fornecedor.fornecedor_code
            and f._branch_uid = ___branch
      ) then
        __fornecedor.fornecedor_code := null;
      end if;
    end loop;
  else
    __fornecedor.fornecedor_colaborador_atualizacao := arg_colaborador_id;
    __fornecedor.fornecedor_dataatualizacao := current_timestamp;
  end if;

  with __uniques as (
    select
        f.fornecedor_code as "CODIGO",
        f.fornecedor_nif as "NIF",
        f.fornecedor_email as "EMAIL",
        jsonb_build_object(
          'CODIGO', __fornecedor.fornecedor_code,
          'NIF', __fornecedor.fornecedor_nif,
          'EMAIL', __fornecedor.fornecedor_email
        ) as _math
      from tweeks.fornecedor f
      where f._branch_uid = ___branch
        and ( __fornecedor.fornecedor_id is null or __fornecedor.fornecedor_id != f.fornecedor_id )
  ) select lib.duplicates( jsonb_agg( _uf ), _uf._math , true ) as dulicates  into _exists
      from __uniques _uf
      group by _uf._math
  ;

  if _exists.dulicates is not null then
    return false ? format( '(%s) estão duplicados!', _exists.dulicates );
  end if;


  select ( "returning" ).* into __fornecedor
    from lib.sets( __fornecedor );

  return true ? jsonb_build_object(
    'fornecedor', __fornecedor
  );
end;
$$;


--
-- TOC entry 259 (class 1259 OID 17202)
-- Name: guia; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.guia (
    guia_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    guia_toperacao_id smallint NOT NULL,
    guia_tguia_id smallint NOT NULL,
    guia_espaco_auth uuid NOT NULL,
    guia_colaborador_id uuid NOT NULL,
    guia_colaborador_atualizacao uuid,
    guia_documentoperacao character varying,
    guia_numero character varying NOT NULL,
    guia_metadata json,
    guia_dataoperacao date DEFAULT CURRENT_DATE NOT NULL,
    guia_observacao character varying,
    guia_refs jsonb,
    guia_refuid uuid,
    guia_refclass character varying,
    guia_estado smallint DEFAULT (map.get('maguita_guia_estado_ativo'::name))::smallint NOT NULL,
    guia_date timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    guia_dateupdate timestamp with time zone,
    _braunc_uid uuid,
    guia_espaco_saida uuid,
    guia_espaco_entrada uuid,
    _branch_uid uuid
);


--
-- TOC entry 901 (class 1255 OID 17211)
-- Name: funct_sets_guia(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_guia(args jsonb) RETURNS tweeks.guia
    LANGUAGE plpgsql
    AS $$
declare
    /**
      args := {
        guia: tweeks.guia {
          guia_toperacao_id: TOPERACAO,
          guia_espaco_entrada: UID
          guia_espaco_saida: UID
          guia_tguia_id: TGUIA
          guia_numero: NUMERO,
          guia_metadata: { ... any data },
          guia_dataoperacao: DATE,
          guia_observacao: OBS,
          guia_refs: { },
          guia_refuid: UID
          guia_refclass: string( regclass )

        },

        //Relativos a Guia
        custoguia: tweeks.custoguia[
          custoguia_montante: MONTANTE,
          custoguia_descricao: DESCRICAO PARA O CUSTO
          custoguia_tcusto_id: 1 - DESPESA | 2 - RECEITA
        ],
        arg_colaborador_id uuid,
        arg_espaco_auth uuid
      }
     */
    _args tweeks.guia;
    arg_colaborador_id uuid default args->>'arg_colaborador_id';
    arg_espaco_auth uuid default args->>'arg_espaco_auth';
    _iNext tweeks.custoguia;
    _custoguia tweeks.custoguia;
    _const map.constant;
    _branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  begin
    _const := map.constant();
    _args := jsonb_populate_record( _args, args->'guia' );

    if _args.guia_uid is null then
      
      _args.guia_numero := tweeks.__generate_guia_code( _branch, _args.guia_toperacao_id );
      _args._braunc_uid := _branch;
      _args.guia_espaco_auth := arg_espaco_auth;
      _args.guia_colaborador_id := arg_colaborador_id;

      select ( "returning" ).* into _args
        from lib.sets_in( _args )
      ;
      for _iNext in
        select cg.*
          from jsonb_array_elements( args->'custoguia' ) e( doc )
            inner join jsonb_populate_record( null::tweeks.custoguia, e.doc ) cg on true
      loop
        _iNext.custoguia_colaborador_id := arg_colaborador_id;
        _iNext.custoguia_espaco_auth := arg_espaco_auth;
        _iNext.custoguia_guia_uid := _args.guia_uid;
        _iNext._branch_uid := _branch;
        select ( "returning" ).* into _custoguia
          from lib.sets_in( _iNext );
      end loop;
    else
      _args._braunc_uid := _branch;
      _args.guia_colaborador_atualizacao := arg_colaborador_id;
      _args.guia_dateupdate := arg_colaborador_id;

      select ( "returning" ).* into _args
        from lib.sets_up( _args )
      ;
      update tweeks.custoguia
        set custoguia_estado = _const.maguita_custoguia_estado_canselado,
            custoguia_dateupdate = clock_timestamp(),
            custoguia_colaborador_atualizacao = arg_colaborador_id
        where custoguia_guia_uid = _args.guia_uid
          and custoguia_estado = _const.maguita_custoguia_estado_ativo
      ;

      for _iNext in
        select cg.*
          from jsonb_array_elements( args->'custoguia' ) e( doc )
            inner join jsonb_populate_record( null::tweeks.custoguia, e.doc ) cg on true
        loop
          _iNext.custoguia_guia_uid := _args.guia_uid;
          _iNext.custoguia_colaborador_id := arg_colaborador_id;
          _iNext.custoguia_dateupdate := clock_timestamp();
          select ( "returning" ).* into _custoguia
          from lib.sets_in( _iNext );
        end loop;
    end if;

    return _args;
  end;
$$;


--
-- TOC entry 922 (class 1255 OID 17212)
-- Name: funct_sets_serie(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_serie(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /**
    args := {
      arg_colaborador_id uuid not null,
      arg_espaco_auth uuid not null,

      serie_id uuid not null,
      serie_tserie_id int2 not null,
      serie_espaco_id uuid not null,
      serie_designacao character varying not null,
      serie_numero character varying not null,
      serie_quantidade int not null,
      serie_numcertificacao,
      serie_numatorizacao
    }
   */

  _serie tweeks.serie;
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  ___branch uuid default tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth );
  _const map.constant;
begin
  _const := map.constant();
  _serie := jsonb_populate_record( _serie, args );

  if _serie.serie_id is null then
    _serie.serie_colaborador_id := arg_colaborador_id;
    _serie.serie_espaco_auth := arg_espaco_auth;

    -- Desativar as serie ativa para o espaçoa
    update tweeks.serie
      set serie_estado = _const.maguita_serie_estado_fechado,
          serie_colaborador_atualizacao = arg_colaborador_id,
          serie_dataatualizacao = current_timestamp
      where serie_tserie_id = _serie.serie_tserie_id
        and serie_espaco_id = _serie.serie_espaco_id
        and _branch_uid = ___branch
        and serie_estado = _const.maguita_serie_estado_ativo
    ;
  else
    _serie.serie_colaborador_atualizacao := arg_colaborador_id;
    _serie.serie_dataatualizacao := current_timestamp;
  end if;


  -- Quando for registrar nova serie
  select ( "returning" ).* into _serie
    from lib.sets( _serie );

  return lib.res_true(jsonb_build_object(
    'serie', _serie
  ));
end;
$$;


--
-- TOC entry 525 (class 1255 OID 157925)
-- Name: funct_sets_unit(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.funct_sets_unit(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$ 
declare
  /**doc
    Sets unit
    args := {
        _espaco_auth
        _user_id
        unit_id? ,
        unit_code,
        unit_name,
        unit_state?
    }
  doc*/
  _espaco_auth uuid not null default args->>'_espaco_auth';
  _user_id uuid not null default args->>'_user_id';
  _branch uuid default tweeks.__branch_uid( _user_id, _espaco_auth );
  _args tweeks.unit;
  _unit tweeks.unit;
begin
  
  _args := jsonb_populate_record( _args, args );
  if _args.unit_id is null then 
    _args.unit_user_id := _user_id;
    _args.unit_espaco_auth := _espaco_auth;
    _args._branch_uid := _branch;
  else
    _args.unit_update := clock_timestamp();
    _args.unit_user_update := _user_id;
  end if;
  
  -- Garantir que o codigo da unidade não se repita
  if _args.unit_id is null and exists(
    select *
      from tweeks.unit u 
      where u._branch_uid = _args._branch_uid
        and lower( trim( u.unit_code ) )  = lower( trim( _args.unit_code ) )
  ) then
    return lib.res_false( 'Já existe uma unidade com o código selecionado!' );
  end if;
  
  select ( "returning").* into _unit
    from lib.sets( _args )
  ;
  
  return lib.res_true( jsonb_build_object(
    'unit', _unit
  ));
end;
$$;


--
-- TOC entry 923 (class 1255 OID 17213)
-- Name: load_clusters(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.load_clusters(args jsonb) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
declare
  _const map.constant;
begin
  _const := map.constant();
  return query with
    __cluster as (
      select
          c.cluster_uid,
          c.cluster_identifier,
          c.cluster_type,
          c.cluster_code,
          c.cluster_path,
          c.cluster_domain,
          c.cluster_licenselife,
          c.cluster_license,
          case
            when c.cluster_name is null and c.cluster_type = _const.cluster_tcluster_local then 'Local server'
            else c.cluster_name
          end as cluster_name,
          c.cluster_port,
          c.cluster_api,
          c.cluster_version,
          c.cluster_grants,
          c.cluster_configs,
          c.cluster_sequence,
          c.cluster_namespace,
          tp.*
        from cluster.cluster c
          left join cluster.tperiod tp on c.cluster_tperiod_id = tp.tperiod_id
    ) select to_jsonb( _c )
      from __cluster _c
      order by case
        when _c.cluster_type = _const.cluster_tcluster_local then 1
        when _c.cluster_type = _const.cluster_tcluster_master then 2
        when _c.cluster_type = _const.cluster_tcluster_child then 3
        when _c.cluster_type = _const.cluster_tcluster_remote then 4
      end,
      _c.cluster_name
  ;
end;
$$;


--
-- TOC entry 924 (class 1255 OID 17214)
-- Name: main(regproc, jsonb, text); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.main(function regproc, args jsonb, mode text DEFAULT 'dev'::text) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $_$
declare
  MODE_PROD constant text default 'prod';
  MODE_TEST constant text default 'test';
  MODE_DEV constant text default 'dev';
  MODE_PUB constant text default 'public';
  _statement text;
begin

  --language=PostgreSQL
  _statement := format( $sql$
      select to_jsonb( t )
        from %s ( $1 ) t;
  $sql$, function );

  -- Mode DEV don't try-catch error
  if mode = MODE_DEV then
    return query execute _statement using args;


  -- Mode PROD and TEST try-catch error
  else
    begin
      return query execute _statement using args;

    exception when others then
      <<_ex>>
      declare
        e text; m text; d text; h text; c text;
        _catch lib.res;
      begin
        get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
        _catch :=  lib.res_exception( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c,
        case
          when mode in( MODE_PROD, MODE_PUB ) then format( 'Algo deu mal, tente novamente mais tarde ou proucure pelo suporte! Error Code: (%s)', _ex.e )
          when mode = MODE_TEST then _ex.m
          else _ex.m
          end
        );
        return next to_jsonb( _catch );
      end;
    end;
  end if;
end;
$_$;


--
-- TOC entry 925 (class 1255 OID 17215)
-- Name: sets_lancamento(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.sets_lancamento(args jsonb) RETURNS lib.res
    LANGUAGE plpgsql
    AS $$
declare
  /*
    arg_espaco_auth?:UUID
    arg_colaborador_id?:UUID

    lancamento_id?: UID
    arg_lancamento_incrementevia:BOOLEAN

    lancamento_tlancamento_id: SELECT*
    _tgrupo_id [{ maguita_tgrupo_ccorrente | maguita_tgrupo_cnormal }] default maguita_tgrupo_ccorrente
    lancamento_operacao := CREDITO => 1 | DEBITO => -1;
    lancamento_valor := _deposito.deposito_montantefinal;
    lancamento_cliente_id*
    lancamento_data := DATE;
    lancamento_documento?: DOCUMENTO;
    lancamento_descricao: DESCRICAO
   */
  _const map.constant;
  _lancamento tweeks.lancamento;

  arg_espaco_auth uuid default args->>'arg_espaco_auth';
  arg_colaborador_id uuid default args->>'arg_colaborador_id';
  arg_lancamento_incrementevia uuid default args->>'arg_lancamento_incrementevia';
begin

  _const := map.constant();
  _lancamento := jsonb_populate_record( _lancamento, args );
  _lancamento._tgrupo_id := coalesce( _lancamento._tgrupo_id, _const.maguita_tgrupo_ccorrente );

  if _lancamento.lancamento_id is null then
    _lancamento.lancamento_mode := _const.maguita_lancamento_mode_manual;
    _lancamento.lancamento_espaco_auth := coalesce( _lancamento.lancamento_espaco_auth, arg_espaco_auth );
    _lancamento.lancamento_colaborador_id := coalesce( _lancamento.lancamento_colaborador_id, arg_colaborador_id );
    _lancamento.lancamento_referencia := jsonb_build_object();
    _lancamento._branch_uid := coalesce( _lancamento._branch_uid, tweeks.__branch_uid( arg_colaborador_id, arg_espaco_auth ) );
  else
    _lancamento.lancamento_colaborador_atualizacao := arg_colaborador_id;
    _lancamento.lancamento_dataatualizacao := now();
    if arg_lancamento_incrementevia then
      _lancamento.lancamento_via := coalesce( _lancamento.lancamento_via, 1)+1;
    end if;
  end if;

  select ( "returning" ).* into _lancamento
    from lib.sets( _lancamento )
  ;

  return lib.res_true(jsonb_build_object(
    '_lancamento', _lancamento
  ));
end;
$$;


--
-- TOC entry 926 (class 1255 OID 17216)
-- Name: sets_tipoimposto(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.sets_tipoimposto(args jsonb) RETURNS lib.result
    LANGUAGE plpgsql
    AS $$
declare
  /**
    Essa função serve para registar os tipos de imposto
    args := {
      arg_colaborador_id: ID,
      arg_espaco_auth: ID,
      arg_links :[ { arg_espaco_destino: ID  } ]

      tipoimposto_id
      tipoimposto_nome: NOME,
      tipoimposto_codigo: CODIGO,
      taxa_taxa: VALOR,
      taxa_percentagem: PERCENTAGEM,

    }
   */

  arg_espaco_auth uuid not null default args->>'arg_espaco_auth';
  arg_colaborador_id uuid not null default args->>'arg_colaborador_id';


  arg_tipoimposto_codigo character varying not null default args->>'tipoimposto_codigo';
  arg_taxa_percentagem double precision default args->>'taxa_percentagem';
  arg_taxa_taxa double precision default args->>'taxa_taxa';
  arg_espaco_child uuid[] default rule.espaco_get_childrens( arg_espaco_auth );
  _tipoimposto tweeks.tipoimposto;
begin
  arg_tipoimposto_codigo := lib.str_normalize( upper( public.unaccent( arg_tipoimposto_codigo ) ) );

  _tipoimposto := jsonb_populate_record( _tipoimposto, args );

  if (
    select count( * ) > 0
      from tweeks.tipoimposto tip
      where tip.tipoimposto_espaco_auth = any( arg_espaco_child )
        and tip.tipoimposto_id != coalesce( _tipoimposto.tipoimposto_id, lib.to_uuid( 0 ) )
        and lib.str_normalize( upper( public.unaccent( tip.tipoimposto_codigo ) ) ) = arg_tipoimposto_codigo
  ) then
    return false ? '@tweeks.tipoimposto.codigo-already-exist';
  end if;

  if _tipoimposto.tipoimposto_id is null then
    _tipoimposto.tipoimposto_colaborador_id := arg_colaborador_id;
    _tipoimposto.tipoimposto_espaco_auth := arg_espaco_auth;
  else
    _tipoimposto.tipoimposto_colaborador_atualizacao := arg_colaborador_id;
    _tipoimposto.tipoimposto_dataatuzaliacao := now();
  end if;

  select ( "returning" ).* into _tipoimposto
    from lib.sets( _tipoimposto, args );

  perform tweeks.funct_reg_taxa(
    jsonb_build_object(
      'arg_espaco_auth', arg_espaco_auth,
      'arg_colaborador_id', arg_colaborador_id,
      'arg_tipoimposto_id', _tipoimposto.tipoimposto_id,
      'arg_taxa_percentagem', arg_taxa_percentagem,
      'arg_taxa_taxa', arg_taxa_taxa
    )
  );

  perform tweeks.funct_reg_link_associacao(
    jsonb_build_object(
      'arg_colaborador_id', arg_colaborador_id,
      'arg_espaco_auth', arg_espaco_auth,
      'arg_link_nome', _tipoimposto.tipoimposto_nome,
      'arg_link_referencia', jsonb_build_object( 'tipoimposto_id', _tipoimposto.tipoimposto_id ),
      'arg_links', args->'arg_links'
    )
  );

  return true ? jsonb_build_object(
    'tipoimposto', _tipoimposto
  );

exception  when others then
  <<_ex>> declare e text; m text; d text; h text; c text;
  begin
    get stacked diagnostics e=returned_sqlstate, m=message_text, d=pg_exception_detail, h=pg_exception_hint, c=pg_exception_context;
    return lib.result_catch( _ex.e, _ex.m, _ex.h, _ex.d, _ex.c );
  end;
end;
$$;


--
-- TOC entry 927 (class 1255 OID 17217)
-- Name: viewarg(text); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.viewarg(argname text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT PARALLEL SAFE
    AS $$
  select jsonb_build_object( 'value', current_setting( format( 'viewargs.%I', argname ), true)::jsonb )->>'value'
$$;


--
-- TOC entry 917 (class 1255 OID 17218)
-- Name: viewargs_object(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.viewargs_object() RETURNS jsonb
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
  select
      jsonb_object_agg(
        substr(e.param, length('viewargs.*'), length( e.param )),
        current_setting( e.param, true )::jsonb
      )
    from jsonb_array_elements_text( current_setting( 'viewargs.*', true )::jsonb )  e( param)
$$;


--
-- TOC entry 547 (class 1255 OID 17219)
-- Name: viewargs_set(text, anyelement); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.viewargs_set(key text, element anyelement) RETURNS TABLE(param text, value jsonb, text text)
    LANGUAGE sql
    AS $$
  select *
    from tweeks.viewargs_sets( jsonb_build_object( key, element ));
$$;


--
-- TOC entry 548 (class 1255 OID 17220)
-- Name: viewargs_sets(jsonb); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.viewargs_sets(jsonb) RETURNS TABLE(param text, value jsonb, text text)
    LANGUAGE plpgsql
    AS $_$
  declare
    _record record;
    _keys jsonb;
  begin

    _keys := coalesce( current_setting( 'viewargs.*', true )::jsonb, jsonb_build_array());
    select coalesce(jsonb_agg( k.param ), jsonb_build_array()) into _keys
      from jsonb_array_elements_text( _keys ) k( param)
      where k.param != all( array( select format('viewargs.%I',  e ) from jsonb_object_keys( $1) e))
    ;
    
    for _record in
      select *
        from jsonb_each( $1 )
    loop
      viewargs_sets.param := format('viewargs.%I', _record.key );
      viewargs_sets.text := _record.value;
      viewargs_sets.value := _record.value;
      _keys := _keys || to_jsonb( viewargs_sets.param );
      perform set_config( viewargs_sets.param, viewargs_sets.text, false );
      return next;
    end loop;

    viewargs_sets.param := 'viewargs.*';
    viewargs_sets.text := to_jsonb( _keys );
    viewargs_sets.value := to_jsonb( _keys );
    perform set_config( viewargs_sets.param, viewargs_sets.text, false );
    return next;
  end;
$_$;


--
-- TOC entry 549 (class 1255 OID 17221)
-- Name: viewargs_show(); Type: FUNCTION; Schema: tweeks; Owner: -
--

CREATE FUNCTION tweeks.viewargs_show(OUT param text, OUT key text, OUT value jsonb, OUT text text) RETURNS SETOF record
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
  select
      e.param,
      substr(e.param, length('viewargs.*'), length( e.param )),
      current_setting( e.param, true )::jsonb,
      jsonb_build_object( 'value', current_setting( e.param, true )::jsonb )->>'value'
    from jsonb_array_elements_text( current_setting( 'viewargs.*', true )::jsonb ) e( param)
$$;


--
-- TOC entry 1936 (class 1255 OID 17222)
-- Name: first(anyelement); Type: AGGREGATE; Schema: lib; Owner: -
--

CREATE AGGREGATE lib.first(anyelement) (
    SFUNC = lib.agg_first,
    STYPE = anyelement
);


--
-- TOC entry 1937 (class 1255 OID 17223)
-- Name: last(anyelement); Type: AGGREGATE; Schema: lib; Owner: -
--

CREATE AGGREGATE lib.last(anyelement) (
    SFUNC = lib.agg_last,
    STYPE = anyelement
);


--
-- TOC entry 2737 (class 2617 OID 17224)
-- Name: -; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.- (
    FUNCTION = lib.result_remove,
    LEFTARG = lib.result,
    RIGHTARG = text
);


--
-- TOC entry 2738 (class 2617 OID 17225)
-- Name: -; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.- (
    FUNCTION = lib.result_remove,
    LEFTARG = lib.result,
    RIGHTARG = integer
);


--
-- TOC entry 2739 (class 2617 OID 17226)
-- Name: ?; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.? (
    FUNCTION = lib.result,
    LEFTARG = boolean,
    RIGHTARG = text
);


--
-- TOC entry 2740 (class 2617 OID 17227)
-- Name: ?; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.? (
    FUNCTION = lib.result,
    LEFTARG = boolean,
    RIGHTARG = jsonb
);


--
-- TOC entry 2741 (class 2617 OID 17228)
-- Name: ||; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.|| (
    FUNCTION = lib.result_concat,
    LEFTARG = lib.result,
    RIGHTARG = jsonb
);


--
-- TOC entry 2742 (class 2617 OID 17229)
-- Name: ||; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.|| (
    FUNCTION = lib.result_concat,
    LEFTARG = lib.result,
    RIGHTARG = lib.result
);


--
-- TOC entry 2743 (class 2617 OID 17230)
-- Name: ||; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.|| (
    FUNCTION = lib.result_remove,
    LEFTARG = lib.result,
    RIGHTARG = integer
);


--
-- TOC entry 2744 (class 2617 OID 17231)
-- Name: ||; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR public.|| (
    FUNCTION = lib.result_remove,
    LEFTARG = lib.result,
    RIGHTARG = text
);


--
-- TOC entry 260 (class 1259 OID 17232)
-- Name: acesso; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.acesso (
    acesso_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    acesso_menu_id smallint NOT NULL,
    acesso_colaborador_propetario uuid NOT NULL,
    acesso_colaborador_id uuid NOT NULL,
    acesso_colaborador_atualizacao uuid,
    acesso_estado smallint DEFAULT (map.get('acesso_estado_ativo'::name))::smallint NOT NULL,
    acesso_dataregisto timestamp with time zone DEFAULT now() NOT NULL,
    acesso_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 6232 (class 0 OID 0)
-- Dependencies: 260
-- Name: TABLE acesso; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.acesso IS 'Essa entidade serve para armazenar os acessos dos colaboradores a um dado menu';


--
-- TOC entry 6233 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_id IS 'Identificador do acesso do colaborador';


--
-- TOC entry 6234 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_menu_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_menu_id IS 'Identificacão do menu a qual o acesso remete';


--
-- TOC entry 6235 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_colaborador_propetario; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_colaborador_propetario IS 'Indenticação do colaborador a quel é o propetario do refererido acesso';


--
-- TOC entry 6236 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_colaborador_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_colaborador_id IS 'Identificação do colaborador a qual cadastrou o acesso';


--
-- TOC entry 6237 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_colaborador_atualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_colaborador_atualizacao IS 'Identificador do último colaborador atualizando a informação do acesso';


--
-- TOC entry 6238 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_estado; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_estado IS 'O atual estado do acesso | estado = { 1 - Acesso pemitido, 0 - Acesso revigado }';


--
-- TOC entry 6239 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_dataregisto; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_dataregisto IS 'A data em que o acesso ao menu foi ao colaborador propetario dado';


--
-- TOC entry 6240 (class 0 OID 0)
-- Dependencies: 260
-- Name: COLUMN acesso.acesso_dataatualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.acesso.acesso_dataatualizacao IS 'A data em que o menu foi revogado do colaborador!';


--
-- TOC entry 261 (class 1259 OID 17238)
-- Name: autenticacao; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.autenticacao (
    autenticacao_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    autenticacao_colaborador_id uuid NOT NULL,
    autenticacao_chave character varying NOT NULL,
    autenticacao_estado smallint DEFAULT (map.get('autenticacao_estado_ativo'::name))::smallint,
    autenticacao_dataregisto timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    autenticacao_dataatualizacao timestamp with time zone
);


--
-- TOC entry 6242 (class 0 OID 0)
-- Dependencies: 261
-- Name: TABLE autenticacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.autenticacao IS 'Essa entidade serve para armazenar as autenticacoes que um colaborador vai passadno';


--
-- TOC entry 6243 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN autenticacao.autenticacao_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.autenticacao.autenticacao_id IS 'Identificador da autenticacao';


--
-- TOC entry 6244 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN autenticacao.autenticacao_colaborador_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.autenticacao.autenticacao_colaborador_id IS 'Identificacao do colaborador que autenticou';


--
-- TOC entry 6245 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN autenticacao.autenticacao_chave; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.autenticacao.autenticacao_chave IS 'Corresponde a chave da autenticação';


--
-- TOC entry 6246 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN autenticacao.autenticacao_estado; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.autenticacao.autenticacao_estado IS 'Corresponde ao estado da autenticação
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechadao </li>
</ul>
  ';


--
-- TOC entry 6247 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN autenticacao.autenticacao_dataregisto; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.autenticacao.autenticacao_dataregisto IS 'Corresponde a data em que a autenticação foi efetuada';


--
-- TOC entry 6248 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN autenticacao.autenticacao_dataatualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.autenticacao.autenticacao_dataatualizacao IS 'Corresponde a data da última atualização da autenticação ( data de logoff )';


--
-- TOC entry 262 (class 1259 OID 17246)
-- Name: privilegio; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.privilegio (
    privilegio_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    previlegio_perfil_id uuid NOT NULL,
    privilegio_menu_id smallint NOT NULL,
    privilegio_colaborador_id uuid NOT NULL,
    privilegio_colaborador_atualizacao uuid,
    privilegio_estado smallint DEFAULT (map.get('privilegio_estado_ativo'::name))::smallint NOT NULL,
    privilegio_dataregisto timestamp with time zone DEFAULT now() NOT NULL,
    privilegio_dataatualuzacao timestamp with time zone
);


--
-- TOC entry 6250 (class 0 OID 0)
-- Dependencies: 262
-- Name: TABLE privilegio; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.privilegio IS 'Esse entidade mapeia os menus a que um perfil tem previlegio de aceder';


--
-- TOC entry 6251 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_id IS 'Identificador único do privilegio';


--
-- TOC entry 6252 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.previlegio_perfil_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.previlegio_perfil_id IS 'Identificador do perfil com o privilégio';


--
-- TOC entry 6253 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_menu_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_menu_id IS 'Identificador do menu ao qual o perfil tem o privilégio de aceder';


--
-- TOC entry 6254 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_colaborador_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_colaborador_id IS 'Identificador do colaborador responsável pela atribuição do privelégio';


--
-- TOC entry 6255 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_colaborador_atualizacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização do privilégio | colaborador que revogou o privelégio do menu ao perfil';


--
-- TOC entry 6256 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_estado; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_estado IS 'Corresponde ao estado do privilégio
<ul>
  <li> 1 - Ativo | Siginifica que o perfil ainda possui privelegio ao menu </li>
  <li> 0 - Fechado | Significa que o perfil perdeu o privilégio ao menu </li>
</ul>';


--
-- TOC entry 6257 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_dataregisto; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_dataregisto IS 'Corresponde ao instante exato em que o privilégio foi definido no sistema';


--
-- TOC entry 6258 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN privilegio.privilegio_dataatualuzacao; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.privilegio.privilegio_dataatualuzacao IS 'Corresponde ao último instante em que o privilegio foi atualizado no sistema | momento em que foi desativo';


--
-- TOC entry 263 (class 1259 OID 17252)
-- Name: session; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.session (
    sid character varying NOT NULL,
    sess json NOT NULL,
    expire timestamp(6) without time zone NOT NULL
);


--
-- TOC entry 264 (class 1259 OID 17257)
-- Name: tsexo; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.tsexo (
    tsexo_id smallint NOT NULL,
    tsexo_nome character varying NOT NULL,
    tsexo_codigo character(1) NOT NULL,
    CONSTRAINT ck_tsexo_codigo_valid CHECK (((tsexo_codigo)::text = upper((tsexo_codigo)::text)))
);


--
-- TOC entry 6261 (class 0 OID 0)
-- Dependencies: 264
-- Name: TABLE tsexo; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.tsexo IS 'Essa entidade serve para armazenar os sexos do colaboradores';


--
-- TOC entry 6262 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN tsexo.tsexo_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.tsexo.tsexo_id IS 'Identificador único do sexo do colaborador';


--
-- TOC entry 6263 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN tsexo.tsexo_nome; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.tsexo.tsexo_nome IS 'Corresponde ao nome do sexo';


--
-- TOC entry 6264 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN tsexo.tsexo_codigo; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.tsexo.tsexo_codigo IS 'Corresponde ao codigo do sexo do colaboarador';


--
-- TOC entry 265 (class 1259 OID 17263)
-- Name: auth; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.auth (
    auth_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    auth_seq bigint NOT NULL,
    auth_key character varying DEFAULT lib.dset_random_text(128),
    auth_cluster_uid uuid,
    auth_date timestamp with time zone DEFAULT now() NOT NULL,
    auth_status smallint DEFAULT 1 NOT NULL,
    auth_close timestamp with time zone
);


--
-- TOC entry 266 (class 1259 OID 17272)
-- Name: auth_auth_seq_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.auth_auth_seq_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6267 (class 0 OID 0)
-- Dependencies: 266
-- Name: auth_auth_seq_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.auth_auth_seq_seq OWNED BY cluster.auth.auth_seq;


--
-- TOC entry 267 (class 1259 OID 17273)
-- Name: break; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.break (
    break_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    break_collector jsonb,
    break_object jsonb,
    break_old jsonb,
    break_regclass character varying,
    break_origin uuid,
    break_receiver uuid,
    break_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    break_instant timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    break_status smallint DEFAULT (map.get('cluster_break_status_pendent'::name))::smallint NOT NULL,
    break_sqlstate text,
    break_message text,
    break_detail text,
    break_hint text,
    break_context text,
    break_ref jsonb,
    break_metadata jsonb,
    break_change jsonb,
    break_current jsonb,
    break_document jsonb
);


--
-- TOC entry 268 (class 1259 OID 17282)
-- Name: classmap; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.classmap (
    classname character varying NOT NULL,
    classnameref character varying NOT NULL,
    status integer DEFAULT 1 NOT NULL
);


--
-- TOC entry 269 (class 1259 OID 17288)
-- Name: collector_collector_sequence_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.collector_collector_sequence_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6271 (class 0 OID 0)
-- Dependencies: 269
-- Name: collector_collector_sequence_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.collector_collector_sequence_seq OWNED BY cluster.collector.collector_sequence;


--
-- TOC entry 270 (class 1259 OID 17289)
-- Name: filter; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.filter (
    filter_id integer NOT NULL,
    filter_regclass character varying,
    filter_regproc character varying NOT NULL,
    filter_sequence integer NOT NULL,
    filter_name character varying,
    filter_describe text
);


--
-- TOC entry 271 (class 1259 OID 17294)
-- Name: filter_filter_id_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.filter_filter_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6274 (class 0 OID 0)
-- Dependencies: 271
-- Name: filter_filter_id_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.filter_filter_id_seq OWNED BY cluster.filter.filter_id;


--
-- TOC entry 272 (class 1259 OID 17295)
-- Name: filter_filter_sequence_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.filter_filter_sequence_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6276 (class 0 OID 0)
-- Dependencies: 272
-- Name: filter_filter_sequence_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.filter_filter_sequence_seq OWNED BY cluster.filter.filter_sequence;


--
-- TOC entry 273 (class 1259 OID 17296)
-- Name: ignore; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.ignore (
    origin character varying NOT NULL,
    object uuid NOT NULL,
    collector uuid NOT NULL,
    transaction uuid NOT NULL
);


--
-- TOC entry 274 (class 1259 OID 17301)
-- Name: object_object_seq_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.object_object_seq_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6279 (class 0 OID 0)
-- Dependencies: 274
-- Name: object_object_seq_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.object_object_seq_seq OWNED BY cluster.object.object_seq;


--
-- TOC entry 275 (class 1259 OID 17302)
-- Name: object_object_sseq_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.object_object_sseq_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6281 (class 0 OID 0)
-- Dependencies: 275
-- Name: object_object_sseq_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.object_object_sseq_seq OWNED BY cluster.object.object_sseq;


--
-- TOC entry 276 (class 1259 OID 17303)
-- Name: pull; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.pull (
    pull_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    pull_server jsonb NOT NULL,
    pull_objects jsonb NOT NULL,
    pull_ignores jsonb,
    pull_result jsonb,
    pull_total bigint,
    pull_limit bigint,
    pull_revcode character varying,
    pull_rejected integer,
    pull_sequence bigint NOT NULL,
    pull_instant timestamp with time zone DEFAULT clock_timestamp(),
    pull_status smallint DEFAULT 2,
    pull_pulled jsonb,
    pull_finalize timestamp without time zone
);


--
-- TOC entry 277 (class 1259 OID 17311)
-- Name: pull_pull_sequence_seq; Type: SEQUENCE; Schema: cluster; Owner: -
--

CREATE SEQUENCE cluster.pull_pull_sequence_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6284 (class 0 OID 0)
-- Dependencies: 277
-- Name: pull_pull_sequence_seq; Type: SEQUENCE OWNED BY; Schema: cluster; Owner: -
--

ALTER SEQUENCE cluster.pull_pull_sequence_seq OWNED BY cluster.pull.pull_sequence;


--
-- TOC entry 278 (class 1259 OID 17312)
-- Name: sequence; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.sequence (
    name character varying NOT NULL,
    sub character varying NOT NULL,
    sequence bigint DEFAULT 0 NOT NULL,
    steep integer NOT NULL,
    lpad integer DEFAULT 0 NOT NULL,
    lpad_char character(1) DEFAULT ''::bpchar NOT NULL,
    zerobase boolean DEFAULT false NOT NULL
);


--
-- TOC entry 279 (class 1259 OID 17321)
-- Name: share; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.share (
    share_regclass character varying NOT NULL,
    share_insert boolean DEFAULT true NOT NULL,
    share_update boolean DEFAULT true NOT NULL,
    share_checker regprocedure,
    share_triggers name[],
    share_pks name[],
    share_pksfrom character varying,
    CONSTRAINT ck_share_as_primary_key CHECK ((COALESCE(array_length(share_pks, 1), 0) > 0))
);


--
-- TOC entry 280 (class 1259 OID 17329)
-- Name: tperiod; Type: TABLE; Schema: cluster; Owner: -
--

CREATE TABLE cluster.tperiod (
    tperiod_id smallint NOT NULL,
    tperiod_desc character varying,
    tperiod_label character varying,
    tperiod_code character varying
);


--
-- TOC entry 281 (class 1259 OID 17334)
-- Name: altspelling; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.altspelling (
    altspelling_id smallint NOT NULL,
    altspelling_country_id smallint NOT NULL,
    altspelling_altspelling character varying NOT NULL
);


--
-- TOC entry 282 (class 1259 OID 17339)
-- Name: country; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.country (
    country_id smallint NOT NULL,
    country_region_id smallint,
    country_subregion_id smallint,
    country_demonym_id smallint,
    country_name character varying NOT NULL,
    country_iso2 character varying NOT NULL,
    country_iso3 character varying NOT NULL,
    country_capital character varying,
    country_population integer NOT NULL,
    country_latitude numeric,
    country_longitude numeric,
    country_area numeric,
    country_gini numeric,
    country_nativename character varying NOT NULL,
    country_numericcode character varying,
    country_flag character varying NOT NULL,
    country_cioc character varying
);


--
-- TOC entry 283 (class 1259 OID 17344)
-- Name: countryborder; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countryborder (
    countryborder_id smallint NOT NULL,
    countryborder_country_id smallint NOT NULL,
    countryborder_country_broder smallint NOT NULL
);


--
-- TOC entry 284 (class 1259 OID 17347)
-- Name: countrycallcode; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countrycallcode (
    countrycallcode_id smallint NOT NULL,
    countrycallcode_country_id smallint NOT NULL,
    countrycallcode_callcode smallint NOT NULL
);


--
-- TOC entry 285 (class 1259 OID 17350)
-- Name: countrycurrency; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countrycurrency (
    countrycurrency_id smallint NOT NULL,
    countrycurrency_country_id smallint NOT NULL,
    countrycurrency_currency_id smallint NOT NULL
);


--
-- TOC entry 286 (class 1259 OID 17353)
-- Name: countrylanguage; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countrylanguage (
    countrylanguage_id smallint NOT NULL,
    countrylanguage_country_id smallint NOT NULL,
    countrylanguage_language_id smallint NOT NULL
);


--
-- TOC entry 287 (class 1259 OID 17356)
-- Name: countryregionalbloc; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countryregionalbloc (
    countryregionalbloc_id smallint NOT NULL,
    countryregionalbloc_country_id smallint NOT NULL,
    countryregionalbloc_regionalbloc_id smallint NOT NULL
);


--
-- TOC entry 288 (class 1259 OID 17359)
-- Name: countrytimezone; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countrytimezone (
    countrytimezone_id smallint NOT NULL,
    countrytimezone_country_id smallint NOT NULL,
    countrytimezone_timezone_id smallint NOT NULL
);


--
-- TOC entry 289 (class 1259 OID 17362)
-- Name: countrytopleveldomain; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countrytopleveldomain (
    countrytopleveldomain_id smallint NOT NULL,
    countrytopleveldomain_country_id smallint NOT NULL,
    countrytopleveldomain_domain_id smallint NOT NULL
);


--
-- TOC entry 290 (class 1259 OID 17365)
-- Name: countrytranslation; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.countrytranslation (
    countrytranslation_id smallint NOT NULL,
    countrytranslation_country_id smallint NOT NULL,
    countrytranslation_language_id smallint NOT NULL,
    countrytranslation_translation character varying NOT NULL
);


--
-- TOC entry 291 (class 1259 OID 17370)
-- Name: currency; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.currency (
    currency_id smallint NOT NULL,
    currency_code character varying,
    currency_name character varying,
    currency_symbol character varying
);


--
-- TOC entry 292 (class 1259 OID 17375)
-- Name: demonym; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.demonym (
    demonym_id smallint NOT NULL,
    demonym_name character varying NOT NULL
);


--
-- TOC entry 293 (class 1259 OID 17380)
-- Name: domain; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.domain (
    domain_id smallint NOT NULL,
    domain_name character varying NOT NULL
);


--
-- TOC entry 294 (class 1259 OID 17385)
-- Name: language; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.language (
    language_id smallint NOT NULL,
    language_iso2 character varying,
    language_iso3 character varying NOT NULL,
    language_name character varying NOT NULL,
    language_nativename character varying NOT NULL
);


--
-- TOC entry 295 (class 1259 OID 17390)
-- Name: region; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.region (
    region_id smallint NOT NULL,
    region_name character varying NOT NULL
);


--
-- TOC entry 296 (class 1259 OID 17395)
-- Name: regionalbloc; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.regionalbloc (
    regionalbloc_id smallint NOT NULL,
    regionalbloc_acronym character varying NOT NULL,
    regionalbloc_name character varying NOT NULL
);


--
-- TOC entry 297 (class 1259 OID 17400)
-- Name: regionalblocname; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.regionalblocname (
    regionalblocname_id smallint NOT NULL,
    regionalblocname_regionalbloc_id smallint NOT NULL,
    regionalblocname_name character varying NOT NULL
);


--
-- TOC entry 298 (class 1259 OID 17405)
-- Name: regionalblocother; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.regionalblocother (
    regionalblocother_id smallint NOT NULL,
    regionalblocother_regionalbloc_id smallint NOT NULL,
    regionalblocother_otheracronym character varying NOT NULL
);


--
-- TOC entry 299 (class 1259 OID 17410)
-- Name: seq_altspelling; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_altspelling
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6307 (class 0 OID 0)
-- Dependencies: 299
-- Name: seq_altspelling; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_altspelling OWNED BY geoinfo.altspelling.altspelling_id;


--
-- TOC entry 300 (class 1259 OID 17411)
-- Name: seq_country; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_country
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6309 (class 0 OID 0)
-- Dependencies: 300
-- Name: seq_country; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_country OWNED BY geoinfo.country.country_id;


--
-- TOC entry 301 (class 1259 OID 17412)
-- Name: seq_countryborder; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countryborder
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6311 (class 0 OID 0)
-- Dependencies: 301
-- Name: seq_countryborder; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countryborder OWNED BY geoinfo.countryborder.countryborder_id;


--
-- TOC entry 302 (class 1259 OID 17413)
-- Name: seq_countrycallcode; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countrycallcode
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6313 (class 0 OID 0)
-- Dependencies: 302
-- Name: seq_countrycallcode; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countrycallcode OWNED BY geoinfo.countrycallcode.countrycallcode_id;


--
-- TOC entry 303 (class 1259 OID 17414)
-- Name: seq_countrycurrency; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countrycurrency
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6315 (class 0 OID 0)
-- Dependencies: 303
-- Name: seq_countrycurrency; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countrycurrency OWNED BY geoinfo.countrycurrency.countrycurrency_id;


--
-- TOC entry 304 (class 1259 OID 17415)
-- Name: seq_countrylanguage; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countrylanguage
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6317 (class 0 OID 0)
-- Dependencies: 304
-- Name: seq_countrylanguage; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countrylanguage OWNED BY geoinfo.countrylanguage.countrylanguage_id;


--
-- TOC entry 305 (class 1259 OID 17416)
-- Name: seq_countryregionalbloc; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countryregionalbloc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6319 (class 0 OID 0)
-- Dependencies: 305
-- Name: seq_countryregionalbloc; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countryregionalbloc OWNED BY geoinfo.countryregionalbloc.countryregionalbloc_id;


--
-- TOC entry 306 (class 1259 OID 17417)
-- Name: seq_countrytimezone; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countrytimezone
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6321 (class 0 OID 0)
-- Dependencies: 306
-- Name: seq_countrytimezone; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countrytimezone OWNED BY geoinfo.countrytimezone.countrytimezone_id;


--
-- TOC entry 307 (class 1259 OID 17418)
-- Name: seq_countrytopleveldomain; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countrytopleveldomain
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6323 (class 0 OID 0)
-- Dependencies: 307
-- Name: seq_countrytopleveldomain; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countrytopleveldomain OWNED BY geoinfo.countrytopleveldomain.countrytopleveldomain_id;


--
-- TOC entry 308 (class 1259 OID 17419)
-- Name: seq_countrytranslation; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_countrytranslation
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6325 (class 0 OID 0)
-- Dependencies: 308
-- Name: seq_countrytranslation; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_countrytranslation OWNED BY geoinfo.countrytranslation.countrytranslation_id;


--
-- TOC entry 309 (class 1259 OID 17420)
-- Name: seq_currency; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_currency
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6327 (class 0 OID 0)
-- Dependencies: 309
-- Name: seq_currency; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_currency OWNED BY geoinfo.currency.currency_id;


--
-- TOC entry 310 (class 1259 OID 17421)
-- Name: seq_dataset; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_dataset
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6329 (class 0 OID 0)
-- Dependencies: 310
-- Name: seq_dataset; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_dataset OWNED BY geoinfo.dataset.dataset_id;


--
-- TOC entry 311 (class 1259 OID 17422)
-- Name: seq_demonym; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_demonym
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6331 (class 0 OID 0)
-- Dependencies: 311
-- Name: seq_demonym; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_demonym OWNED BY geoinfo.demonym.demonym_id;


--
-- TOC entry 312 (class 1259 OID 17423)
-- Name: seq_domain; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_domain
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6333 (class 0 OID 0)
-- Dependencies: 312
-- Name: seq_domain; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_domain OWNED BY geoinfo.domain.domain_id;


--
-- TOC entry 313 (class 1259 OID 17424)
-- Name: seq_language; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_language
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6335 (class 0 OID 0)
-- Dependencies: 313
-- Name: seq_language; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_language OWNED BY geoinfo.language.language_id;


--
-- TOC entry 314 (class 1259 OID 17425)
-- Name: seq_region; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_region
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6337 (class 0 OID 0)
-- Dependencies: 314
-- Name: seq_region; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_region OWNED BY geoinfo.region.region_id;


--
-- TOC entry 315 (class 1259 OID 17426)
-- Name: seq_regionalbloc; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_regionalbloc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6339 (class 0 OID 0)
-- Dependencies: 315
-- Name: seq_regionalbloc; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_regionalbloc OWNED BY geoinfo.regionalbloc.regionalbloc_id;


--
-- TOC entry 316 (class 1259 OID 17427)
-- Name: seq_regionalblocname; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_regionalblocname
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6341 (class 0 OID 0)
-- Dependencies: 316
-- Name: seq_regionalblocname; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_regionalblocname OWNED BY geoinfo.regionalblocname.regionalblocname_id;


--
-- TOC entry 317 (class 1259 OID 17428)
-- Name: seq_regionalblocother; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_regionalblocother
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6343 (class 0 OID 0)
-- Dependencies: 317
-- Name: seq_regionalblocother; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_regionalblocother OWNED BY geoinfo.regionalblocother.regionalblocother_id;


--
-- TOC entry 318 (class 1259 OID 17429)
-- Name: subregion; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.subregion (
    subregion_id smallint NOT NULL,
    subregion_name character varying NOT NULL
);


--
-- TOC entry 319 (class 1259 OID 17434)
-- Name: seq_subregion; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_subregion
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6346 (class 0 OID 0)
-- Dependencies: 319
-- Name: seq_subregion; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_subregion OWNED BY geoinfo.subregion.subregion_id;


--
-- TOC entry 320 (class 1259 OID 17435)
-- Name: timezone; Type: TABLE; Schema: geoinfo; Owner: -
--

CREATE TABLE geoinfo.timezone (
    timezone_id smallint NOT NULL,
    timezone_timezone character varying NOT NULL
);


--
-- TOC entry 321 (class 1259 OID 17440)
-- Name: seq_timezone; Type: SEQUENCE; Schema: geoinfo; Owner: -
--

CREATE SEQUENCE geoinfo.seq_timezone
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6349 (class 0 OID 0)
-- Dependencies: 321
-- Name: seq_timezone; Type: SEQUENCE OWNED BY; Schema: geoinfo; Owner: -
--

ALTER SEQUENCE geoinfo.seq_timezone OWNED BY geoinfo.timezone.timezone_id;


--
-- TOC entry 322 (class 1259 OID 17441)
-- Name: domsync; Type: TABLE; Schema: libdom; Owner: -
--

CREATE TABLE libdom.domsync (
    classname character varying NOT NULL,
    columnname character varying NOT NULL,
    domain character varying NOT NULL,
    comment text,
    CONSTRAINT domsync_classname_check CHECK (((classname)::regclass IS NOT NULL))
);


--
-- TOC entry 323 (class 1259 OID 17447)
-- Name: constvalue; Type: TABLE; Schema: map; Owner: -
--

CREATE TABLE map.constvalue (
    constvalue_name name NOT NULL,
    constvalue_type regtype NOT NULL,
    constvalue_value text NOT NULL,
    constvalue_editable boolean DEFAULT false NOT NULL,
    constvalue_descrision character varying,
    constvalue_comment character varying
);


--
-- TOC entry 6351 (class 0 OID 0)
-- Dependencies: 323
-- Name: TABLE constvalue; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON TABLE map.constvalue IS 'Essa entidade serve para armazenar os valores das constantes';


--
-- TOC entry 6352 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN constvalue.constvalue_name; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON COLUMN map.constvalue.constvalue_name IS 'Corresponde ao nome da constante';


--
-- TOC entry 6353 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN constvalue.constvalue_type; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON COLUMN map.constvalue.constvalue_type IS 'Corresponde ao tipo da constante';


--
-- TOC entry 6354 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN constvalue.constvalue_value; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON COLUMN map.constvalue.constvalue_value IS 'Corresponde ao valor da constante';


--
-- TOC entry 6355 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN constvalue.constvalue_editable; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON COLUMN map.constvalue.constvalue_editable IS 'Esse atributo indica se a constante pode ser editavel';


--
-- TOC entry 6356 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN constvalue.constvalue_descrision; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON COLUMN map.constvalue.constvalue_descrision IS 'Corresponde a descrição da constante';


--
-- TOC entry 6357 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN constvalue.constvalue_comment; Type: COMMENT; Schema: map; Owner: -
--

COMMENT ON COLUMN map.constvalue.constvalue_comment IS 'Commentario para a constante';


--
-- TOC entry 381 (class 1259 OID 169255)
-- Name: raw; Type: TABLE; Schema: patch; Owner: -
--

CREATE TABLE patch.raw (
    raw_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    raw_text text NOT NULL,
    raw_match text NOT NULL
);


--
-- TOC entry 383 (class 1259 OID 169264)
-- Name: revision; Type: TABLE; Schema: patch; Owner: -
--

CREATE TABLE patch.revision (
    file character varying,
    identifier character varying,
    ref character varying GENERATED ALWAYS AS (patch.ref(file, identifier)) STORED NOT NULL,
    _raw_uid uuid NOT NULL,
    force smallint DEFAULT 0 NOT NULL,
    flags text[] DEFAULT ARRAY[]::text[] NOT NULL,
    configs jsonb DEFAULT jsonb_build_object() NOT NULL,
    status smallint DEFAULT 2 NOT NULL,
    connection character varying,
    seq integer NOT NULL,
    version integer DEFAULT 0 NOT NULL,
    date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);


--
-- TOC entry 382 (class 1259 OID 169263)
-- Name: revision_seq_seq; Type: SEQUENCE; Schema: patch; Owner: -
--

CREATE SEQUENCE patch.revision_seq_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6359 (class 0 OID 0)
-- Dependencies: 382
-- Name: revision_seq_seq; Type: SEQUENCE OWNED BY; Schema: patch; Owner: -
--

ALTER SEQUENCE patch.revision_seq_seq OWNED BY patch.revision.seq;


--
-- TOC entry 369 (class 1259 OID 94082)
-- Name: lancamento; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.lancamento (
    id integer,
    cred numeric,
    deb numeric
);


--
-- TOC entry 375 (class 1259 OID 152272)
-- Name: agg; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.agg (
    key text NOT NULL,
    priority integer,
    function text,
    types text[],
    format text,
    label text,
    name text,
    rename text,
    description text,
    simple text,
    expression text,
    over text
);


--
-- TOC entry 371 (class 1259 OID 128725)
-- Name: filter; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.filter (
    filter_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    filter_parametrized_uid uuid NOT NULL,
    filter_name character varying NOT NULL,
    filter_props jsonb DEFAULT jsonb_build_object() NOT NULL,
    filter_require boolean DEFAULT false NOT NULL,
    filter_column character varying NOT NULL,
    filter_type character varying NOT NULL,
    filter_opr character varying NOT NULL,
    filter_basevalue character varying,
    filter_valuemode integer DEFAULT (libdom.get('report_filter_filter_valuemode_raw'::name))::smallint NOT NULL,
    filter_increment character varying,
    filter_grants character varying[] NOT NULL,
    filter_state smallint DEFAULT (libdom.get('report_filter_state_active'::name))::smallint NOT NULL,
    filter_date timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    filter_update timestamp with time zone,
    filter_user_id character varying NOT NULL,
    filter_user_update character varying,
    filter_espaco_auth character varying NOT NULL,
    _branch_uid character varying NOT NULL
);


--
-- TOC entry 377 (class 1259 OID 152286)
-- Name: mask; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.mask (
    type text[] DEFAULT ARRAY[]::text[] NOT NULL,
    mask text NOT NULL,
    name text,
    description character varying,
    representation text,
    function text,
    priority smallint
);


--
-- TOC entry 370 (class 1259 OID 128712)
-- Name: parametrized; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.parametrized (
    parametrized_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    parametrized_name character varying NOT NULL,
    parametrized_source character varying NOT NULL,
    parametrized_columns jsonb DEFAULT jsonb_build_array() NOT NULL,
    parametrized_groups jsonb DEFAULT jsonb_build_array() NOT NULL,
    parametrized_props jsonb DEFAULT jsonb_build_object() NOT NULL,
    parametrized_grants character varying[] NOT NULL,
    parametrized_state smallint DEFAULT (libdom.get('report_filter_state_active'::name))::smallint NOT NULL,
    parametrized_date timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    parametrized_update timestamp with time zone,
    parametrized_user_id character varying NOT NULL,
    parametrized_espaco_auth character varying NOT NULL,
    parametrized_user_update character varying,
    _branch_uid character varying NOT NULL
);


--
-- TOC entry 372 (class 1259 OID 152236)
-- Name: report; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.report (
    report_name character varying,
    report_source character varying NOT NULL,
    report_columns text[],
    report_priority integer,
    report_active boolean DEFAULT true NOT NULL
);


--
-- TOC entry 376 (class 1259 OID 152279)
-- Name: talias; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.talias (
    type text NOT NULL,
    alias text[]
);


--
-- TOC entry 373 (class 1259 OID 152249)
-- Name: template; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.template (
    type character varying,
    name character varying,
    configs jsonb
);


--
-- TOC entry 378 (class 1259 OID 152296)
-- Name: var; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.var (
    var_key text NOT NULL,
    var_description text,
    var_type text,
    var_expression text
);


--
-- TOC entry 374 (class 1259 OID 152259)
-- Name: vcolumn; Type: TABLE; Schema: report; Owner: -
--

CREATE TABLE report.vcolumn (
    source character varying NOT NULL,
    name character varying NOT NULL,
    "position" smallint,
    show boolean DEFAULT false,
    init boolean DEFAULT false,
    format character varying,
    filter jsonb DEFAULT jsonb_build_array(),
    agg jsonb DEFAULT jsonb_build_array(),
    noagg boolean DEFAULT false,
    gen jsonb DEFAULT jsonb_build_array(),
    rename character varying,
    type character varying
);


--
-- TOC entry 324 (class 1259 OID 17515)
-- Name: entrada; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.entrada (
    entrada_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    entrada_artigo_id uuid NOT NULL,
    entrada_espaco_destino uuid NOT NULL,
    entrada_espaco_auth uuid NOT NULL,
    entrada_colaborador_id uuid NOT NULL,
    entrada_colaborador_atualizacao uuid,
    entrada_custounitario double precision,
    entrada_quantidade double precision NOT NULL,
    entrada_quantidadeinicial double precision DEFAULT 0 NOT NULL,
    entrada_quantidadefinal double precision DEFAULT 0,
    entrada_descricao character varying,
    entrada_estado smallint DEFAULT (map.get('entrada_estado_ativo'::name))::smallint NOT NULL,
    entrada_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    entrada_dataatualizacao timestamp with time zone,
    entrada_guia_id uuid NOT NULL,
    _branch_uid uuid,
    entrada_lote character varying,
    entrada_validade date,
    entrada_metadata json
);


--
-- TOC entry 6361 (class 0 OID 0)
-- Dependencies: 324
-- Name: TABLE entrada; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.entrada IS 'Entrada - Registra todas as entradas (compras) feito sobre um artigo para um determinado stock';


--
-- TOC entry 6362 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_id IS 'Identificador único da entrada';


--
-- TOC entry 6363 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_artigo_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_artigo_id IS 'Identificador do artigo o qual está se entregado';


--
-- TOC entry 6364 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_espaco_auth; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_espaco_auth IS 'Identificador do espaço a qual o artigo entrou';


--
-- TOC entry 6365 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_colaborador_id IS 'Identificador do colaborador responsavel pela entrega do artigo';


--
-- TOC entry 6366 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização da entrega';


--
-- TOC entry 6367 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_custounitario; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_custounitario IS 'Corresponde ao montante do custo da entrada (montante de custo da compra)';


--
-- TOC entry 6368 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_quantidade; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_quantidade IS 'Corresponde a quantidade do artigo entrado em stock';


--
-- TOC entry 6369 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_quantidadeinicial; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_quantidadeinicial IS 'Corresponde a quantidade de artigo inicialmente no stock antes da entrada';


--
-- TOC entry 6370 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_quantidadefinal; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_quantidadefinal IS 'Corresponde a quantidade de artigo disponivél no stock depois da entrada';


--
-- TOC entry 6371 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_descricao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_descricao IS 'Corresponde a observação da entrada';


--
-- TOC entry 6372 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_estado IS 'Corresponde ao estado da entrada
<ul>
  <li> 1  - Ativo </li>
  <li> -1 - Anulado </li>
</ul>';


--
-- TOC entry 6373 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_dataregistro IS 'Corresponde ao isntante em que a entrada foi registrada';


--
-- TOC entry 6374 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN entrada.entrada_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.entrada.entrada_dataatualizacao IS 'Corresponde ao instante em que a entrada foi atualizada';


--
-- TOC entry 384 (class 1259 OID 169523)
-- Name: vreport_balanco; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_balanco AS
 WITH _const(maguita_conta_estado_fechado, maguita_venda_estado_fechado) AS (
         SELECT (map.get('maguita_conta_estado_fechado'::name))::smallint AS get,
            (map.get('maguita_venda_estado_fechado'::name))::smallint AS get
        ), __lancamento AS (
         SELECT l.ordem,
            l.ordem_grupo,
            l.cd,
            l.credito,
            l.debito,
            l.valor,
            l.entrada,
            l.saldo,
            l.resumo,
            l.acomulacao,
            l.regula_acumulacao,
            l.regula_montante,
            l.regula,
            l.regula_id,
            l.regula_refid,
            l.cliente_id,
            l.tgrupo_id,
            l.lancamento_id,
            l.lancamento_refid,
            l.lancamento_ref,
            l.lancamento_class,
            l.lancamento_doc,
            l.lancamento_data,
            l.lancamento_time,
            l.lancamento_sequencia
           FROM tweeks.__lancamento_regularizacao() l(ordem, ordem_grupo, cd, credito, debito, valor, entrada, saldo, resumo, acomulacao, regula_acumulacao, regula_montante, regula, regula_id, regula_refid, cliente_id, tgrupo_id, lancamento_id, lancamento_refid, lancamento_ref, lancamento_class, lancamento_doc, lancamento_data, lancamento_time, lancamento_sequencia)
        ), __receitas AS (
         SELECT art.artigo_id,
            art.artigo_nome,
            art.artigo_codigo,
            cla.classe_id,
            cla.classe_nome,
            es.espaco_id,
            es.espaco_nome,
            ve.venda_montantecomimposto,
            ve.venda_quantidade,
            l.regula_montante AS conta_montanteefetivo,
            (l.regula_montante / ct.conta_montante) AS conta_percentageefetiva,
            ((l.regula_montante / ct.conta_montante) * ve.venda_montantecomimposto) AS venda_montanteefetivo,
            ct.conta_data,
            ct._branch_uid
           FROM _const,
            (((((tweeks.conta ct
             JOIN tweeks.venda ve ON (((ct.conta_id = ve.venda_conta_id) AND (ve.venda_venda_id IS NULL))))
             JOIN tweeks.espaco es ON ((ct.conta_espaco_auth = es.espaco_id)))
             JOIN tweeks.artigo art ON ((ve.venda_artigo_id = art.artigo_id)))
             JOIN tweeks.classe cla ON ((art.artigo_classe_id = cla.classe_id)))
             JOIN __lancamento l ON ((ct.conta_id = l.lancamento_refid)))
          WHERE ((ct.conta_estado = _const.maguita_conta_estado_fechado) AND (ve.venda_estado = _const.maguita_venda_estado_fechado))
        ), ___despesas AS (
         SELECT art.artigo_id,
            art.artigo_nome,
            art.artigo_codigo,
            cla.classe_id,
            cla.classe_nome,
            es.espaco_id,
            es.espaco_nome,
            g.guia_date AS entrada_data,
            g.guia_documentoperacao AS entrada_codigofatura,
            en.entrada_quantidade,
            en.entrada_custounitario AS quantidade_custounidade,
            (en.entrada_custounitario * en.entrada_quantidade) AS entrada_montanteefetivo,
            (0.0)::double precision AS entrada_montanteprevisto,
            en._branch_uid
           FROM ((((tweeks.entrada en
             JOIN tweeks.guia g ON ((en.entrada_guia_id = g.guia_uid)))
             JOIN tweeks.espaco es ON ((en.entrada_espaco_destino = es.espaco_id)))
             JOIN tweeks.artigo art ON ((en.entrada_artigo_id = art.artigo_id)))
             JOIN tweeks.classe cla ON ((art.artigo_classe_id = cla.classe_id)))
        ), __union AS (
         SELECT COALESCE(__rec.artigo_id, _desps.artigo_id) AS artigo_id,
            COALESCE(__rec.artigo_nome, _desps.artigo_nome) AS artigo_nome,
            COALESCE(__rec.artigo_codigo, _desps.artigo_codigo) AS artigo_codigo,
            COALESCE(__rec.classe_id, _desps.classe_id) AS classe_id,
            COALESCE(__rec.classe_nome, _desps.classe_nome) AS classe_nome,
            COALESCE(__rec.espaco_id, _desps.espaco_id) AS espaco_id,
            COALESCE(__rec.espaco_nome, _desps.espaco_nome) AS espaco_nome,
            COALESCE(__rec._branch_uid, _desps._branch_uid) AS _branch_uid,
            COALESCE((__rec.conta_data)::timestamp with time zone, _desps.entrada_data) AS data,
            COALESCE(_desps.entrada_quantidade, (0.0)::double precision) AS despesa_quantidade,
            COALESCE(_desps.entrada_montanteefetivo, (0.0)::double precision) AS despesa_montanteefetivo,
            COALESCE(_desps.entrada_montanteprevisto, (0.0)::double precision) AS despesa_montanteprevisto,
            COALESCE(__rec.venda_quantidade, (0.0)::double precision) AS receita_quantidade,
            COALESCE(__rec.venda_montanteefetivo, (0.0)::double precision) AS receita_montanteefetivo,
            COALESCE((__rec.venda_montantecomimposto - __rec.venda_montanteefetivo), (0.0)::double precision) AS receita_montanteprevisto
           FROM (__receitas __rec
             FULL JOIN ___despesas _desps ON (((__rec.conta_data = _desps.entrada_data) AND (__rec.artigo_id = _desps.artigo_id) AND (__rec.classe_id = _desps.classe_id) AND (__rec.espaco_id = _desps.espaco_id))))
        ), __resultado AS (
         SELECT _un.artigo_id,
            _un.artigo_nome AS "ARTIGO",
            _un.artigo_codigo AS "CÓDIGO",
            _un.classe_id,
            _un.espaco_id,
            _un.espaco_nome AS "ARMAZÉM",
            _un._branch_uid,
            _un.classe_nome AS "CATEGORIA",
            _un.data AS "DATA",
            sum(_un.despesa_quantidade) AS "QT. ENTRADA",
            sum(_un.receita_montanteefetivo) AS "$ RECEITA EFET.",
            sum(_un.receita_montanteprevisto) AS "$ RECEITA PREV.",
            sum((_un.receita_montanteefetivo + _un.receita_montanteprevisto)) AS "$ RECEITA ESTI.",
            sum(_un.receita_quantidade) AS "QT. SAÍDA",
            sum(_un.despesa_montanteefetivo) AS "$ DESPESA EFET.",
            sum(_un.despesa_montanteprevisto) AS "$ DESPESA PREV.",
            sum((_un.despesa_montanteefetivo + _un.despesa_montanteprevisto)) AS "$ DESPESA ESTI.",
            sum((_un.receita_montanteprevisto - _un.despesa_montanteprevisto)) AS "$ REST. PREV.",
            sum((_un.receita_montanteefetivo - _un.despesa_montanteefetivo)) AS "$ REST. EFET.",
            sum(((_un.receita_montanteefetivo + _un.receita_montanteprevisto) - (_un.despesa_montanteefetivo + _un.despesa_montanteprevisto))) AS "$ REST. ESTI.",
            sum((_un.despesa_quantidade - _un.receita_quantidade)) AS "REST. QT."
           FROM __union _un
          GROUP BY _un.artigo_id, _un.espaco_id, _un.espaco_nome, _un.artigo_nome, _un.artigo_codigo, _un.classe_id, _un.classe_nome, _un._branch_uid, _un.data
        )
 SELECT __resultado.artigo_id,
    __resultado."ARTIGO",
    __resultado."CÓDIGO",
    __resultado.classe_id,
    __resultado.espaco_id,
    __resultado."ARMAZÉM",
    __resultado._branch_uid,
    __resultado."CATEGORIA",
    __resultado."DATA",
    __resultado."QT. ENTRADA",
    __resultado."$ RECEITA EFET.",
    __resultado."$ RECEITA PREV.",
    __resultado."$ RECEITA ESTI.",
    __resultado."QT. SAÍDA",
    __resultado."$ DESPESA EFET.",
    __resultado."$ DESPESA PREV.",
    __resultado."$ DESPESA ESTI.",
    __resultado."$ REST. PREV.",
    __resultado."$ REST. EFET.",
    __resultado."$ REST. ESTI.",
    __resultado."REST. QT."
   FROM __resultado
  ORDER BY __resultado."CATEGORIA", __resultado."ARTIGO", __resultado."DATA";


--
-- TOC entry 325 (class 1259 OID 17530)
-- Name: cliente; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.cliente (
    cliente_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    cliente_colaborador_id uuid NOT NULL,
    cliente_colaborador_gerente uuid,
    cliente_colaborador_atualizacao uuid,
    cliente_espaco_auth uuid NOT NULL,
    cliente_tdocument_id smallint,
    cliente_titular character varying NOT NULL,
    cliente_nif character varying,
    cliente_documento character varying,
    cliente_mail character varying,
    cliente_contactos jsonb DEFAULT jsonb_build_array() NOT NULL,
    cliente_estado smallint DEFAULT (map.get('maguita_cliente_estado_ativo'::name))::smallint NOT NULL,
    cliente_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    cliente_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    cliente_code character varying NOT NULL,
    cliente_metadata jsonb DEFAULT jsonb_build_object() NOT NULL
);


--
-- TOC entry 326 (class 1259 OID 17540)
-- Name: deposito; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.deposito (
    deposito_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    deposito_caixa_id uuid,
    deposito_tpaga_id smallint NOT NULL,
    deposito_currency_id smallint NOT NULL,
    deposito_espaco_auth uuid NOT NULL,
    deposito_colaborador_id uuid NOT NULL,
    deposito_colaborador_atualizacao uuid,
    deposito_referencia jsonb,
    deposito_documento character varying NOT NULL,
    deposito_data date NOT NULL,
    deposito_montante double precision NOT NULL,
    deposito_montantemoeda double precision,
    deposito_taxacambio double precision,
    deposito_estado smallint DEFAULT (map.get('maguita_deposito_estado_ativo'::name))::smallint NOT NULL,
    deposito_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    deposito_dataatualizacao timestamp with time zone,
    deposito_posto_id uuid,
    deposito_cliente_id uuid NOT NULL,
    deposito_montantetroco double precision DEFAULT 0.0 NOT NULL,
    deposito_montantefinal double precision GENERATED ALWAYS AS ((deposito_montante - deposito_montantetroco)) STORED,
    deposito_docref character varying,
    deposito_observacao character varying,
    _tgrupo_id smallint NOT NULL,
    deposito_serie_id uuid,
    _branch_uid uuid,
    deposito_serie json,
    CONSTRAINT ck_desposito_montantetroco CHECK ((deposito_montantetroco < deposito_montante))
);


--
-- TOC entry 6377 (class 0 OID 0)
-- Dependencies: 326
-- Name: TABLE deposito; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.deposito IS 'Essa entidade serve para registar as amortizações feitas nas contas';


--
-- TOC entry 6378 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_id IS 'Identificador de amortização';


--
-- TOC entry 6379 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_caixa_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_caixa_id IS 'Identificador da caixa que a amortização foi feita';


--
-- TOC entry 6380 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_tpaga_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_tpaga_id IS 'Identificador da forma usada para efetuar a amortizcao';


--
-- TOC entry 6381 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_currency_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_currency_id IS 'Identificador da moeda usada para a amortização';


--
-- TOC entry 6382 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_colaborador_id IS 'Identificador do colaborador responsavél pela amortização';


--
-- TOC entry 6383 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização da amortização';


--
-- TOC entry 6384 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_referencia; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_referencia IS 'Corresponde a referencia interna/externa no qual o deposito se associa (conta_id)';


--
-- TOC entry 6385 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_documento; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_documento IS 'O documento da amortização';


--
-- TOC entry 6386 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_data; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_data IS 'A data em que a amortização foi feita';


--
-- TOC entry 6387 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_montante; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_montante IS 'O montante amortizado';


--
-- TOC entry 6388 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_montantemoeda; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_montantemoeda IS 'O montante em moeda em moeda da amortizacao';


--
-- TOC entry 6389 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_taxacambio; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_taxacambio IS 'A taxa de cambio usado no momento da operação';


--
-- TOC entry 6390 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_estado IS 'Corresponde ao estado de amortização
<ul>
  <li> 1 - Ativo </li>
</ul>';


--
-- TOC entry 6391 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_dataregistro IS 'O instante em que a amortização foi registrada no sistema';


--
-- TOC entry 6392 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_dataatualizacao IS 'O isntante em que a atualização foi atalizada pela últma vez';


--
-- TOC entry 6393 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_docref; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_docref IS 'Corresponde ao numero de documento usado externamente para o deposito';


--
-- TOC entry 6394 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN deposito.deposito_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.deposito.deposito_observacao IS 'Corresponde a observação do deposito';


--
-- TOC entry 327 (class 1259 OID 17551)
-- Name: tpaga; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tpaga (
    tpaga_id smallint NOT NULL,
    tpaga_designacao character varying NOT NULL,
    CONSTRAINT ck_tpaga_designacao_normalized CHECK (lib.str_is_normalized((tpaga_designacao)::text))
);


--
-- TOC entry 6396 (class 0 OID 0)
-- Dependencies: 327
-- Name: TABLE tpaga; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.tpaga IS '#Tipo Pagamento - Essa entidade serve para registar as diferentes formas que o pagamento pode ser feito';


--
-- TOC entry 6397 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN tpaga.tpaga_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tpaga.tpaga_id IS 'Identificador único do tipo de pagamento';


--
-- TOC entry 6398 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN tpaga.tpaga_designacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tpaga.tpaga_designacao IS 'Corresponde a designação do tipo de pagamento';


--
-- TOC entry 385 (class 1259 OID 169528)
-- Name: vreport_caixa; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_caixa AS
 WITH _const(maguita_caixa_estado_fechado, maguita_caixa_estado_ativo) AS (
         SELECT (map.get('maguita_caixa_estado_fechado'::name))::smallint AS get,
            (map.get('maguita_caixa_estado_ativo'::name))::smallint AS get
        ), __report_caixa AS (
         SELECT cx.caixa_id,
            cx.caixa_code AS "CAIXA",
            cx.caixa_montantefecho AS "$ CAP. FEC.",
            cx.caixa_montantefechoposto AS "$ CAP. FEC. POS",
            cx.caixa_montanteinicial AS "$ CAP. INI.",
            cx.caixa_montanteinicialposto AS "$ CAP. INI. POS",
            cx.caixa_quantidadecheque AS "CHEQUES",
            cx.caixa_quantidadechequeposto AS "CHEQUES POS",
            cx.caixa_observacao AS "OBSERVAÇÃO",
            cx.caixa_dataregistro AS "ABERTURA",
                CASE
                    WHEN (coclose.colaborador_id IS NOT NULL) THEN cx.caixa_dataatualizacao
                    ELSE NULL::timestamp with time zone
                END AS "FECHO",
                CASE
                    WHEN (cx.caixa_estado = _const.maguita_caixa_estado_fechado) THEN 'FECHADO'::text
                    WHEN (cx.caixa_estado = _const.maguita_caixa_estado_ativo) THEN 'ABERTA'::text
                    ELSE NULL::text
                END AS "ESTADO CAIXA",
            pos.posto_designacao AS "POSTO",
            e.espaco_nome AS "ARMAZÉM",
            owner.colaborador_id AS colaborador_owner,
            owner.colaborador_nome AS "PROPRIETARIO",
            coclose.colaborador_id AS colaborador_close,
            coclose.colaborador_nome AS "ENCERADOR",
            opr.colaborador_id AS colaborador_operador,
            opr.colaborador_nome AS "OPERADOR",
            COALESCE(ct.conta_titularnif, cli.cliente_titular) AS "TITULAR",
            COALESCE(ct.conta_titularnif, cli.cliente_nif) AS "NIF",
            de.deposito_documento AS "P. RECIBO",
            tp.tpaga_designacao AS "P. MODALIDADE",
            de.deposito_docref AS "P. DOCUMENTO",
            cur.currency_code AS "P. MOEDA",
            de.deposito_montantemoeda AS "P. $RECEBIDO",
            de.deposito_taxacambio AS "P. $CÂMBIO",
            de.deposito_montante AS "P. $REC. x $CÂM.",
            de.deposito_montantetroco AS "P. $TROCO",
            de.deposito_montantefinal AS "P. $M. FINAL",
            de.deposito_data AS "P. DATA",
            de.deposito_dataregistro AS "ENTRADA",
            cli.cliente_id,
            pos.posto_id,
            e.espaco_id,
            de.deposito_id,
            cur.currency_id,
            cx.caixa_estado,
            tp.tpaga_id,
            cx._branch_uid
           FROM (((((((((((_const
             JOIN tweeks.caixa cx ON (true))
             JOIN tweeks.posto pos ON ((cx.caixa_posto_id = pos.posto_id)))
             JOIN tweeks.espaco e ON ((pos.posto_espaco_auth = e.espaco_id)))
             JOIN auth.colaborador owner ON ((cx.caixa_colaborador_id = owner.colaborador_id)))
             LEFT JOIN auth.colaborador coclose ON (((cx.caixa_colaborador_atualizacao = coclose.colaborador_id) AND (cx.caixa_estado = _const.maguita_caixa_estado_fechado))))
             LEFT JOIN tweeks.deposito de ON ((cx.caixa_id = de.deposito_caixa_id)))
             LEFT JOIN tweeks.cliente cli ON ((cli.cliente_id = de.deposito_cliente_id)))
             LEFT JOIN tweeks.conta ct ON (((cli.cliente_id = ct.conta_cliente_id) AND (ct.conta_id = ((de.deposito_referencia ->> 'conta_id'::text))::uuid) AND ((ct.conta_numerofatura)::text = (de.deposito_documento)::text))))
             LEFT JOIN auth.colaborador opr ON ((de.deposito_colaborador_id = opr.colaborador_id)))
             LEFT JOIN geoinfo.currency cur ON ((de.deposito_currency_id = cur.currency_id)))
             LEFT JOIN tweeks.tpaga tp ON ((de.deposito_tpaga_id = tp.tpaga_id)))
        )
 SELECT __report_caixa.caixa_id,
    __report_caixa."CAIXA",
    __report_caixa."$ CAP. FEC.",
    __report_caixa."$ CAP. FEC. POS",
    __report_caixa."$ CAP. INI.",
    __report_caixa."$ CAP. INI. POS",
    __report_caixa."CHEQUES",
    __report_caixa."CHEQUES POS",
    __report_caixa."OBSERVAÇÃO",
    __report_caixa."ABERTURA",
    __report_caixa."FECHO",
    __report_caixa."ESTADO CAIXA",
    __report_caixa."POSTO",
    __report_caixa."ARMAZÉM",
    __report_caixa.colaborador_owner,
    __report_caixa."PROPRIETARIO",
    __report_caixa.colaborador_close,
    __report_caixa."ENCERADOR",
    __report_caixa.colaborador_operador,
    __report_caixa."OPERADOR",
    __report_caixa."TITULAR",
    __report_caixa."NIF",
    __report_caixa."P. RECIBO",
    __report_caixa."P. MODALIDADE",
    __report_caixa."P. DOCUMENTO",
    __report_caixa."P. MOEDA",
    __report_caixa."P. $RECEBIDO",
    __report_caixa."P. $CÂMBIO",
    __report_caixa."P. $REC. x $CÂM.",
    __report_caixa."P. $TROCO",
    __report_caixa."P. $M. FINAL",
    __report_caixa."P. DATA",
    __report_caixa."ENTRADA",
    __report_caixa.cliente_id,
    __report_caixa.posto_id,
    __report_caixa.espaco_id,
    __report_caixa.deposito_id,
    __report_caixa.currency_id,
    __report_caixa.caixa_estado,
    __report_caixa.tpaga_id,
    __report_caixa._branch_uid
   FROM __report_caixa;


--
-- TOC entry 328 (class 1259 OID 17562)
-- Name: lancamento; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.lancamento (
    lancamento_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    lancamento_cliente_id uuid NOT NULL,
    lancamento_tlancamento_id smallint NOT NULL,
    lancamento_colaborador_id uuid NOT NULL,
    _tgrupo_id smallint NOT NULL,
    lancamento_colaborador_atualizacao uuid,
    lancamento_espaco_auth uuid NOT NULL,
    lancamento_sequencia bigint NOT NULL,
    lancamento_referencia jsonb NOT NULL,
    lancamento_regclass character varying,
    lancamento_refid uuid,
    lancamento_documento character varying,
    lancamento_data date DEFAULT CURRENT_DATE NOT NULL,
    lancamento_descricao character varying NOT NULL,
    lancamento_valor double precision,
    lancamento_operacao smallint NOT NULL,
    lancamento_montante double precision GENERATED ALWAYS AS ((lancamento_valor * (lancamento_operacao)::double precision)) STORED,
    lancamento_credito double precision GENERATED ALWAYS AS (
CASE
    WHEN (lancamento_operacao = 1) THEN lancamento_valor
    ELSE (0)::double precision
END) STORED NOT NULL,
    lancamento_debito double precision GENERATED ALWAYS AS (
CASE
    WHEN (lancamento_operacao = '-1'::integer) THEN lancamento_valor
    ELSE (0)::double precision
END) STORED NOT NULL,
    lancamento_estado smallint DEFAULT (map.get('maguita_transacao_estado_ativo'::name))::smallint NOT NULL,
    lancamento_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    lancamento_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    lancamento_via smallint DEFAULT 1 NOT NULL,
    lancamento_mode smallint DEFAULT (map.get('maguita_lancamento_mode_automatic'::name))::smallint NOT NULL,
    CONSTRAINT ck_lancamento_operacao CHECK ((lancamento_operacao = ANY (ARRAY['-1'::integer, 1])))
);


--
-- TOC entry 329 (class 1259 OID 17577)
-- Name: tgrupo; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tgrupo (
    tgrupo_id smallint NOT NULL,
    tgrupo_desc character varying NOT NULL
);


--
-- TOC entry 330 (class 1259 OID 17582)
-- Name: tlancamento; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tlancamento (
    tlancamento_id smallint NOT NULL,
    tlancamento_desc character varying NOT NULL,
    tlancamento_operacao smallint NOT NULL
);


--
-- TOC entry 386 (class 1259 OID 169533)
-- Name: vreport_conta; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_conta AS
 WITH _const(maguita_lancamento_mode_manual, maguita_lancamento_mode_automatic, ___conta_regclass, ___deposito_regclass) AS (
         SELECT (map.get('maguita_lancamento_mode_manual'::name))::smallint AS get,
            (map.get('maguita_lancamento_mode_automatic'::name))::smallint AS get,
            cluster.__format('tweeks.conta'::regclass) AS ___conta_regclass,
            cluster.__format('tweeks.deposito'::regclass) AS ___deposito_regclass
        ), _lancamento AS (
         SELECT __lancamento_regularizacao.ordem,
            __lancamento_regularizacao.ordem_grupo,
            __lancamento_regularizacao.cd,
            __lancamento_regularizacao.credito,
            __lancamento_regularizacao.debito,
            __lancamento_regularizacao.valor,
            __lancamento_regularizacao.entrada,
            __lancamento_regularizacao.saldo,
            __lancamento_regularizacao.resumo,
            __lancamento_regularizacao.acomulacao,
            __lancamento_regularizacao.regula_acumulacao,
            __lancamento_regularizacao.regula_montante,
            __lancamento_regularizacao.regula,
            __lancamento_regularizacao.regula_id,
            __lancamento_regularizacao.regula_refid,
            __lancamento_regularizacao.cliente_id,
            __lancamento_regularizacao.tgrupo_id,
            __lancamento_regularizacao.lancamento_id,
            __lancamento_regularizacao.lancamento_refid,
            __lancamento_regularizacao.lancamento_ref,
            __lancamento_regularizacao.lancamento_class,
            __lancamento_regularizacao.lancamento_doc,
            __lancamento_regularizacao.lancamento_data,
            __lancamento_regularizacao.lancamento_time,
            __lancamento_regularizacao.lancamento_sequencia
           FROM tweeks.__lancamento_regularizacao() __lancamento_regularizacao(ordem, ordem_grupo, cd, credito, debito, valor, entrada, saldo, resumo, acomulacao, regula_acumulacao, regula_montante, regula, regula_id, regula_refid, cliente_id, tgrupo_id, lancamento_id, lancamento_refid, lancamento_ref, lancamento_class, lancamento_doc, lancamento_data, lancamento_time, lancamento_sequencia)
        ), __conta_report AS (
         SELECT l.lancamento_sequencia AS "SEQUÊNCIA",
            cli.cliente_titular AS "CLIENTE",
            cli.cliente_nif AS "NIF",
            l.lancamento_doc AS "DOCUMENTO",
            l.credito AS "$ CREDITO",
            l.debito AS "$ DEBITO",
            l.valor AS "$ MONTANTE",
            l.entrada AS "$ RESULTADO",
            l.regula_montante AS "$ REGULARIZADO",
            tlanc.tlancamento_desc AS "TIPO",
            tg.tgrupo_desc AS "CONTA",
                CASE
                    WHEN (lanc.lancamento_operacao = 1) THEN 'CREDITO'::text
                    WHEN (lanc.lancamento_operacao = '-1'::integer) THEN 'DEBITO'::text
                    ELSE NULL::text
                END AS "OPERAÇÃO",
                CASE
                    WHEN (lanc.lancamento_mode = _const.maguita_lancamento_mode_manual) THEN 'MANUAL'::text
                    WHEN (lanc.lancamento_mode = _const.maguita_lancamento_mode_automatic) THEN 'AUTOMATICO'::text
                    ELSE NULL::text
                END AS "MODO",
            col.colaborador_nome AS "COLABORADOR",
            l.lancamento_data AS "DATA",
            l.lancamento_time AS "REGISTRO",
            lanc.lancamento_descricao AS "OBSERVAÇÃO",
            lanc.lancamento_id,
            cli.cliente_id,
                CASE
                    WHEN ((lanc.lancamento_regclass)::text = (_const.___conta_regclass)::text) THEN lanc.lancamento_refid
                    ELSE NULL::uuid
                END AS _conta_id,
                CASE
                    WHEN ((lanc.lancamento_regclass)::text = (_const.___deposito_regclass)::text) THEN lanc.lancamento_refid
                    ELSE NULL::uuid
                END AS _deposito_id,
            tg.tgrupo_id,
            tlanc.tlancamento_id,
            col.colaborador_id,
            lanc.lancamento_mode,
            lanc._branch_uid,
            lanc.lancamento_operacao
           FROM ((((((_const
             JOIN _lancamento l ON (true))
             JOIN tweeks.lancamento lanc ON ((l.lancamento_id = lanc.lancamento_id)))
             JOIN tweeks.tlancamento tlanc ON ((lanc.lancamento_tlancamento_id = tlanc.tlancamento_id)))
             JOIN tweeks.cliente cli ON ((l.cliente_id = cli.cliente_id)))
             JOIN tweeks.tgrupo tg ON ((lanc._tgrupo_id = tg.tgrupo_id)))
             JOIN auth.colaborador col ON ((lanc.lancamento_colaborador_id = col.colaborador_id)))
          ORDER BY l.lancamento_sequencia
        )
 SELECT __conta_report."SEQUÊNCIA",
    __conta_report."CLIENTE",
    __conta_report."NIF",
    __conta_report."DOCUMENTO",
    __conta_report."$ CREDITO",
    __conta_report."$ DEBITO",
    __conta_report."$ MONTANTE",
    __conta_report."$ RESULTADO",
    __conta_report."$ REGULARIZADO",
    __conta_report."TIPO",
    __conta_report."CONTA",
    __conta_report."OPERAÇÃO",
    __conta_report."MODO",
    __conta_report."COLABORADOR",
    __conta_report."DATA",
    __conta_report."REGISTRO",
    __conta_report."OBSERVAÇÃO",
    __conta_report.lancamento_id,
    __conta_report.cliente_id,
    __conta_report._conta_id,
    __conta_report._deposito_id,
    __conta_report.tgrupo_id,
    __conta_report.tlancamento_id,
    __conta_report.colaborador_id,
    __conta_report.lancamento_mode,
    __conta_report._branch_uid,
    __conta_report.lancamento_operacao
   FROM __conta_report;


--
-- TOC entry 331 (class 1259 OID 17592)
-- Name: tserie; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tserie (
    tserie_id smallint NOT NULL,
    tserie_desc character varying NOT NULL,
    tserie_code character varying,
    tserie_seqlimit smallint DEFAULT 6 NOT NULL,
    tserie_numlimit smallint DEFAULT 7 NOT NULL
);


--
-- TOC entry 387 (class 1259 OID 169538)
-- Name: vreport_fatura; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_fatura AS
 WITH _const(maguita_conta_estado_fechado, maguita_conta_estado_aberto, maguita_conta_estado_anulado) AS (
         SELECT (map.get('maguita_conta_estado_fechado'::name))::smallint AS get,
            (map.get('maguita_conta_estado_aberto'::name))::smallint AS get,
            (map.get('maguita_conta_estado_anulado'::name))::smallint AS get
        )
 SELECT ct.conta_id,
    ct.conta_data AS "DATA",
    (ct.conta_dataregistro)::date AS "REGISTO",
    ct.conta_datafecho AS "FECHO",
    ct.conta_numerofatura AS "FATURA",
        CASE
            WHEN ct.conta_proforma THEN 'SIM'::text
            ELSE 'NÃO'::text
        END AS "PROFOMA",
    ct.conta_proforma,
        CASE
            WHEN (ct.conta_estado = _const.maguita_conta_estado_fechado) THEN 'FECHADO'::text
            WHEN (ct.conta_estado = _const.maguita_conta_estado_aberto) THEN 'ABERTO'::text
            ELSE NULL::text
        END AS "ESTADO",
    ct.conta_numero AS "Nº CONTA",
    ct.conta_imprensa AS "INPRESSÕES",
    ct.conta_proformavencimento AS "PROF. VENCIMENTO",
    ct.conta_estado,
    tc.tgrupo_id,
    ct._branch_uid,
    tc.tgrupo_desc AS "TIPO CONTA",
    ct.conta_montante AS "$ MONTANTE",
    ct.conta_desconto AS "$ DESCONTO",
    (ct.conta_montante - ct.conta_desconto) AS "$ PAGAR",
    c.cliente_id,
    c.cliente_titular AS "CLIENTE",
    c.cliente_nif AS "NIF",
    p.posto_id,
    p.posto_designacao AS "POSTO",
    e.espaco_id,
    e.espaco_nome AS "ARMAZÉM",
    e.espaco_codigo AS "CÓDIGO AR.",
    col_vend.colaborador_nome AS "VENDEDOR",
    col_open.colaborador_nome AS "ABERTURA",
    s.serie_numero AS "Nº SERIE",
    s.serie_designacao AS "SERIE",
    ts.tserie_desc AS "TIPO SERIE",
    col_open.colaborador_id AS colaborador_abertura,
    col_vend.colaborador_id AS colaborador_vendor,
    ts.tserie_id,
    s.serie_id
   FROM _const,
    ((((((((tweeks.conta ct
     JOIN tweeks.tgrupo tc ON ((ct._tgrupo_id = tc.tgrupo_id)))
     JOIN tweeks.posto p ON ((ct.conta_posto_fecho = p.posto_id)))
     JOIN tweeks.espaco e ON ((p.posto_espaco_auth = e.espaco_id)))
     JOIN auth.colaborador col_open ON ((ct.conta_colaborador_id = col_open.colaborador_id)))
     LEFT JOIN auth.colaborador col_vend ON ((ct.conta_colaborador_fecho = col_vend.colaborador_id)))
     LEFT JOIN tweeks.serie s ON ((ct.conta_serie_id = s.serie_id)))
     LEFT JOIN tweeks.cliente c ON ((ct.conta_cliente_id = c.cliente_id)))
     LEFT JOIN tweeks.tserie ts ON ((s.serie_tserie_id = ts.tserie_id)))
  WHERE (ct.conta_estado <> _const.maguita_conta_estado_anulado);


--
-- TOC entry 332 (class 1259 OID 17604)
-- Name: fluxo; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.fluxo (
    fluxo_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    fluxo_toperacao_id smallint NOT NULL,
    fluxo_artigo_in uuid,
    fluxo_artigo_out uuid,
    fluxo_espaco_in uuid,
    fluxo_espaco_out uuid,
    fluxo_espaco_auth uuid NOT NULL,
    fluxo_colaborador_id uuid,
    fluxo_colaborador_atualizacao uuid,
    fluxo_sequencia bigint NOT NULL,
    fluxo_quantidadein double precision,
    fluxo_quantidadeout double precision,
    fluxo_quantidadefinal double precision,
    fluxo_checkpoint smallint DEFAULT 1 NOT NULL,
    fluxo_data date,
    fluxo_documento character varying,
    fluxo_observacao character varying,
    fluxo_referencia jsonb,
    fluxo_regclass character varying,
    fluxo_refuid uuid,
    fluxo_estado smallint DEFAULT (map.get('maguita_fluxo_estado_ativo'::name))::smallint NOT NULL,
    fluxo_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    fluxo_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    CONSTRAINT ck_fluxo_checkpointo CHECK ((fluxo_checkpoint = ANY (ARRAY[1, 0]))),
    CONSTRAINT ck_fluxo_has_artigo CHECK (((true = (fluxo_artigo_in IS NOT NULL)) OR (true = (fluxo_artigo_out IS NOT NULL)))),
    CONSTRAINT ck_fluxo_has_espaco CHECK (((true = (fluxo_espaco_in IS NOT NULL)) OR (true = (fluxo_espaco_out IS NOT NULL)))),
    CONSTRAINT ck_fluxo_has_quantidade CHECK (((true = (fluxo_quantidadein IS NOT NULL)) OR (true = (fluxo_quantidadeout IS NOT NULL)) OR (true = (fluxo_quantidadefinal IS NOT NULL))))
);


--
-- TOC entry 333 (class 1259 OID 17617)
-- Name: toperacao; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.toperacao (
    toperacao_id smallint NOT NULL,
    toperacao_designacao character varying,
    toperacao_classe smallint DEFAULT 1 NOT NULL,
    toperacao_code character varying
);


--
-- TOC entry 6405 (class 0 OID 0)
-- Dependencies: 333
-- Name: TABLE toperacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.toperacao IS 'Essa entidade serve para armazenar os tipos de movimentos que pode ocorrer em um stock';


--
-- TOC entry 6406 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN toperacao.toperacao_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.toperacao.toperacao_id IS 'Identificador único do tipo de movimento';


--
-- TOC entry 6407 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN toperacao.toperacao_designacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.toperacao.toperacao_designacao IS 'Designação do tipo de movimento';


--
-- TOC entry 388 (class 1259 OID 169543)
-- Name: vreport_fluxo; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_fluxo AS
 SELECT top.toperacao_designacao AS "OPERAÇÃO",
        CASE
            WHEN (ain.artigo_id IS NULL) THEN (aou.artigo_nome)::text
            WHEN (aou.artigo_id IS NULL) THEN (ain.artigo_nome)::text
            WHEN (ain.artigo_id = aou.artigo_id) THEN (ain.artigo_nome)::text
            ELSE format('%s ==> %s'::text, aou.artigo_nome, ain.artigo_nome)
        END AS "ARTIGO",
        CASE
            WHEN (ein.espaco_id IS NULL) THEN (eou.espaco_nome)::text
            WHEN (eou.espaco_id IS NULL) THEN (ein.espaco_nome)::text
            WHEN (ein.espaco_id = eou.espaco_id) THEN (ein.espaco_nome)::text
            ELSE format('%s ==> %s'::text, eou.espaco_nome, ein.espaco_nome)
        END AS "ARMAZÉM",
        CASE
            WHEN (ain.artigo_id IS NULL) THEN (f.fluxo_quantidadeout)::text
            WHEN (aou.artigo_id IS NULL) THEN (f.fluxo_quantidadein)::text
            WHEN (ain.artigo_id = aou.artigo_id) THEN (f.fluxo_quantidadein)::text
            ELSE format('%s ==> %s'::text, f.fluxo_quantidadeout, f.fluxo_quantidadein)
        END AS "QT",
    f.fluxo_documento AS "DOCUMENTO",
    COALESCE(f.fluxo_data, (f.fluxo_dataregistro)::date) AS "DATA",
    c.colaborador_nome AS "COLABORADOR",
    f.fluxo_sequencia AS "SEQUENCIA",
    ain.artigo_nome AS "ART. ENTRADA",
    aou.artigo_nome AS "ART. SAÍDA",
    eou.espaco_nome AS "ARM. ORIGEM",
    ein.espaco_nome AS "ARM. DESTINO",
    COALESCE(f.fluxo_quantidadein, (0)::double precision) AS "QT+",
    COALESCE(f.fluxo_quantidadeout, (0)::double precision) AS "QT-",
    f.fluxo_dataregistro AS "REGISTO",
    f.fluxo_observacao AS "OBSERVAÇÃO",
        CASE
            WHEN (ain.artigo_id IS NULL) THEN ARRAY[aou.artigo_id]
            WHEN (aou.artigo_id IS NULL) THEN ARRAY[ain.artigo_id]
            WHEN (ain.artigo_id = aou.artigo_id) THEN ARRAY[ain.artigo_id]
            ELSE ARRAY[ain.artigo_id, aou.artigo_id]
        END AS __artigo_id,
        CASE
            WHEN (ein.espaco_id IS NULL) THEN ARRAY[eou.espaco_id]
            WHEN (eou.espaco_id IS NULL) THEN ARRAY[ein.espaco_id]
            WHEN (ein.espaco_id = eou.espaco_id) THEN ARRAY[ein.espaco_id]
            ELSE ARRAY[ein.espaco_id, eou.espaco_id]
        END AS __espaco_id,
        CASE
            WHEN (clain.classe_id IS NULL) THEN ARRAY[claout.classe_id]
            WHEN (claout.classe_id IS NULL) THEN ARRAY[clain.classe_id]
            WHEN (clain.classe_id = claout.classe_id) THEN ARRAY[clain.classe_id]
            ELSE ARRAY[clain.classe_id, claout.classe_id]
        END AS __classe_id,
    f.fluxo_referencia,
    f.fluxo_id,
    top.toperacao_id,
    ain.artigo_id AS __artigo_in,
    aou.artigo_id AS __artigo_out,
    ein.espaco_id AS __espaco_in,
    eou.espaco_id AS __espaco_out,
    clain.classe_id AS __classe_in,
    claout.classe_id AS __classe_out,
    c.colaborador_id,
    f._branch_uid
   FROM ((((((((tweeks.fluxo f
     JOIN tweeks.toperacao top ON ((f.fluxo_toperacao_id = top.toperacao_id)))
     LEFT JOIN tweeks.artigo ain ON ((f.fluxo_artigo_in = ain.artigo_id)))
     LEFT JOIN tweeks.classe clain ON ((ain.artigo_classe_id = clain.classe_id)))
     LEFT JOIN tweeks.artigo aou ON ((f.fluxo_artigo_out = aou.artigo_id)))
     LEFT JOIN tweeks.classe claout ON ((aou.artigo_classe_id = claout.classe_id)))
     LEFT JOIN tweeks.espaco ein ON ((f.fluxo_espaco_in = ein.espaco_id)))
     LEFT JOIN tweeks.espaco eou ON ((f.fluxo_espaco_out = eou.espaco_id)))
     LEFT JOIN auth.colaborador c ON ((f.fluxo_colaborador_id = c.colaborador_id)));


--
-- TOC entry 348 (class 1259 OID 17724)
-- Name: fornecedor; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.fornecedor (
    fornecedor_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    fornecedor_espaco_auth uuid NOT NULL,
    fornecedor_colaborador_id uuid NOT NULL,
    fornecedor_colaborador_atualizacao uuid,
    fornecedor_nif character varying,
    fornecedor_nome character varying,
    fornecedor_email character varying,
    fornecedor_contacto character varying,
    fornecedor_endereco character varying,
    fornecedor_estado smallint DEFAULT (map.get('maguita_fornecedor_estado_ativo'::name))::smallint NOT NULL,
    fornecedor_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    fornecedor_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    fornecedor_code character varying,
    CONSTRAINT ck_fornecedor_contacto CHECK ((lower(lib.str_nospace((fornecedor_contacto)::text)) = (fornecedor_contacto)::text)),
    CONSTRAINT ck_fornecedor_email_normalized CHECK ((lower(lib.str_nospace((fornecedor_email)::text)) = (fornecedor_email)::text)),
    CONSTRAINT ck_fornecedor_endereco_normalized CHECK (lib.str_is_normalized((fornecedor_endereco)::text)),
    CONSTRAINT ck_fornecedor_nome_normalized CHECK (lib.str_is_normalized((fornecedor_nome)::text))
);


--
-- TOC entry 6409 (class 0 OID 0)
-- Dependencies: 348
-- Name: TABLE fornecedor; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.fornecedor IS '#Fornecedor - Essa entidade armazena os fornecedores dos produtos em contacto';


--
-- TOC entry 6410 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_id IS 'Identificador único do fornecedor';


--
-- TOC entry 6411 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_colaborador_id IS 'Identificador do colaborador responsável pelo registro';


--
-- TOC entry 6412 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_colaborador_atualizacao IS 'Identificador do colaborador responsável pela última atualização';


--
-- TOC entry 6413 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_nif; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_nif IS 'NIF único do fornecedor';


--
-- TOC entry 6414 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_nome; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_nome IS 'O nome do fornecedor';


--
-- TOC entry 6415 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_email; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_email IS 'Email único do fornecedor';


--
-- TOC entry 6416 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_contacto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_contacto IS 'Corresponde ao contacto do fornecedor';


--
-- TOC entry 6417 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_endereco; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_endereco IS 'Corresponde ao endereço do fornecedor';


--
-- TOC entry 6418 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_estado IS 'Estado do fornecedor no sistema
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechado </li>
</ul>
';


--
-- TOC entry 6419 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_dataregistro IS 'Corresponde ao instante em que o fornecedor foi registrado no sistema';


--
-- TOC entry 6420 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN fornecedor.fornecedor_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.fornecedor.fornecedor_dataatualizacao IS 'Corresponde ao instante em que o fornecedor foi atualizado pela última no sistema';


--
-- TOC entry 389 (class 1259 OID 169548)
-- Name: vreport_guiaentrada; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_guiaentrada AS
 SELECT em.entrada_lote AS "LOTE",
    em.entrada_quantidade AS "QT",
    em.entrada_descricao AS "DESCRICAO",
    em.entrada_quantidadeinicial AS "QT ANTES",
    em.entrada_validade AS "VALIDADE",
    em.entrada_custounitario AS "$ UNIT",
    (em.entrada_quantidade * em.entrada_custounitario) AS "$ TOTAL",
    g.guia_date AS "DATA",
    g.guia_documentoperacao AS "DOCUMENTO",
    g.guia_numero AS "NUMERO",
    g.guia_observacao AS "OBS",
    f.fornecedor_nome AS "FORNECEDOR",
    f.fornecedor_nif AS "F. NIF",
    f.fornecedor_code AS "CÓD. FOR.",
    e.espaco_nome AS "ARMAZEM",
    e.espaco_codigo AS "CÓD. ARM.",
    a.artigo_nome AS "ARTIGO",
    a.artigo_codigo AS "CÓD. ART.",
    cla.classe_nome AS "CATEGORIA",
    cla.classe_codigo AS "CÓD. CAT.",
    em.entrada_id,
    g.guia_uid,
    f.fornecedor_id,
    e.espaco_id,
    a.artigo_id,
    cla.classe_id,
    em._branch_uid
   FROM (((((tweeks.entrada em
     JOIN tweeks.guia g ON ((em.entrada_guia_id = g.guia_uid)))
     JOIN tweeks.artigo a ON ((em.entrada_artigo_id = a.artigo_id)))
     JOIN tweeks.classe cla ON ((a.artigo_classe_id = cla.classe_id)))
     LEFT JOIN tweeks.fornecedor f ON ((f.fornecedor_id = (((g.guia_refs -> 'fornecedor'::text) ->> 'fornecedor_id'::text))::uuid)))
     LEFT JOIN tweeks.espaco e ON ((e.espaco_id = (((g.guia_refs -> 'destino'::text) ->> 'espaco_id'::text))::uuid)));


--
-- TOC entry 390 (class 1259 OID 169553)
-- Name: vreport_guiasaida; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_guiasaida AS
SELECT
    NULL::uuid AS venda_id,
    NULL::character varying AS "SERIE",
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::character varying AS "NIF",
    NULL::character varying AS "CLIENTE",
    NULL::double precision AS "$ PREÇO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::double precision AS "$ MONTANTE FINAL",
    NULL::boolean AS venda_isencao,
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::date AS "DATA",
    NULL::smallint AS _tgrupo_id,
    NULL::uuid AS conta_cliente_id,
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::uuid AS colaborador_fecho,
    NULL::uuid AS classe_id,
    NULL::character varying AS "CÓD ARTIGO",
    NULL::uuid AS _branch_uid;


--
-- TOC entry 334 (class 1259 OID 17628)
-- Name: tipoimposto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tipoimposto (
    tipoimposto_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    tipoimposto_espaco_auth uuid NOT NULL,
    tipoimposto_colaborador_id uuid NOT NULL,
    tipoimposto_colaborador_atualizacao uuid,
    tipoimposto_nome character varying NOT NULL,
    tipoimposto_codigo character varying NOT NULL,
    tipoimposto_estado smallint DEFAULT (map.get('tipoimposto_estado_ativo'::name))::smallint NOT NULL,
    tipoimposto_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    tipoimposto_dataatuzaliacao timestamp with time zone,
    tipoimposto_percentagem double precision,
    tipoimposto_valor double precision,
    _branch_uid uuid
);


--
-- TOC entry 6422 (class 0 OID 0)
-- Dependencies: 334
-- Name: TABLE tipoimposto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.tipoimposto IS 'Essa entidade serve para armazenar os impostos que devem ser aplicado aos artigos';


--
-- TOC entry 6423 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_id IS 'Identificador único do artigo';


--
-- TOC entry 6424 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_colaborador_id IS 'Identificador do colaborador responsável pelo registro do imposto';


--
-- TOC entry 6425 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_colaborador_atualizacao IS 'Identificador do último colaborador responsável pela atualização do imposto';


--
-- TOC entry 6426 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_nome; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_nome IS 'Corresponde ao nome do imposto';


--
-- TOC entry 6427 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_codigo; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_codigo IS 'Corresponde ao código do imposto';


--
-- TOC entry 6428 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_estado IS 'Corresponde ao estado do imposto
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechado </li>
</ul>';


--
-- TOC entry 6429 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_dataregistro IS 'Corresponde ao instante em que o impoto foi registrado';


--
-- TOC entry 6430 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tipoimposto.tipoimposto_dataatuzaliacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tipoimposto.tipoimposto_dataatuzaliacao IS 'Corresponde ao último instante em que o imposto foi atualizado';


--
-- TOC entry 391 (class 1259 OID 169558)
-- Name: vreport_imposto; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_imposto AS
 WITH __imposto_report AS (
         SELECT tip.tipoimposto_id,
            tip.tipoimposto_codigo AS "CODIGO",
            tip.tipoimposto_nome AS "IMPOSTO",
            art.artigo_codigo AS "CÓD. ART.",
            art.artigo_nome AS "ARTIGO",
            cla.classe_nome AS "CATEGORIA",
            cla.classe_codigo AS "CÓD. CATEGORIA",
            ct.conta_titular AS "CLIENTE",
            ct.conta_titularnif AS "NIF",
            ct.conta_numerofatura AS "FATURA",
                CASE
                    WHEN (tx.taxa_percentagem IS NOT NULL) THEN format('%s %s'::text, tx.taxa_percentagem, '%')
                    ELSE format('%s %s'::text, tx.taxa_taxa, 'STN')
                END AS "TAXA",
            ve.venda_impostoadicionar AS "+$ IMPOSTO",
            ve.venda_impostoretirar AS "-$ IMPOSTO",
            ve.venda_imposto AS "$ IMPOSTO",
                CASE
                    WHEN ve.venda_isencao THEN 'SIM'::text
                    ELSE 'NÃO'::text
                END AS "ISENÇÃO",
            ve.venda_montantesemimposto AS "$ SUBTOTAL",
            ve.venda_montantecomimposto AS "$ TOTAL",
            s.serie_id,
            s.serie_numero AS "NUM. SERIE",
            s.serie_designacao AS "SERIE",
            s.serie_numatorizacao AS "CERT. SERIE",
            ts.tserie_desc AS "TIPO SERIE",
            col.colaborador_nome AS "COLABORADOR",
            ct.conta_datafecho AS "DATA",
            (ct.conta_datafecho)::date AS _date,
            ve.venda_isencao,
            ve._branch_uid,
            col.colaborador_id,
            ts.tserie_id,
            art.artigo_id,
            ve.venda_id,
            cla.classe_id
           FROM ((((((((tweeks.tipoimposto tip
             JOIN tweeks.taxa tx ON ((tip.tipoimposto_id = tx.taxa_tipoimposto_id)))
             JOIN tweeks.venda ve ON ((tx.taxa_id = ANY (ve.venda_taxas))))
             JOIN tweeks.artigo art ON ((ve.venda_artigo_id = art.artigo_id)))
             JOIN tweeks.classe cla ON ((art.artigo_classe_id = cla.classe_id)))
             JOIN tweeks.conta ct ON ((ve.venda_conta_id = ct.conta_id)))
             JOIN auth.colaborador col ON ((ct.conta_colaborador_fecho = col.colaborador_id)))
             JOIN tweeks.serie s ON ((((ct.conta_serie ->> 'serie_id'::text))::uuid = s.serie_id)))
             JOIN tweeks.tserie ts ON ((s.serie_tserie_id = ts.tserie_id)))
        )
 SELECT __imposto_report.tipoimposto_id,
    __imposto_report."CODIGO",
    __imposto_report."IMPOSTO",
    __imposto_report."CÓD. ART.",
    __imposto_report."ARTIGO",
    __imposto_report."CATEGORIA",
    __imposto_report."CÓD. CATEGORIA",
    __imposto_report."CLIENTE",
    __imposto_report."NIF",
    __imposto_report."FATURA",
    __imposto_report."TAXA",
    __imposto_report."+$ IMPOSTO",
    __imposto_report."-$ IMPOSTO",
    __imposto_report."$ IMPOSTO",
    __imposto_report."ISENÇÃO",
    __imposto_report."$ SUBTOTAL",
    __imposto_report."$ TOTAL",
    __imposto_report.serie_id,
    __imposto_report."NUM. SERIE",
    __imposto_report."SERIE",
    __imposto_report."CERT. SERIE",
    __imposto_report."TIPO SERIE",
    __imposto_report."COLABORADOR",
    __imposto_report."DATA",
    __imposto_report._date,
    __imposto_report.venda_isencao,
    __imposto_report._branch_uid,
    __imposto_report.colaborador_id,
    __imposto_report.tserie_id,
    __imposto_report.artigo_id,
    __imposto_report.venda_id,
    __imposto_report.classe_id
   FROM __imposto_report;


--
-- TOC entry 392 (class 1259 OID 169563)
-- Name: vreport_notacredito; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_notacredito AS
SELECT
    NULL::uuid AS venda_id,
    NULL::character varying AS "DOCUMENTO",
    NULL::character varying AS "JUSTIFICATIVA",
    NULL::character varying AS "DOC. ORIGEM",
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::character varying AS "NIF",
    NULL::character varying AS "CLIENTE",
    NULL::double precision AS "$ PREÇO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::double precision AS "$ MONTANTE FINAL",
    NULL::boolean AS venda_isencao,
    NULL::text AS "ISEN.",
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::date AS "DATA",
    NULL::smallint AS tserie_id,
    NULL::character varying AS "SERIE",
    NULL::smallint AS _tgrupo_id,
    NULL::uuid AS conta_cliente_id,
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::uuid AS _branch_uid,
    NULL::uuid AS colaborador_fecho,
    NULL::uuid AS classe_id,
    NULL::uuid AS deposito_id,
    NULL::uuid AS _caixa_id,
    NULL::character varying AS "CAIXA",
    NULL::character varying AS "CÓD ARTIGO";


--
-- TOC entry 393 (class 1259 OID 169568)
-- Name: vreport_venda; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_venda AS
SELECT
    NULL::uuid AS venda_id,
    NULL::character varying AS "FATURA",
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::character varying AS "NIF",
    NULL::character varying AS "CLIENTE",
    NULL::double precision AS "$ PREÇO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::double precision AS "$ MONTANTE FINAL",
    NULL::boolean AS venda_isencao,
    NULL::text AS "ISEN.",
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::date AS "DATA",
    NULL::smallint AS tserie_id,
    NULL::character varying AS "SERIE",
    NULL::smallint AS _tgrupo_id,
    NULL::uuid AS conta_cliente_id,
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::uuid AS _branch_uid,
    NULL::uuid AS colaborador_fecho,
    NULL::uuid AS classe_id,
    NULL::uuid AS deposito_id,
    NULL::uuid AS _caixa_id,
    NULL::character varying AS "CAIXA",
    NULL::character varying AS "CÓD ARTIGO";


--
-- TOC entry 380 (class 1259 OID 168435)
-- Name: vreport_venda_artigo; Type: VIEW; Schema: report; Owner: -
--

CREATE VIEW report.vreport_venda_artigo AS
SELECT
    NULL::character varying AS "ARTIGO",
    NULL::character varying AS "CATEGORIA",
    NULL::character varying AS "CÓD. CAT.",
    NULL::character varying AS "ARMAZÉM",
    NULL::character varying AS "POSTO",
    NULL::double precision AS "QT",
    NULL::double precision AS "$ MONT.",
    NULL::double precision AS "$ EXTRAS",
    NULL::double precision AS "$ MONT+EXT",
    NULL::double precision AS "$ IMPOSTO",
    NULL::double precision AS "$ SUBTOTAL",
    NULL::double precision AS "$ TOTAL",
    NULL::text AS "IMPOSTOS",
    NULL::text AS "TAXAS",
    NULL::uuid[] AS _tipoimposto_ids,
    NULL::uuid AS artigo_id,
    NULL::smallint AS tserie_id,
    NULL::character varying AS "SERIE",
    NULL::uuid AS posto_id,
    NULL::uuid AS espaco_id,
    NULL::text AS "COLABORADOR",
    NULL::character varying AS "CAIXA",
    NULL::uuid AS _caixa_id,
    NULL::character varying AS "CÓD ARTIGO",
    NULL::uuid AS _branch_uid;


--
-- TOC entry 335 (class 1259 OID 17645)
-- Name: version; Type: TABLE; Schema: sys; Owner: -
--

CREATE TABLE sys.version (
    number integer
);


--
-- TOC entry 336 (class 1259 OID 17654)
-- Name: _vserie; Type: VIEW; Schema: tweeks; Owner: -
--

CREATE VIEW tweeks._vserie AS
 SELECT NULL::uuid AS serie_id,
    NULL::integer AS serie_sequencia,
    NULL::smallint AS serie_tserie_id,
    NULL::uuid AS serie_espaco_id,
    NULL::uuid AS serie_espaco_auth,
    NULL::uuid AS serie_espaco_branch,
    NULL::uuid AS serie_colaborador_id,
    NULL::uuid AS serie_colaborador_atualizacao,
    NULL::character varying AS serie_designacao,
    NULL::character varying AS serie_numero,
    NULL::integer AS serie_quantidade,
    NULL::smallint AS serie_estado,
    NULL::timestamp with time zone AS serie_dataregistro,
    NULL::timestamp with time zone AS serie_dataatualizacao,
    NULL::smallint AS _serie_estado;


--
-- TOC entry 337 (class 1259 OID 17658)
-- Name: acerto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.acerto (
    acerto_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    acerto_espaco_auth uuid NOT NULL,
    acerto_colaborador_id uuid NOT NULL,
    acerto_colaborador_atualizacao uuid,
    acerto_quantidade double precision NOT NULL,
    acerto_correcao double precision NOT NULL,
    acerto_quantidadeinicial double precision NOT NULL,
    acerto_observacao character varying,
    acerto_estado smallint DEFAULT (map.get('acerto_estado_ativo'::name))::smallint NOT NULL,
    acerto_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    acerto_dataatualizacao timestamp with time zone,
    acerto_oprgroup uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    acerto_artigo_id uuid,
    acerto_espaco_id uuid NOT NULL,
    _branch_uid uuid,
    acerto_codigo character varying
);


--
-- TOC entry 6433 (class 0 OID 0)
-- Dependencies: 337
-- Name: TABLE acerto; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.acerto IS 'Essa entidade serve para registar os acertos feitos no stock dos produtos';


--
-- TOC entry 6434 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_id IS 'Identificador único do acerto';


--
-- TOC entry 6435 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_colaborador_id IS 'Identificador do colaborador responsavel pelo registro do acerto';


--
-- TOC entry 6436 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_colaborador_atualizacao IS 'Identificador do colaborador que atualizou o acerto pela últma vez';


--
-- TOC entry 6437 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_quantidade; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_quantidade IS 'A quantidade do acerto (quantidade do produto declarado presente no stock)';


--
-- TOC entry 6438 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_correcao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_correcao IS 'A diferença da quantidade declarada em relação a quantidade inicial (quantidade - inicial)';


--
-- TOC entry 6439 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_quantidadeinicial; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_quantidadeinicial IS 'Quantidade de produto que estava no stock antes do acerto';


--
-- TOC entry 6440 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_observacao IS 'Observação deixada no stock';


--
-- TOC entry 6441 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_estado IS 'Corresponde ao estado de acerto
<ul>
  <li> 1 - Ativo </li>
  <li> -1 - Anulado </li>
</ul>';


--
-- TOC entry 6442 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_dataregistro IS 'Corresponde a data em que o acerto foi registrado no sistema';


--
-- TOC entry 6443 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN acerto.acerto_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.acerto.acerto_dataatualizacao IS 'Corresponde a data em que o acerto foi atualizado pela sua última vez';


--
-- TOC entry 338 (class 1259 OID 17667)
-- Name: aloca; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.aloca (
    aloca_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    aloca_posto_id uuid NOT NULL,
    aloca_espaco_destino uuid NOT NULL,
    aloca_espaco_auth uuid NOT NULL,
    aloca_colaborador_id uuid NOT NULL,
    aloca_colaborador_atualizacao uuid,
    aloca_montante double precision DEFAULT 0 NOT NULL,
    aloca_estado smallint DEFAULT (map.get('maguita_aloca_estado_ativo'::name))::smallint NOT NULL,
    aloca_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    aloca_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 339 (class 1259 OID 17674)
-- Name: branch; Type: VIEW; Schema: tweeks; Owner: -
--

CREATE VIEW tweeks.branch AS
 SELECT branch.branch_uid,
    branch.branch_tbranch_id,
    branch.branch_name,
    branch.branch_path,
    branch.branch_user,
    branch.branch_workspace,
    branch.branch_licence,
    branch.branch_grants,
    branch.branch_main_user,
    branch.branch_main_workspace,
    branch.branch_clusters,
    branch.branch_date,
    branch.branch_update,
    branch.branch_state,
    branch._branch_uid
   FROM cluster.branch;


--
-- TOC entry 340 (class 1259 OID 17678)
-- Name: branchmap; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.branchmap (
    class text NOT NULL,
    map_usr text,
    map_spc text,
    map_sch text,
    map_tbl text,
    map_brc text
);


--
-- TOC entry 341 (class 1259 OID 17683)
-- Name: cambio; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.cambio (
    cambio_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    cambio_currency_id smallint NOT NULL,
    cambio_espaco_auth uuid NOT NULL,
    cambio_colaborador_id uuid NOT NULL,
    cambio_colaborador_atualizacao uuid,
    cambio_taxa double precision,
    cambio_data date DEFAULT CURRENT_DATE NOT NULL,
    cambio_estado smallint DEFAULT (map.get('cambio_estado_ativo'::name))::smallint NOT NULL,
    cambio_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    cambio_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 6448 (class 0 OID 0)
-- Dependencies: 341
-- Name: TABLE cambio; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.cambio IS 'Essa entidade serve para armazenar os cambios registrados';


--
-- TOC entry 6449 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_id IS 'Identificador único do cambio';


--
-- TOC entry 6450 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_currency_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_currency_id IS 'Identificador da moeda do cambio';


--
-- TOC entry 6451 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_colaborador_id IS 'Identificador do colaborador responsável pelo registro do cambio';


--
-- TOC entry 6452 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_colaborador_atualizacao IS 'Identificador do colaborador responsável pela atualização do cambio';


--
-- TOC entry 6453 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_taxa; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_taxa IS 'O valor do cambio (a taxa do cambio)';


--
-- TOC entry 6454 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_data; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_data IS 'A data na qual o cambio pertence (o cambio pode ser registrado com atrazo)';


--
-- TOC entry 6455 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_estado IS 'Corresponde ao estado do cambio
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechado </li>
</ul>';


--
-- TOC entry 6456 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_dataregistro IS 'O instante em que o cambio foi registrado';


--
-- TOC entry 6457 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN cambio.cambio_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.cambio.cambio_dataatualizacao IS 'O instante em que o cambio foi atualizado (fechado)';


--
-- TOC entry 342 (class 1259 OID 17690)
-- Name: chave; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.chave (
    chave_temporarai character varying NOT NULL,
    chave_definitiva character varying,
    chave_descricao character varying,
    chave_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);


--
-- TOC entry 366 (class 1259 OID 91004)
-- Name: circular; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.circular (
    id integer NOT NULL,
    name character varying,
    code character varying
);


--
-- TOC entry 365 (class 1259 OID 91003)
-- Name: circular_id_seq; Type: SEQUENCE; Schema: tweeks; Owner: -
--

CREATE SEQUENCE tweeks.circular_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6461 (class 0 OID 0)
-- Dependencies: 365
-- Name: circular_id_seq; Type: SEQUENCE OWNED BY; Schema: tweeks; Owner: -
--

ALTER SEQUENCE tweeks.circular_id_seq OWNED BY tweeks.circular.id;


--
-- TOC entry 343 (class 1259 OID 17696)
-- Name: codigoimposto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.codigoimposto (
    codigoimposto_codigo character varying NOT NULL,
    codigoimposto_descricao character varying
);


--
-- TOC entry 344 (class 1259 OID 17701)
-- Name: custoguia; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.custoguia (
    custoguia_uid uuid DEFAULT gen_random_uuid() NOT NULL,
    custoguia_guia_uid uuid NOT NULL,
    custoguia_colaborador_id uuid NOT NULL,
    custoguia_espaco_auth uuid NOT NULL,
    custoguia_colaborador_atualizacao uuid,
    custoguia_descricao character varying NOT NULL,
    custoguia_montante double precision NOT NULL,
    custoguia_tcusto_id smallint NOT NULL,
    custoguia_estado smallint DEFAULT (map.get('maguita_custoguia_estado_ativo'::name))::smallint NOT NULL,
    custoguia_date timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    custoguia_dateupdate timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 345 (class 1259 OID 17709)
-- Name: dispoe; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.dispoe (
    dispoe_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    dispoe_artigo_id uuid NOT NULL,
    dispoe_artigo_item uuid NOT NULL,
    dispoe_espaco_auth uuid NOT NULL,
    dispoe_colaborador_id uuid NOT NULL,
    dispoe_colaborador_atualizacao uuid,
    dispoe_estado smallint DEFAULT (map.get('dispoe_estado_ativo'::name))::smallint NOT NULL,
    dispoe_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    dispoe_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 6465 (class 0 OID 0)
-- Dependencies: 345
-- Name: TABLE dispoe; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.dispoe IS 'Dispoe - Essa entidade serve para mapear os artigos (item extras) que fazem parte do artigo de venda';


--
-- TOC entry 6466 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_id IS 'Identificador único do dispoe';


--
-- TOC entry 6467 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_artigo_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_artigo_id IS 'Identificador do artigo de venda';


--
-- TOC entry 6468 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_artigo_item; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_artigo_item IS 'Identificador do artigo (item extra) associado ao artigo de venda';


--
-- TOC entry 6469 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_colaborador_id IS 'Identificador do colaborador responsável pelo registro do dispor';


--
-- TOC entry 6470 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_colaborador_atualizacao IS 'Identificador do último colaborador a atualiazar o dispoe (colaborador que desagregou o artigo item extra ao artigo)';


--
-- TOC entry 6471 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_estado IS 'Estado do dispor
<ul>
  <li> 1 - Ativo </li>
  <li> 0 - Fechado </li>
</ul>';


--
-- TOC entry 6472 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_dataregistro IS 'Corresponde ao isntante em que o dispoe foi registrado';


--
-- TOC entry 6473 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN dispoe.dispoe_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.dispoe.dispoe_dataatualizacao IS 'Corresponde ao instante em que o item foi atualizado pela última vez';


--
-- TOC entry 346 (class 1259 OID 17715)
-- Name: ean; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.ean (
    ean_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    ean_artigo_id uuid NOT NULL,
    ean_espaco_auth uuid NOT NULL,
    ean_colaborador_id uuid NOT NULL,
    ean_colaborador_atualizacao uuid,
    ean_code character varying NOT NULL,
    ean_dateout date,
    ean_datein date,
    ean_estado smallint DEFAULT (map.get('maguita_ean_estado_ativo'::name))::smallint NOT NULL,
    ean_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    ena_dateupdate timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 347 (class 1259 OID 17723)
-- Name: fluxo_fluxo_sequencia_seq; Type: SEQUENCE; Schema: tweeks; Owner: -
--

CREATE SEQUENCE tweeks.fluxo_fluxo_sequencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6476 (class 0 OID 0)
-- Dependencies: 347
-- Name: fluxo_fluxo_sequencia_seq; Type: SEQUENCE OWNED BY; Schema: tweeks; Owner: -
--

ALTER SEQUENCE tweeks.fluxo_fluxo_sequencia_seq OWNED BY tweeks.fluxo.fluxo_sequencia;


--
-- TOC entry 349 (class 1259 OID 17736)
-- Name: imposto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.imposto (
    imposto_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    imposto_tipoimposto_id uuid NOT NULL,
    imposto_artigo_id uuid NOT NULL,
    imposto_taplicar_id smallint NOT NULL,
    imposto_espaco_auth uuid NOT NULL,
    imposto_colaborador_id uuid NOT NULL,
    imposto_colaborador_atualizacao uuid,
    imposto_percentagem double precision,
    imposto_valor double precision,
    imposto_estado smallint DEFAULT (map.get('maguita_imposto_estado_ativo'::name))::smallint NOT NULL,
    imposto_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    imposto_dataatualizacao smallint,
    _branch_uid uuid
);


--
-- TOC entry 350 (class 1259 OID 17742)
-- Name: impostovenda; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.impostovenda (
    impostovenda_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    impostovenda_venda_id uuid NOT NULL,
    impostovenda_tipoimposto_id uuid NOT NULL,
    impostovenda_espaco_auth uuid NOT NULL,
    impostovenda_colaborador_id uuid NOT NULL,
    impostovenda_colaborador_atualizacao uuid,
    impostovenda_valor double precision,
    impostovenda_percentagem double precision,
    impostovenda_estado smallint DEFAULT (map.get('impostovenda_estado_ativo'::name))::smallint NOT NULL,
    impostovenda_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    impostovenda_dataatualizacao timestamp with time zone,
    _branch_uid uuid
);


--
-- TOC entry 351 (class 1259 OID 17748)
-- Name: lancamento_lancamento_sequencia_seq; Type: SEQUENCE; Schema: tweeks; Owner: -
--

CREATE SEQUENCE tweeks.lancamento_lancamento_sequencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6480 (class 0 OID 0)
-- Dependencies: 351
-- Name: lancamento_lancamento_sequencia_seq; Type: SEQUENCE OWNED BY; Schema: tweeks; Owner: -
--

ALTER SEQUENCE tweeks.lancamento_lancamento_sequencia_seq OWNED BY tweeks.lancamento.lancamento_sequencia;


--
-- TOC entry 367 (class 1259 OID 91012)
-- Name: ref; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.ref (
    value tweeks.circular
);


--
-- TOC entry 368 (class 1259 OID 91017)
-- Name: ref2; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.ref2 (
    value tweeks.ref
);


--
-- TOC entry 352 (class 1259 OID 17749)
-- Name: repcolumn; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.repcolumn (
    source character varying NOT NULL,
    name character varying NOT NULL,
    show boolean DEFAULT false NOT NULL,
    init boolean DEFAULT false NOT NULL,
    format character varying,
    filter jsonb DEFAULT jsonb_build_array() NOT NULL,
    agg jsonb DEFAULT jsonb_build_array() NOT NULL,
    gen jsonb DEFAULT jsonb_build_array() NOT NULL,
    rename character varying,
    "position" smallint,
    type character varying NOT NULL
);


--
-- TOC entry 353 (class 1259 OID 17759)
-- Name: retalho; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.retalho (
    retalho_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    retalho_artigo_composto uuid NOT NULL,
    retalho_artigo_base uuid NOT NULL,
    retalho_colaborador_id uuid NOT NULL,
    retalho_espaco_auth uuid NOT NULL,
    retalho_composicao double precision NOT NULL,
    retalho_quantidade double precision NOT NULL,
    retalho_total double precision GENERATED ALWAYS AS ((retalho_composicao * retalho_quantidade)) STORED NOT NULL,
    retalho_estado smallint DEFAULT (map.get('maguita_retalho_estado_ativo'::name))::smallint NOT NULL,
    retalho_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    retalho_dataatualizacao timestamp with time zone,
    _branch_uid uuid,
    retalho_codigo character varying
);


--
-- TOC entry 354 (class 1259 OID 17768)
-- Name: seq_classe_code; Type: SEQUENCE; Schema: tweeks; Owner: -
--

CREATE SEQUENCE tweeks.seq_classe_code
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 355 (class 1259 OID 17769)
-- Name: seq_cliente_code; Type: SEQUENCE; Schema: tweeks; Owner: -
--

CREATE SEQUENCE tweeks.seq_cliente_code
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 356 (class 1259 OID 17770)
-- Name: serie_serie_sequencia_seq; Type: SEQUENCE; Schema: tweeks; Owner: -
--

CREATE SEQUENCE tweeks.serie_serie_sequencia_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 6488 (class 0 OID 0)
-- Dependencies: 356
-- Name: serie_serie_sequencia_seq; Type: SEQUENCE OWNED BY; Schema: tweeks; Owner: -
--

ALTER SEQUENCE tweeks.serie_serie_sequencia_seq OWNED BY tweeks.serie.serie_sequencia;


--
-- TOC entry 357 (class 1259 OID 17771)
-- Name: stock; Type: VIEW; Schema: tweeks; Owner: -
--

CREATE VIEW tweeks.stock AS
 SELECT __fluxo_scan.fluxo_espaco_id AS espaco_id,
    __fluxo_scan.fluxo_artigo_id AS artigo_id,
    NULL::uuid AS fluxo_espaco_in,
    NULL::uuid AS fluxo_artigo_in,
    NULL::bigint AS entrada_quantidade,
    NULL::bigint AS entradas,
    NULL::uuid AS fluxo_artigo_out,
    NULL::uuid AS fluxo_espaco_out,
    NULL::bigint AS saida_quantidade,
    NULL::bigint AS saidas,
    __fluxo_scan.fluxo_resultado AS stock_quantidade
   FROM tweeks.__fluxo_scan(NULL::uuid, NULL::uuid, true, NULL::uuid) __fluxo_scan(fluxo_artigo_id, fluxo_espaco_id, fluxo_preview, fluxo_resultado, fluxo_checkmarks, fluxo_check, fluxo_order, fluxo_end, fluxo_resume, fluxo_credito, fluxo_debito, fluxo_calc, fluxo_quantidade, fluxo_id, fluxo_date, fluxo_sequencia);


--
-- TOC entry 358 (class 1259 OID 17775)
-- Name: taplicar; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.taplicar (
    taplicar_id smallint NOT NULL,
    taplicar_descricao character varying NOT NULL
);


--
-- TOC entry 359 (class 1259 OID 17780)
-- Name: tbranch; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tbranch (
    tbranch_id smallint NOT NULL,
    tbranch_name character varying NOT NULL,
    tbranch_configs jsonb DEFAULT jsonb_build_object()
);


--
-- TOC entry 360 (class 1259 OID 17786)
-- Name: tdocuemto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tdocuemto (
    tdocumento_id smallint NOT NULL,
    tdocumento_nome character varying NOT NULL
);


--
-- TOC entry 361 (class 1259 OID 17791)
-- Name: tlink; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tlink (
    tlink_id smallint NOT NULL,
    tlink_designacao character varying
);


--
-- TOC entry 6494 (class 0 OID 0)
-- Dependencies: 361
-- Name: TABLE tlink; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.tlink IS 'Essa entidade serve para registar os tipos de links';


--
-- TOC entry 6495 (class 0 OID 0)
-- Dependencies: 361
-- Name: COLUMN tlink.tlink_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tlink.tlink_id IS 'Identificador do tipo de link';


--
-- TOC entry 6496 (class 0 OID 0)
-- Dependencies: 361
-- Name: COLUMN tlink.tlink_designacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.tlink.tlink_designacao IS 'Corresponde a designação dos tipos de link';


--
-- TOC entry 362 (class 1259 OID 17796)
-- Name: tposto; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.tposto (
    tposto_id smallint NOT NULL,
    tposto_designacao character varying
);


--
-- TOC entry 363 (class 1259 OID 17801)
-- Name: trabalha; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.trabalha (
    trabalha_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    trabalha_perfil_id uuid,
    trabalha_espaco_destino uuid NOT NULL,
    trabalha_espaco_auth uuid NOT NULL,
    trabalha_colaborador_proprietario uuid NOT NULL,
    trabalha_colaborador_id uuid NOT NULL,
    trabalha_colaborador_atualizacao uuid,
    trabalha_estado smallint DEFAULT (map.get('maguita_trabalha_estado_ativo'::name))::smallint NOT NULL,
    trabalha_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    trabalha_dataatualizacao timestamp with time zone,
    trabalha_posicao smallint,
    _branch_uid uuid
);


--
-- TOC entry 6499 (class 0 OID 0)
-- Dependencies: 363
-- Name: TABLE trabalha; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.trabalha IS 'Essa entidade serve para indicar os perfil com qual um colaborador trabalha, e tambem em qual departamento ou setor o colaborador trabalha';


--
-- TOC entry 6500 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_id IS 'Identificador único da instancia trabalha';


--
-- TOC entry 6501 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_perfil_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_perfil_id IS 'Identificador do perfil com qual o colaborador esta a trabalhar';


--
-- TOC entry 6502 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_espaco_auth; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_espaco_auth IS 'Identificaodor do local onde o colaborador trabalha (departamento, setor, direção, local, agencia, ...)';


--
-- TOC entry 6503 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_colaborador_proprietario; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_colaborador_proprietario IS 'Identificador do colaborador proprietario ao trabalho (colaborador com direito de trabalhar)';


--
-- TOC entry 6504 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_colaborador_id IS 'Identificador do colaborador responsável pelo registro do trabalha';


--
-- TOC entry 6505 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_colaborador_atualizacao IS 'Identificador do último colaborador responsável pela atualização do trabalha';


--
-- TOC entry 6506 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_estado IS 'Corresponde ao estado do trabalha do colaborador
<ul>
  <li> 1 - Ativo | O colaborador atualmente trabalha nesse local </li>
  <li> 0 - Desativo | O colaborador deixou de trabalhar com o perfil</li>
</ul>
';


--
-- TOC entry 6507 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_dataregistro IS 'Corresponde a data em que foi atribuido ao colaborador o direito de trabalhar com o perfil';


--
-- TOC entry 6508 (class 0 OID 0)
-- Dependencies: 363
-- Name: COLUMN trabalha.trabalha_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.trabalha.trabalha_dataatualizacao IS 'Corresponde ao último instante';


--
-- TOC entry 364 (class 1259 OID 17807)
-- Name: transferencia; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.transferencia (
    transferencia_id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    transferencia_espaco_auth uuid,
    transferencia_colaborador_id uuid NOT NULL,
    transferencia_colaborador_atualizacao uuid,
    transferencia_quantidade double precision NOT NULL,
    transferencia_data date,
    transferencia_documento character varying NOT NULL,
    transferencia_observacao character varying,
    transferencia_estado smallint DEFAULT (map.get('transferencia_estado_ativo'::name))::smallint NOT NULL,
    transferencia_dataregistro timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    transferencia_dataatualizacao timestamp with time zone,
    transferencia_espaco_origem uuid,
    transferencia_espaco_destino uuid,
    transferencia_artigo_id uuid,
    _branch_uid uuid,
    transferencia_lote character varying,
    transferencia_validade date,
    transferencia_metadata json,
    transferencia_descricao character varying
);


--
-- TOC entry 6510 (class 0 OID 0)
-- Dependencies: 364
-- Name: TABLE transferencia; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON TABLE tweeks.transferencia IS 'Essa entidade serve para armazenar as transferência dos artigos entre os stock ';


--
-- TOC entry 6511 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_colaborador_id; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_colaborador_id IS 'Identificador do colaborador responsável pelo registro de transferência do artigo entre os stocks';


--
-- TOC entry 6512 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_colaborador_atualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_colaborador_atualizacao IS 'Identificador do colaborador responsável pela última atualização da transferencia.';


--
-- TOC entry 6513 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_quantidade; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_quantidade IS 'Corresponde a quantidade do artigo tranferido';


--
-- TOC entry 6514 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_data; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_data IS 'Corresponde a data efetiva da transferencia dos produtos';


--
-- TOC entry 6515 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_documento; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_documento IS 'Corresponde ao documento da transferência';


--
-- TOC entry 6516 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_observacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_observacao IS 'Corresponde a observação para a transferencia';


--
-- TOC entry 6517 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_estado; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_estado IS 'Corresponde ao estado da transferencia';


--
-- TOC entry 6518 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_dataregistro; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_dataregistro IS 'Corresponde ao isntante em que a tranferência foi registrada no sistema';


--
-- TOC entry 6519 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN transferencia.transferencia_dataatualizacao; Type: COMMENT; Schema: tweeks; Owner: -
--

COMMENT ON COLUMN tweeks.transferencia.transferencia_dataatualizacao IS 'Corresponde a data em que a transferência foi atualizada pela última vez no sistema';


--
-- TOC entry 379 (class 1259 OID 160223)
-- Name: unit; Type: TABLE; Schema: tweeks; Owner: -
--

CREATE TABLE tweeks.unit (
    unit_id uuid DEFAULT gen_random_uuid() NOT NULL,
    unit_code character varying NOT NULL,
    unit_name character varying NOT NULL,
    unit_state smallint DEFAULT (map.get('maguita_unit_state_active'::name))::smallint NOT NULL,
    unit_date timestamp with time zone DEFAULT clock_timestamp() NOT NULL,
    unit_update timestamp with time zone,
    unit_espaco_auth uuid NOT NULL,
    unit_user_id uuid NOT NULL,
    unit_user_update uuid,
    _branch_uid uuid NOT NULL
);


--
-- TOC entry 4418 (class 2604 OID 17815)
-- Name: auth auth_seq; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.auth ALTER COLUMN auth_seq SET DEFAULT nextval('cluster.auth_auth_seq_seq'::regclass);


--
-- TOC entry 4290 (class 2604 OID 17816)
-- Name: collector collector_sequence; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.collector ALTER COLUMN collector_sequence SET DEFAULT nextval('cluster.collector_collector_sequence_seq'::regclass);


--
-- TOC entry 4427 (class 2604 OID 17817)
-- Name: filter filter_id; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.filter ALTER COLUMN filter_id SET DEFAULT nextval('cluster.filter_filter_id_seq'::regclass);


--
-- TOC entry 4428 (class 2604 OID 17818)
-- Name: filter filter_sequence; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.filter ALTER COLUMN filter_sequence SET DEFAULT nextval('cluster.filter_filter_sequence_seq'::regclass);


--
-- TOC entry 4299 (class 2604 OID 17819)
-- Name: object object_seq; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.object ALTER COLUMN object_seq SET DEFAULT nextval('cluster.object_object_seq_seq'::regclass);


--
-- TOC entry 4300 (class 2604 OID 17820)
-- Name: object object_sseq; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.object ALTER COLUMN object_sseq SET DEFAULT nextval('cluster.object_object_sseq_seq'::regclass);


--
-- TOC entry 4430 (class 2604 OID 17821)
-- Name: pull pull_sequence; Type: DEFAULT; Schema: cluster; Owner: -
--

ALTER TABLE ONLY cluster.pull ALTER COLUMN pull_sequence SET DEFAULT nextval('cluster.pull_pull_sequence_seq'::regclass);


--
-- TOC entry 4439 (class 2604 OID 17822)
-- Name: altspelling altspelling_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.altspelling ALTER COLUMN altspelling_id SET DEFAULT nextval('geoinfo.seq_altspelling'::regclass);


--
-- TOC entry 4440 (class 2604 OID 17823)
-- Name: country country_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.country ALTER COLUMN country_id SET DEFAULT nextval('geoinfo.seq_country'::regclass);


--
-- TOC entry 4441 (class 2604 OID 17824)
-- Name: countryborder countryborder_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countryborder ALTER COLUMN countryborder_id SET DEFAULT nextval('geoinfo.seq_countryborder'::regclass);


--
-- TOC entry 4442 (class 2604 OID 17825)
-- Name: countrycallcode countrycallcode_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countrycallcode ALTER COLUMN countrycallcode_id SET DEFAULT nextval('geoinfo.seq_countrycallcode'::regclass);


--
-- TOC entry 4443 (class 2604 OID 17826)
-- Name: countrycurrency countrycurrency_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countrycurrency ALTER COLUMN countrycurrency_id SET DEFAULT nextval('geoinfo.seq_countrycurrency'::regclass);


--
-- TOC entry 4444 (class 2604 OID 17827)
-- Name: countrylanguage countrylanguage_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countrylanguage ALTER COLUMN countrylanguage_id SET DEFAULT nextval('geoinfo.seq_countrylanguage'::regclass);


--
-- TOC entry 4445 (class 2604 OID 17828)
-- Name: countryregionalbloc countryregionalbloc_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countryregionalbloc ALTER COLUMN countryregionalbloc_id SET DEFAULT nextval('geoinfo.seq_countryregionalbloc'::regclass);


--
-- TOC entry 4446 (class 2604 OID 17829)
-- Name: countrytimezone countrytimezone_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countrytimezone ALTER COLUMN countrytimezone_id SET DEFAULT nextval('geoinfo.seq_countrytimezone'::regclass);


--
-- TOC entry 4447 (class 2604 OID 17830)
-- Name: countrytopleveldomain countrytopleveldomain_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countrytopleveldomain ALTER COLUMN countrytopleveldomain_id SET DEFAULT nextval('geoinfo.seq_countrytopleveldomain'::regclass);


--
-- TOC entry 4448 (class 2604 OID 17831)
-- Name: countrytranslation countrytranslation_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.countrytranslation ALTER COLUMN countrytranslation_id SET DEFAULT nextval('geoinfo.seq_countrytranslation'::regclass);


--
-- TOC entry 4449 (class 2604 OID 17832)
-- Name: currency currency_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.currency ALTER COLUMN currency_id SET DEFAULT nextval('geoinfo.seq_currency'::regclass);


--
-- TOC entry 4320 (class 2604 OID 17833)
-- Name: dataset dataset_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.dataset ALTER COLUMN dataset_id SET DEFAULT nextval('geoinfo.seq_dataset'::regclass);


--
-- TOC entry 4450 (class 2604 OID 17834)
-- Name: demonym demonym_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.demonym ALTER COLUMN demonym_id SET DEFAULT nextval('geoinfo.seq_demonym'::regclass);


--
-- TOC entry 4451 (class 2604 OID 17835)
-- Name: domain domain_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.domain ALTER COLUMN domain_id SET DEFAULT nextval('geoinfo.seq_domain'::regclass);


--
-- TOC entry 4452 (class 2604 OID 17836)
-- Name: language language_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.language ALTER COLUMN language_id SET DEFAULT nextval('geoinfo.seq_language'::regclass);


--
-- TOC entry 4453 (class 2604 OID 17837)
-- Name: region region_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.region ALTER COLUMN region_id SET DEFAULT nextval('geoinfo.seq_region'::regclass);


--
-- TOC entry 4454 (class 2604 OID 17838)
-- Name: regionalbloc regionalbloc_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.regionalbloc ALTER COLUMN regionalbloc_id SET DEFAULT nextval('geoinfo.seq_regionalbloc'::regclass);


--
-- TOC entry 4455 (class 2604 OID 17839)
-- Name: regionalblocname regionalblocname_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.regionalblocname ALTER COLUMN regionalblocname_id SET DEFAULT nextval('geoinfo.seq_regionalblocname'::regclass);


--
-- TOC entry 4456 (class 2604 OID 17840)
-- Name: regionalblocother regionalblocother_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.regionalblocother ALTER COLUMN regionalblocother_id SET DEFAULT nextval('geoinfo.seq_regionalblocother'::regclass);


--
-- TOC entry 4457 (class 2604 OID 17841)
-- Name: subregion subregion_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.subregion ALTER COLUMN subregion_id SET DEFAULT nextval('geoinfo.seq_subregion'::regclass);


--
-- TOC entry 4458 (class 2604 OID 17842)
-- Name: timezone timezone_id; Type: DEFAULT; Schema: geoinfo; Owner: -
--

ALTER TABLE ONLY geoinfo.timezone ALTER COLUMN timezone_id SET DEFAULT nextval('geoinfo.seq_timezone'::regclass);


--
-- TOC entry 4573 (class 2604 OID 169272)
-- Name: revision seq; Type: DEFAULT; Schema: patch; Owner: -
--

ALTER TABLE ONLY patch.revision ALTER COLUMN seq SET DEFAULT nextval('patch.revision_seq_seq'::regclass);


--
-- TOC entry 4543 (class 2604 OID 91007)
-- Name: circular id; Type: DEFAULT; Schema: tweeks; Owner: -
--

ALTER TABLE ONLY tweeks.circular ALTER COLUMN id SET DEFAULT nextval('tweeks.circular_id_seq'::regclass);


--
-- TOC entry 4488 (class 2604 OID 17844)
-- Name: fluxo fluxo_sequencia; Type: DEFAULT; Schema: tweeks; Owner: -
--

ALTER TABLE ONLY tweeks.fluxo ALTER COLUMN fluxo_sequencia SET DEFAULT nextval('tweeks.fluxo_fluxo_sequencia_seq'::regclass);


--
-- TOC entry 4476 (class 2604 OID 17845)
-- Name: lancamento lancamento_sequencia; Type: DEFAULT; Schema: tweeks; Owner: -
--

ALTER TABLE ONLY tweeks.lancamento ALTER COLUMN lancamento_sequencia SET DEFAULT nextval('tweeks.lancamento_lancamento_sequencia_seq'::regclass);


--
-- TOC entry 5409 (class 0 OID 17232)
-- Dependencies: 260
-- Data for Name: acesso; Type: TABLE DATA; Schema: auth; Owner: -
--

COPY auth.acesso (acesso_id, acesso_menu_id, acesso_colaborador_propetario, acesso_colaborador_id, acesso_colaborador_atualizacao, acesso_estado, acesso_dataregisto, acesso_dataatualizacao, _branch_uid) FROM stdin;
07cd873e-9eff-45eb-a871-20671aa4cc17	89	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
8e1dd29a-1e99-47be-90ba-d22956132328	87	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
b7a32917-789f-4fe3-b7be-43723833c58d	90	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
7faa7a03-e062-460c-b18b-d2fea90778dd	98	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
57974df0-bd8c-4a42-bee0-3703a2c3a87f	93	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
04e041b5-ed74-45e9-82d5-3c6df028a273	94	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
d82d6537-f2fc-4bb6-90ac-554b91400394	88	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
6623a1d1-57b4-404e-99fc-dcfc4b627ab6	69	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
e58a1956-8eaf-4ef4-897e-f92548e17ff0	70	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
734b586f-59c4-46a8-9cb0-83dc73c9c11d	74	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
54ae17e5-593f-4fbb-962c-c474751c1e02	71	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
ed77c714-b0ae-4073-a225-116807b670da	75	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
bc7da21c-df75-465e-b48d-aec59a970db5	77	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
284f8da4-f8d5-4199-a316-13640c9490c2	95	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
98109c28-b4f2-49fb-9c86-3f37e46e01bb	100	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
24a918e2-22d4-4761-85e9-ea822c1f64bb	113	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
cb502ca5-7750-470a-8a7a-0965bad3f131	114	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
cdda0097-5f2c-4e7c-8384-c43bfe126f32	102	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
426b3f56-6a86-471f-bd5c-ccf1d8bc63a8	104	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
f01030e8-9e0b-4954-b6cf-5ce3f9f36863	106	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
891587ed-417a-4184-a045-7b9581a7da25	107	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
a45bc4e6-48c7-4e93-aa3f-c81cbbbb2bc6	108	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
0997ded1-0cc9-4415-8358-1a844d75a40d	109	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
f34da386-f4fb-4f39-b5a0-97da887b6cab	110	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
2089c88a-3796-4af9-bf94-8bc12f74964e	111	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
600ac9b6-1fc1-49bb-afe3-e932334a860e	112	00000000-0000-0000-0000-000000000002	00000000-0000-0000-0000-000000000001	\N	1	2023-06-08 17:18:58.83119+00	\N	\N
0b8ef529-20f8-479c-910d-aa1ed093f0f7	74	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
0e283cfb-b11b-4572-8e8e-72d6af4429c1	93	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
2620ef8d-fdd6-4db7-8514-3a0f8173ddaa	77	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
33130ea7-b15b-423a-9d64-00e542753f2a	106	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
3b7ec093-b6bc-48ba-9998-367ba1b736fd	98	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
49a7ffaf-5b6b-40dd-847d-3a13492450cf	88	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
4bb76774-8ec2-42b9-a283-695780a1e95b	111	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
509c9129-8b0b-4384-868e-94c5809fe886	107	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
511c6aa3-5360-46b7-813c-3e0ffc331ecd	110	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
60832115-4d8e-49fe-b025-f1ecb4f5c5a0	95	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
7043f131-53eb-4c80-bbc9-4addd8ad4fdc	100	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
721d0515-1902-4bad-9a23-925f45454ec7	102	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
7552dd55-5fd0-45ba-9a39-6f1aa88de6b5	94	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
90c004e3-f97c-4d68-8996-a209bb294811	90	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
9beddc35-6da9-4015-8799-68cab7d846ab	104	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
b12636e2-cc84-4013-a7c9-0b8ea10229db	75	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
b35b387d-cbb0-46c6-bfdd-34d5796f9a7a	109	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
d2ef1ca9-4b0f-4ff8-94b6-55b446eefff3	112	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
da0f8942-fbc2-4224-8859-084354937527	69	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
dfcdddf3-c61c-4c2f-a143-b0ab6e44da4f	70	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
e6ded223-b122-4f4e-8759-ac20373ab0ed	71	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
e9e52264-ad9a-4db3-8996-6f9023b81ee1	108	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
f6855d0f-ba93-49ec-bc50-06fcd80150d6	87	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
fbac0ab1-628c-4c4f-9343-c7c98dec5fa8	89	b0dfd33a-3d66-4133-b08f-9ce2366600ba	00000000-0000-0000-0000-000000000002	\N	1	2022-10-11 09:59:29.79398+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
1d9bf851-cb62-404b-aa7f-f39c33d9ef18	102	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
05dbec9e-9141-4426-81c1-c40eebf82a7a	71	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
3d286c18-927d-46bb-936d-c148d5dac907	95	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
64dcd628-a641-49e2-b490-50c923cf546a	93	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
76e0788b-9303-485b-9e23-d568cce3dbbb	74	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
892d089a-412b-4932-8fb4-0dbec3d123fc	109	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
14ad3f03-ee54-4d93-8132-57505bbeeca8	112	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
fd792d4b-0b3a-44f5-83ea-4a133dcc7698	107	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
d42696c2-a19a-4274-9f69-07b56bdff163	108	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
618fecb7-f8ba-40cf-97fe-06cd7fd4653f	106	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
2261f7ac-ab3b-4306-a87b-93f60bba063a	110	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
e8e345c5-1449-4506-892f-75d8cae5197b	111	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:44:18.172963+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
9a946db5-f27e-439a-9a1a-e7109fd85778	102	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
9a508e76-e54a-48d8-8f6e-51cad3b63fe3	71	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
d57efadc-ed0d-4e2c-ae5e-2aebf44afe26	94	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
1e71de5f-b37e-49b0-bb62-3d34302132fa	95	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
9d46a935-a5e9-4031-96d1-a2ebec42762a	90	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
7b3382f1-d0e4-422e-9192-13a818627335	93	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
1fae581b-db11-4ad6-a8f7-67dd8a14252e	74	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
dacbe057-4357-42c0-98df-bf56d40749f8	109	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
fdab69e3-466e-41ea-a853-1334ca037b41	112	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
b04befcc-1d0d-46f1-87bd-1a781ac9c474	107	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
07253126-fa01-4b92-9b82-503f0a0b53fe	108	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
a2a4d1f0-2f71-4e58-9962-3e24ad25e843	106	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
2f2d8758-620c-4b31-8660-3ae5bd77b6b4	110	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
14849fbb-cf17-4da0-9e8e-ef4ca4d450a2	111	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-26 16:56:00.326574+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
7aea6c3c-70fb-45e6-9eae-1bbcdaa21add	104	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
f52c4344-6529-4a27-bff3-50b3b9536394	94	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
87a708f9-6bdb-4c15-b797-83a3bc1f7de4	100	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
b9de87aa-c2fb-44b2-9b08-7aa0460090bc	88	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
daa67bae-bfb7-4771-94ac-8e8a3efece01	90	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
f424181c-29ca-4cef-887c-4cc33de35c5a	77	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
c1204bcf-42ba-4e53-89e1-4d74b268556f	89	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
de67e672-8e4d-4827-9a33-e71f9bf4ffc0	87	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
64aec8c9-2d76-47f4-bd93-1addc8961ae3	98	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
981a6fe3-9dc8-4478-9809-92e7a116c420	70	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-27 16:08:19.515836+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
97f7c91f-4d46-404f-b755-ce70fdb5050c	69	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	b0dfd33a-3d66-4133-b08f-9ce2366600ba	0	2023-06-27 16:08:19.515836+00	2023-06-29 08:20:12.015604+00	e1973eb1-dcd5-4243-9699-dfbbae1bff04
4c0ca1b7-77ed-426d-a7b5-ab62496f4543	75	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	b0dfd33a-3d66-4133-b08f-9ce2366600ba	0	2023-06-27 16:08:19.515836+00	2023-06-29 08:20:12.015604+00	e1973eb1-dcd5-4243-9699-dfbbae1bff04
6ea87b84-7b01-4d42-8cc3-668858190e17	70	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:19:41.989002+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
465c7dcf-7b22-48f9-95af-954f3c9a05ea	71	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
306c8128-8e68-43d0-b0a1-17e49a3aa80d	94	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
52204adc-7187-4291-b4bf-ae20d18f4fd2	95	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
1f4f6ffd-4e79-460d-bbbb-dadaa4518eb6	100	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
da3b2389-8a5f-43bf-8ac7-f62523010d2f	88	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
3b7d57b3-b321-4938-8a76-edcdbf9a4cc7	90	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
3570e182-10b7-4b69-b7c8-79db62951fc5	89	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
e2a57746-fab6-4bab-a658-6758d538a7fc	87	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
79ebf005-7208-4c5b-ae4f-1893e46e8697	74	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
45f4c50d-3a31-450d-b8e3-9e79c879b349	109	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
c89fbe5a-1106-4b54-a1fd-0474b0044da1	112	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
22be763a-f94b-4e95-81bc-90b1188b8124	107	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
b3102c2e-01ed-43fa-a1c2-2d9f12432bdc	108	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
8b0d50be-b2f0-4c0f-9e75-d39beb05c625	111	5896c3e5-4d44-492a-abff-80a016a7a0b1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:28:52.214331+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
eda72db5-024d-4d13-8576-9a3b771a0356	104	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
d5dbc0bb-8c1b-4885-af4c-e13085ea1e46	100	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
6f87b4c1-ebb5-4d7f-8122-118cf9327bbb	88	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
77eaadd1-5f52-45fd-bdbf-82d3d8de07cd	77	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
ff65adb6-2a8d-45f1-ab7c-4aba5b53d6df	89	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
744f57f0-df50-4106-88e1-3523b78df214	87	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
ecb6fd73-c3b7-4fce-900c-938d1a7c4b25	98	e3848a2a-197f-4344-9d1e-12d78d0c45d7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
6d4fffd6-aef4-4287-b423-a2e4598d6909	115	5896c3e5-4d44-492a-abff-80a016a7a0b1	5896c3e5-4d44-492a-abff-80a016a7a0b1	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
a6176197-5e19-4859-856f-96fb5c1334f9	116	5896c3e5-4d44-492a-abff-80a016a7a0b1	5896c3e5-4d44-492a-abff-80a016a7a0b1	\N	1	2023-06-29 10:46:10.951027+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
c34f7e67-f306-4c34-8d6e-78f99580189c	116	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-09-20 16:00:01.736944+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
aa74b757-d953-49c0-aa3e-e452f7aaa269	115	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-09-20 16:00:01.736944+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
147d17d2-cd8d-4eb2-b248-d0631949ebaf	69	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-09-20 16:00:01.736944+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
e87a6ad9-a8f3-40c5-93f1-b2baa6f6def2	75	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-09-20 16:00:01.736944+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
4c087bb1-f6ab-4c64-adb8-05d08806cb55	117	455163b9-674b-4666-ad6c-80f70584a97e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	\N	1	2023-09-21 19:48:19.729867+00	\N	e1973eb1-dcd5-4243-9699-dfbbae1bff04
\.


--
-- TOC entry 5410 (class 0 OID 17238)
-- Dependencies: 261
-- Data for Name: autenticacao; Type: TABLE DATA; Schema: auth; Owner: -
--

COPY auth.autenticacao (autenticacao_id, autenticacao_colaborador_id, autenticacao_chave, autenticacao_estado, autenticacao_dataregisto, autenticacao_dataatualizacao) FROM stdin;
285b6ec5-d4dc-4e21-ad7f-f7b2cb4cd698	00000000-0000-0000-0000-000000000002	lGReDwFwDsoFTrSGCKBIjGUoVXKJSesC	1	2023-06-08 17:25:05.147293+00	\N
e1cee4c0-888a-4ee3-a80c-dbf5678adf85	00000000-0000-0000-0000-000000000002	qszWuxWlXUtoeLiveccQkfiPburqSFar	1	2023-06-08 17:27:32.85795+00	\N
d887bd17-c928-4b3e-9cf3-53511a20d188	b0dfd33a-3d66-4133-b08f-9ce2366600ba	YyHsJBrpEycWpSnqudJZGaFfvAsLTEGf	1	2023-06-08 17:28:02.513128+00	\N
505ae9c6-6b46-40a2-a7e0-f05edbc54836	b0dfd33a-3d66-4133-b08f-9ce2366600ba	fTPWilNEANxfFeEZhJceWuNwDiTfzjpo	1	2023-06-08 17:28:39.46172+00	\N
14eafbe6-da34-44b4-a886-598d802b0e88	b0dfd33a-3d66-4133-b08f-9ce2366600ba	wWdmszludjlPphrqqkiaJJscgLjmdGba	1	2023-06-14 18:13:34.542093+00	\N
ea14c15c-c5ba-4a2c-9b2c-d6d392c4275b	b0dfd33a-3d66-4133-b08f-9ce2366600ba	jqyGvuavqvOsdrtazLMtUoFhZxDhvVVu	1	2023-06-14 23:23:25.574044+00	\N
be054835-487e-4152-ab6c-0bd916a55efc	b0dfd33a-3d66-4133-b08f-9ce2366600ba	KibqvmyhErMNBiqrdCraUdeZNdZvCEYl	1	2023-06-15 01:26:31.504116+00	\N
e98369e3-0182-43cc-838d-b69b73490b00	b0dfd33a-3d66-4133-b08f-9ce2366600ba	DNDHuxuZVcRsbgyrwOMrKYyCchJygFrK	1	2023-06-15 01:27:32.554424+00	\N
da9e162b-d17e-4574-81b9-7ed5e03aa832	b0dfd33a-3d66-4133-b08f-9ce2366600ba	CdpXIsXknDzQlbnmuibTJpqZZVFxEKOP	1	2023-06-24 09:48:18.045058+00	\N
3d8ba55a-94e9-4500-bc59-84256ec7aadd	b0dfd33a-3d66-4133-b08f-9ce2366600ba	UnsXaMPeFxbHToWCqDyGnLBiwaDdgVhV	1	2023-06-24 09:52:59.587+00	\N
dd322e45-1d42-4c1b-bf90-691093b3aadb	b0dfd33a-3d66-4133-b08f-9ce2366600ba	NqnMkmUJCKsGJRzTWWPtkrqzgNhJGKoV	1	2023-06-24 09:59:06.806042+00	\N
0e7a8ee9-143d-4ca8-8f43-f0598c656e4f	b0dfd33a-3d66-4133-b08f-9ce2366600ba	SOVbysNUuXOkEohWPYpbZosIjdIBBQam	1	2023-06-26 11:00:08.677637+00	\N
ab02ddec-ac1b-4783-b22d-d7a9d16abae6	b0dfd33a-3d66-4133-b08f-9ce2366600ba	eYJMpbaElKSWLLUWMhCdmJzrtQkyNGla	1	2023-06-26 11:40:02.033279+00	\N
61919132-872c-4adb-806c-f64426ca1a2e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	PYkUBjmtJIxkgJfnzHbVjDiVazpcKbuO	1	2023-06-26 11:49:46.619579+00	\N
a2fd2273-8a3d-4a0f-80d3-320416a93b2d	b0dfd33a-3d66-4133-b08f-9ce2366600ba	zONjePaJZaSaaaKTyCILPwdpcslsjTiM	1	2023-06-26 14:49:23.505119+00	\N
13366684-c0bb-4474-b4d4-bc659e4878a4	b0dfd33a-3d66-4133-b08f-9ce2366600ba	zrsrrVhLQbNCfcHRUnsonpNBOuoHMThV	1	2023-06-26 14:49:23.955057+00	\N
fb11d518-6e14-4d2a-8665-b87d00c5731d	b0dfd33a-3d66-4133-b08f-9ce2366600ba	yaPfuYHsvpUvTdfngejwJrCpLuSqdRsB	1	2023-06-26 15:03:40.783316+00	\N
65380d1f-bece-43cc-ab67-daeaec9f3e01	b0dfd33a-3d66-4133-b08f-9ce2366600ba	oBDeGXrTxUSnFpKfOeIuiawNgHZphAjk	1	2023-06-26 16:31:26.330745+00	\N
0aab98c7-182c-40ce-9f25-1ed194a33be9	b0dfd33a-3d66-4133-b08f-9ce2366600ba	lIyaJiLKacOsrsqSXQGbecvlJTBAOVZm	1	2023-06-26 16:40:18.390452+00	\N
642f6475-0734-4f2b-b454-8cccc8123d2f	b0dfd33a-3d66-4133-b08f-9ce2366600ba	WTAlFaoKDttDsVaCCyQPLyPtYQLYEjip	1	2023-06-26 16:53:35.351028+00	\N
d661e64e-a57b-4826-a9ba-9746c758b5df	455163b9-674b-4666-ad6c-80f70584a97e	CFSGzmPdOmdJLvsQVBknCjbhYVDqdeQT	1	2023-06-26 17:03:24.700031+00	\N
1681f712-1cf4-4a93-be63-8c63184d7ed5	b0dfd33a-3d66-4133-b08f-9ce2366600ba	cuEwSPIaKjFOWkHcUvrmsFavKzellGiP	1	2023-06-26 17:03:41.429479+00	\N
d63643eb-90d1-4899-93b9-b4193d1ad374	b0dfd33a-3d66-4133-b08f-9ce2366600ba	gdrtknXoMclxyIlQPfMWUticEkzIdlgU	1	2023-06-26 17:20:45.287033+00	\N
4320ac40-1570-4626-b3ae-9efe8765b27f	455163b9-674b-4666-ad6c-80f70584a97e	CzpxrhtMIYUctoDSxQyxaTdMYDZlSrqc	1	2023-06-26 17:54:06.754808+00	\N
d66b0067-e06e-4bb5-b9a5-8ffdc0ba7542	455163b9-674b-4666-ad6c-80f70584a97e	TelJWNjhDfoerMSrwWwESanBaWVTufcE	1	2023-06-26 17:54:26.627294+00	\N
0df3d1f8-ad97-49c6-88b3-b0462a5c88a1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	SAfpSfWuUneuWJXQeOOswKCZPMcKTyhZ	1	2023-06-26 17:56:36.261471+00	\N
938850ce-5b21-495d-99bd-b3466ff915fe	b0dfd33a-3d66-4133-b08f-9ce2366600ba	IqjeAcQfWKFVwjJCwJoRghXsKrpFnkQn	1	2023-06-26 18:03:15.720677+00	\N
fa39e307-6597-4fad-aa61-c9c0aaf4cb51	b0dfd33a-3d66-4133-b08f-9ce2366600ba	STkrFmFcnTidFjBZsnlmQusnMnfTgnXD	1	2023-06-26 18:04:26.204339+00	\N
107157ee-c7e3-4da6-b261-f3e38e96b2cd	b0dfd33a-3d66-4133-b08f-9ce2366600ba	DyljnCJxakYOouMcYfcmssFQjuJytsuM	1	2023-06-26 18:05:28.47537+00	\N
657cae89-dab0-4d95-812b-8dccc9ae3fb6	b0dfd33a-3d66-4133-b08f-9ce2366600ba	NPLjuaAnroPBmqawjiqssYcvkXntjtxE	1	2023-06-26 18:07:09.469162+00	\N
39e01ef5-6925-4490-85d1-9d8ca632603b	b0dfd33a-3d66-4133-b08f-9ce2366600ba	DUemdzUXenqKvtfNdJbBPHrbAScJEiuO	1	2023-06-26 18:15:09.959152+00	\N
5c7e2ae3-a158-45a4-b925-6bec5728c6f4	b0dfd33a-3d66-4133-b08f-9ce2366600ba	kAKWervPOIQCuMyoawBInyLhtuNsyXwR	1	2023-06-26 18:18:12.859497+00	\N
604ea78d-c707-4028-82ec-320b27c16377	b0dfd33a-3d66-4133-b08f-9ce2366600ba	iHEUPoYfzuVaKcNHZpILRWXlQlRtehmQ	1	2023-06-26 18:20:35.377084+00	\N
12c3b75d-0605-48c8-9cbb-e15ae1a277f6	b0dfd33a-3d66-4133-b08f-9ce2366600ba	oCFCPOhKTwVGXwVxocPuYNWmNdLuNDdL	1	2023-06-26 18:24:49.50589+00	\N
a65b926c-a2d3-42e3-9943-fcf92f553781	b0dfd33a-3d66-4133-b08f-9ce2366600ba	RDjIvXDEhFYfOBNXfUgbinKoZRuHQGaM	1	2023-06-26 18:26:42.665459+00	\N
578f0d4b-93bb-48be-aa35-8d6f2f5ea3d3	b0dfd33a-3d66-4133-b08f-9ce2366600ba	QzQCamRjfpihUCIbgtpszfmviNJnfwmZ	1	2023-06-26 18:31:36.600485+00	\N
6a087f71-be20-414f-ad86-76846df27ad0	b0dfd33a-3d66-4133-b08f-9ce2366600ba	VvneoqbyMBfTfFphQpKLnnttrlNrfJvx	1	2023-06-26 18:32:50.20764+00	\N
d9038801-3040-47c7-aa43-47115afe2a8f	b0dfd33a-3d66-4133-b08f-9ce2366600ba	hgTYiBukxXQzVFdukoggnIIIwzWnsjFO	1	2023-06-26 18:38:44.54471+00	\N
4fba7184-619c-4171-b541-c1a87de38e14	b0dfd33a-3d66-4133-b08f-9ce2366600ba	arJyEyLICsQyapexYZUzqNyfLIaRfnyR	1	2023-06-26 18:45:15.629054+00	\N
32e4d30e-d79f-4eae-bc66-702fc0726a6e	b0dfd33a-3d66-4133-b08f-9ce2366600ba	VvGlOWwJKbRpfDwrsHhYXxqsmJJkMKSM	1	2023-06-26 18:46:58.491787+00	\N
3efdede7-f8a5-43c3-8c41-f0107f744831	b0dfd33a-3d66-4133-b08f-9ce2366600ba	bbbkruLysuYPJGznzraZMDgvsLLnMRcl	1	2023-06-26 18:49:03.74361+00	\N
3ff176fd-f385-487c-9edf-daa86801ceee	b0dfd33a-3d66-4133-b08f-9ce2366600ba	gSmoDyYPJtNFixFqTvwKacHLLhYzjBxJ	1	2023-06-26 18:57:33.801767+00	\N
ede5611c-6d9a-471f-863a-be3a9111c3f2	b0dfd33a-3d66-4133-b08f-9ce2366600ba	ZSfkqFTfGwaYZFSQwfUcRYbeMzKDhflE	1	2023-06-26 19:06:38.093948+00	\N
6ab419a5-7291-4ecb-8216-5f936745be62	b0dfd33a-3d66-4133-b08f-9ce2366600ba	yifrfHeVecLVIUpTkoXlBrIVKuKRDElg	1	2023-06-26 19:07:34.859553+00	\N
29439eaa-4f0f-4428-88c0-c01b78f72d07	b0dfd33a-3d66-4133-b08f-9ce2366600ba	eWPZsilZpPZJENdEjrrbGDLXlZUmYPoU	1	2023-06-26 19:16:13.792262+00	\N
15d2d642-fdd9-43fc-a43f-05abadb5319d	b0dfd33a-3d66-4133-b08f-9ce2366600ba	LuZgWUVVRvrfsspTlvyqmodhQcVcNmeb	1	2023-06-26 19:37:58.568542+00	\N
80ef2c2d-533c-45e5-bed6-57c2f9995745	b0dfd33a-3d66-4133-b08f-9ce2366600ba	LhMfyWxJiRLyqYMyJiuSkunTbFfGOMMy	1	2023-06-26 19:38:22.509843+00	\N
4962370d-11f2-423d-9322-5b022e068eb0	b0dfd33a-3d66-4133-b08f-9ce2366600ba	NVwCBSJDTajPFEwwRTWRQGbRYWUZZRLT	1	2023-06-26 19:39:34.033044+00	\N
e191851f-cecd-4424-bdb9-f9a589a7d143	b0dfd33a-3d66-4133-b08f-9ce2366600ba	QlZFCHOiHePtWoFzYdYqBddBjEJaHuyk	1	2023-06-26 19:40:26.640881+00	\N
c11bb855-6722-4bd8-9b84-bb9c2e6c9a42	b0dfd33a-3d66-4133-b08f-9ce2366600ba	HuHkKQQbHkHdSkkMNjtTEVBThSPyqfYk	1	2023-06-27 09:15:42.21608+00	\N
dc1d91a3-cd17-4f83-bffa-fb4489a332f2	b0dfd33a-3d66-4133-b08f-9ce2366600ba	wyHSffBVjfQEpoyCSeDGLSWkUEDDDZXh	1	2023-06-27 09:25:05.982522+00	\N
a0a2fd32-dc78-4b99-859e-d2fb7d9f1b6a	b0dfd33a-3d66-4133-b08f-9ce2366600ba	kdLryeLXLZxysSTnPRdFOoyeoaEKncHY	1	2023-06-27 09:39:31.173544+00	\N
e6489ea4-5a61-4114-a6cd-2a2112ff6a52	b0dfd33a-3d66-4133-b08f-9ce2366600ba	yJWMQcqNuLnbusCdROJnYTwnrybqVhJh	1	2023-06-27 09:40:56.079257+00	\N
55525bc0-c819-4ac8-a9b8-8f3f1020f9c6	b0dfd33a-3d66-4133-b08f-9ce2366600ba	ikRHpgCmNvHUKmagjqYpUDcIecmFnPuh	1	2023-06-27 09:50:11.081788+00	\N
cab52b41-2fe6-4e46-9be4-f0044fd25c31	b0dfd33a-3d66-4133-b08f-9ce2366600ba	uBdrtETouxatLrTmMBxUlxyYGMhYPOkK	1	2023-06-27 09:59:28.810874+00	\N
b958cc63-2d6c-4e80-89fb-6fd3ccc00626	b0dfd33a-3d66-4133-b08f-9ce2366600ba	kNVBHeVZbfQhHDDWoqmdHcsdTbOiiMln	1	2023-06-27 10:12:45.583472+00	\N
aaeeba97-686e-4d1b-8045-bb084737632b	b0dfd33a-3d66-4133-b08f-9ce2366600ba	ljdUtBVZDrPPCcfDOGcXEEmKPPRmLkYr	1	2023-06-27 10:16:01.552609+00	\N
082fed7b-f81c-45d3-a0b3-99b875f1f5e5	b0dfd33a-3d66-4133-b08f-9ce2366600ba	YnxchXjRsMrlLrPSFVlTrfEvcGHbqrIR	1	2023-06-27 10:32:45.553806+00	\N
7dc59458-9f28-4b51-b503-818833ccf79b	b0dfd33a-3d66-4133-b08f-9ce2366600ba	kjrYUeILJnaDUhgxnngdXKsgTGplWuNb	1	2023-06-27 10:38:00.421687+00	\N
14faa7bf-d430-4a93-82f9-2df08ac105ce	b0dfd33a-3d66-4133-b08f-9ce2366600ba	QCuqYCnrWoktiOBongKBuDPmCOtWSJfx	1	2023-06-27 11:19:02.824561+00	\N
18afb57c-12be-41cf-812e-08cc2d8a6e76	455163b9-674b-4666-ad6c-80f70584a97e	wSdxHnJUbpBxSGywoeoffuqIoZXOjEUC	1	2023-06-27 15:18:24.35852+00	\N
1f88c416-a43a-44bc-9123-26db4126a9c0	455163b9-674b-4666-ad6c-80f70584a97e	iePHkepLICILdkMwtMjRcmPCBonwisqW	1	2023-06-27 15:19:19.218849+00	\N
6593af71-b7d9-4119-9114-6c171f974e8b	455163b9-674b-4666-ad6c-80f70584a97e	YXpcsoEmpgdGdvKeLjSahbUkJwYKkhgk	1	2023-06-27 15:19:50.488517+00	\N
34e88357-4bc5-474f-9e9b-15cfa1b93789	455163b9-674b-4666-ad6c-80f70584a97e	UOyuQbYzuROugQQpUTeHoXTrBjcjQraR	1	2023-06-27 15:20:21.099742+00	\N
063d5781-2449-41ac-b71c-373e0eb114c2	455163b9-674b-4666-ad6c-80f70584a97e	JPGyOEGFRClFzacwphowpJwmISSEQmSI	1	2023-06-27 15:24:44.697508+00	\N
6b0a24a9-a151-4cba-8e83-c58e48c051d4	b0dfd33a-3d66-4133-b08f-9ce2366600ba	xIScsIJpHsLFEtpXxVggpuCmmrLcfFbJ	1	2023-06-27 15:27:32.439123+00	\N
8d6a11e5-3426-4e4d-b3f4-d4b25dccca91	b0dfd33a-3d66-4133-b08f-9ce2366600ba	FSPKBKeGPhuEswfrmgHnndajcJnHFgRg	1	2023-06-27 15:28:05.5306+00	\N
0e396156-ea55-4f53-9290-241eacce5fab	455163b9-674b-4666-ad6c-80f70584a97e	qlFtrWYSDTagsHGEcwOKxNqvkMWOMWeX	1	2023-06-27 15:28:47.549785+00	\N
7cb8c70b-13e3-462d-8906-fecc151646e7	b0dfd33a-3d66-4133-b08f-9ce2366600ba	fnZxYkpYSyCLNVOElxppKtydSUReHGlN	1	2023-06-27 15:36:17.404059+00	\N
15821c03-068b-4f47-940e-4f45cab74108	455163b9-674b-4666-ad6c-80f70584a97e	PCunEUUpaxldcjywCZgvhGNRsMpKHSTZ	1	2023-06-27 15:37:02.276317+00	\N
713fa077-a50a-4d78-a464-74fb50a2212d	455163b9-674b-4666-ad6c-80f70584a97e	oypXqdRFkflMgwEeZhUZpQGufQMJSoki	1	2023-06-27 15:42:01.044591+00	\N
8fd0f37d-bfb1-43b7-b25c-ec1ef1578a9b	455163b9-674b-4666-ad6c-80f70584a97e	AdjQyYZkWToOzmqbypvBpolawUPZSfhX	1	2023-06-27 15:45:09.217619+00	\N
1012e24e-b4d1-496d-9d53-a55ccba4bbe2	455163b9-674b-4666-ad6c-80f70584a97e	mkRvvLdPinktapjrXKZuqHzTbyNiZUbp	1	2023-06-27 15:47:48.228586+00	\N
d2bf9e5e-3cf4-4ff7-89a6-3eba5b471565	455163b9-674b-4666-ad6c-80f70584a97e	vOkYIXRRSRrzOKSPmSFjLdbQQdTqGFjG	1	2023-06-27 15:48:38.300077+00	\N
477e3989-385e-44a6-b0b1-809615ab70cb	455163b9-674b-4666-ad6c-80f70584a97e	PRIfkYpHCUQzBveBwvIsMjDhqmURuTRm	1	2023-06-27 15:52:01.271054+00	\N
28a2b0f5-6983-4f55-87bd-de581a09ac30	b0dfd33a-3d66-4133-b08f-9ce2366600ba	ruKHxpdfnMGgRHhiXOQHqsEVZkVAdYBk	1	2023-06-27 15:52:45.2366+00	\N
89a9adc5-9e15-47f6-bea8-76ad49ee10d4	b0dfd33a-3d66-4133-b08f-9ce2366600ba	dyFwAMpzJDTwFwvZxPnwsUZfAxwZgxjF	1	2023-06-27 15:53:20.727377+00	\N
4dac1e69-75a1-417a-a72e-5c9084ed8422	b0dfd33a-3d66-4133-b08f-9ce2366600ba	SicwVDGlgMrWExRcrBiQhiLRhaYXUrPU	1	2023-06-27 15:53:44.660984+00	\N
95108e2c-06cf-4594-832f-70fbaf51071c	455163b9-674b-4666-ad6c-80f70584a97e	OSkBoCnujGsOGASwiztmmuHCPYDiyMls	1	2023-06-27 15:57:24.236059+00	\N
618f9dc5-9e96-433f-9aa3-47f4812d78d4	455163b9-674b-4666-ad6c-80f70584a97e	aqWQuHEidLCOHtWoHtNmyLFitXikPPoR	1	2023-06-27 15:58:31.990875+00	\N
ceb53ddf-f5a5-429b-a5b6-15b3fd6096ef	455163b9-674b-4666-ad6c-80f70584a97e	uYcayhAuHEHjGGXtRleZxvQMadiHOiOJ	1	2023-06-27 16:00:50.822152+00	\N
aeef3387-5c6d-43af-a253-d2313f210314	455163b9-674b-4666-ad6c-80f70584a97e	dttldQXFbADFPvyTfZsFgLyxOqmbnYPn	1	2023-06-27 16:02:31.617498+00	\N
2e755dd8-62bb-41d1-8e84-947af3469031	455163b9-674b-4666-ad6c-80f70584a97e	XsYVKDVShNmrJPsOnrKBuyOZpHWXsLYv	1	2023-06-27 16:03:10.913723+00	\N
1ee6b9d5-20a2-4252-aeee-c67b0318bfde	455163b9-674b-4666-ad6c-80f70584a97e	UqWrLQrrOUlKUMFyPooUWHjpKyjBXouR	1	2023-06-27 16:05:37.508938+00	\N
d4eb3cec-9b19-4f6e-bf50-a58956c4bfe8	455163b9-674b-4666-ad6c-80f70584a97e	OIwJqRVDqfODieDSGgrzwketrQJLHUVr	1	2023-06-27 16:06:47.410018+00	\N
0834feb5-e8d7-45b3-94db-b9920f1d8def	455163b9-674b-4666-ad6c-80f70584a97e	orlGgoKJPUDupQmddCsDmgmnzvRYzHko	1	2023-06-27 16:07:21.647123+00	\N
4ece0c9c-ee9f-406d-ba9e-60ec648ad256	455163b9-674b-4666-ad6c-80f70584a97e	vVAhiuEAsDbEUqMpivLKazfvQTNpoaEu	1	2023-06-27 16:08:38.100725+00	\N
42ae7f15-1635-4341-b7b8-e000262a417c	455163b9-674b-4666-ad6c-80f70584a97e	IlOCFPJKPahcCyuorQwceMSckAmqlWMp	1	2023-06-27 16:09:07.426157+00	\N
df8889fd-26ec-49b7-918a-40137492378e	455163b9-674b-4666-ad6c-80f70584a97e	OZorKAwyNXegskpgFdOxSSLeYXWYpVUf	1	2023-06-27 16:11:19.633792+00	\N
b0a845cb-40e4-426b-905d-85940b8db715	455163b9-674b-4666-ad6c-80f70584a97e	eRlRMZKdEWSOUcArPQRlnGyyonWPORjM	1	2023-06-27 16:14:43.947381+00	\N
b1f845dd-dbd7-485f-8318-9769ce2a4b42	455163b9-674b-4666-ad6c-80f70584a97e	xfSaMEKXlCxcqgGcLLfgnLjXpoMuQLYn	1	2023-06-27 16:15:10.217146+00	\N
72238e18-3bd0-4c23-b857-8eb512726cb5	455163b9-674b-4666-ad6c-80f70584a97e	fqSCYVzxRsqHGNcFlkTUEjpMhlHrNEoS	1	2023-06-27 16:20:55.000004+00	\N
1bf9011d-2c4d-4839-995f-973c24d9a702	455163b9-674b-4666-ad6c-80f70584a97e	eUUzwWKBqyaJUOmKqEEYsthHxLbJsRxu	1	2023-06-27 16:23:49.103872+00	\N
0a0117ea-39f2-4960-8c10-2a1b1e0fe00e	455163b9-674b-4666-ad6c-80f70584a97e	irccXTtvfjvskdaWxHDiIDCrVipSTipt	1	2023-06-27 16:24:32.333028+00	\N
f9b39f83-284b-497c-9814-8a9ba93d237a	455163b9-674b-4666-ad6c-80f70584a97e	SxXthlFmtsbEjPsQlxUCbwYlJLUdQWeV	1	2023-06-27 16:25:46.572267+00	\N
30a1fb99-a265-45d5-9601-3e4e81b378f2	455163b9-674b-4666-ad6c-80f70584a97e	iTDmllusMycWsAIjCUfyIvEXMXKWXwPG	1	2023-06-27 16:26:45.931166+00	\N
42045938-240d-47f6-990c-c0dcd25f15a5	455163b9-674b-4666-ad6c-80f70584a97e	gYBpcGGdMkwDzCXVydFkORmUxQLXxOBU	1	2023-06-27 16:30:20.21777+00	\N
5f8ab4e0-f9c0-49a2-a596-1ad65b04afd6	455163b9-674b-4666-ad6c-80f70584a97e	IKZTmOkWHctmifMmgNISJrVwMeZiyrHj	1	2023-06-27 16:33:58.112558+00	\N
1691da13-21c5-4c6f-9b7e-b54e051b7051	455163b9-674b-4666-ad6c-80f70584a97e	dWElKSdcgYyWepWhmeNOplLDzTboHQsi	1	2023-06-27 16:34:48.88577+00	\N
fec6d569-5894-478f-a495-d3952c371567	455163b9-674b-4666-ad6c-80f70584a97e	eWoDrPLguSEvpQcXrYAVtMUhVcbNqXPI	1	2023-06-27 16:35:19.660165+00	\N
4eb42133-84b7-40eb-a069-2b345511e0b5	b0dfd33a-3d66-4133-b08f-9ce2366600ba	DLgjYrimIWkvGbXtFxcWuRZApYsGiYvk	1	2023-06-28 08:29:26.27917+00	\N
f6a5402e-cab0-461d-854d-392760cc8ae8	b0dfd33a-3d66-4133-b08f-9ce2366600ba	iNEyPQJiWioygPemabZUKnSnoagyJsfG	1	2023-06-28 08:35:15.957954+00	\N
a8dd4629-2ede-419f-a6ae-ddedef5a5bfd	b0dfd33a-3d66-4133-b08f-9ce2366600ba	BjqySXlifzaWlGtpCFEOBbARdNYVZmXR	1	2023-06-28 08:37:59.82559+00	\N
86e68706-7235-4a43-8aa5-94a84b5c99bd	b0dfd33a-3d66-4133-b08f-9ce2366600ba	oxElbciJdoZkztPqvWJtYLFUUgCJLGQt	1	2023-06-28 09:58:14.950636+00	\N
59b624b1-abf3-4b92-8c80-f15ad4adaf62	b0dfd33a-3d66-4133-b08f-9ce2366600ba	iLhTsHGGeKNnVfDfrMkICayOBArXSbRu	1	2023-06-28 10:01:39.04745+00	\N
7c3dcee1-c08c-4eda-ad93-a0facd448a78	b0dfd33a-3d66-4133-b08f-9ce2366600ba	bTHKqiKOMgkkinEGkPQtQZbYJiFOGPUG	1	2023-06-28 11:53:32.675105+00	\N
7d3c9755-9c11-49be-ab7e-f2e4dac3bdc2	b0dfd33a-3d66-4133-b08f-9ce2366600ba	FAWllxMHoAROXiTgqiyRHFTgNBsAdYYd	1	2023-06-28 11:54:29.503827+00	\N
fdab4e76-3509-4810-a89e-57f740ccdb24	b0dfd33a-3d66-4133-b08f-9ce2366600ba	lQtuTKssvmoWjraaRWpKDWKVyNoPSnJH	1	2023-06-28 12:50:18.194931+00	\N
19d449c4-e96e-462b-a9f0-f04d7db54021	b0dfd33a-3d66-4133-b08f-9ce2366600ba	DwBzzVOupUxXYZQHbykfCohqkIBSdeYl	1	2023-06-28 12:50:39.494492+00	\N
577fe2e1-f060-4969-847d-bb76cd1ae4a2	b0dfd33a-3d66-4133-b08f-9ce2366600ba	IqzmGjdYpFfgQEWoREceNuFWXwgkdgkt	1	2023-06-28 12:51:04.373991+00	\N
2bb07b06-3fb9-4c6a-b296-26d93663e657	b0dfd33a-3d66-4133-b08f-9ce2366600ba	avKUicWMUyiCcDEHteQRJRZGRMDitDqu	1	2023-06-28 12:51:30.653845+00	\N
23de0bb5-2502-4d42-add7-f1b204eec742	b0dfd33a-3d66-4133-b08f-9ce2366600ba	iRWPpYgUTIvfGsSiXrazszkGmEQcTmvJ	1	2023-06-28 12:51:45.10203+00	\N
7518ee26-d0a6-45fd-a84d-4788ccf8a019	b0dfd33a-3d66-4133-b08f-9ce2366600ba	YnlSpiOQvdqFDVbOOQIivdqeBDZciEgP	1	2023-06-28 12:52:06.331018+00	\N
38eb8817-3f77-460d-925e-0f24b01ecdb6	b0dfd33a-3d66-4133-b08f-9ce2366600ba	MmHkMLlfdOrLciGvkuFMPwHvKmcRdZuI	1	2023-06-28 12:54:38.244794+00	\N
66983b4b-202d-4bda-b96f-1b99da5f6256	b0dfd33a-3d66-4133-b08f-9ce2366600ba	nZwTosGNNQoeEBUgKWKZhjgaqtjGxhsM	1	2023-06-28 13:16:59.827628+00	\N
aacc0952-b12f-4407-8a3e-f1f9054ec204	455163b9-674b-4666-ad6c-80f70584a97e	OcBfLyQqwyplxCogtkPgqzxJJVNQyAAS	1	2023-06-28 15:20:05.434481+00	\N
abbb3694-ae20-4bb3-bb60-fb188f86f540	455163b9-674b-4666-ad6c-80f70584a97e	CuWpvpxnIxwmKvnuWOsbHfliMRWUgUMf	1	2023-06-28 15:32:37.898321+00	\N
5ca9bf57-4a24-41df-adf1-de1a02dc461d	455163b9-674b-4666-ad6c-80f70584a97e	SfdYcTSnROHfPuQoVIHhPLowrbQLOldD	1	2023-06-28 15:33:29.566155+00	\N
606806a8-1556-421e-b2cf-6b42fc00a915	455163b9-674b-4666-ad6c-80f70584a97e	OayEzoiWaumXKYuGrLNPSSFPVHLHHprg	1	2023-06-28 15:42:13.904174+00	\N
b93a1194-a003-4e98-bd64-4d76a7601d89	455163b9-674b-4666-ad6c-80f70584a97e	miwecXdELJhwjJawvcPGHGyozcVZoleI	1	2023-06-28 15:47:46.696946+00	\N
f6403cff-8a5b-475a-a52c-1bc45b1898ae	455163b9-674b-4666-ad6c-80f70584a97e	JfYBgIdWUzYahfYxWGkXaHvFqqNGnmDK	1	2023-06-28 15:50:59.979214+00	\N
52641682-854a-4e8c-b282-e08524c17fb7	455163b9-674b-4666-ad6c-80f70584a97e	wldixczyaFTOgtnpErgzurmCcOhCTZTE	1	2023-06-28 15:51:27.569163+00	\N
c73d7d51-9f0d-4db7-923b-0955da3537cf	455163b9-674b-4666-ad6c-80f70584a97e	HQldKwCtPySvubMDsgcBAyhbYEohCdkU	1	2023-06-28 16:12:13.841496+00	\N
89e0b22f-3d2e-42f5-a061-cb0d643e5862	455163b9-674b-4666-ad6c-80f70584a97e	cufYWguhdENfgFhiUWOHlcoJTQqAoxGK	1	2023-06-28 16:15:30.132151+00	\N
b408691d-0608-4867-8d3d-8f05a6d32667	455163b9-674b-4666-ad6c-80f70584a97e	CoYSnTxhodxQhyVmkmrFkeufjKKXesQp	1	2023-06-28 16:26:12.724435+00	\N
8bbba1da-5dbd-4f46-b774-af58b5443528	455163b9-674b-4666-ad6c-80f70584a97e	gVMvQehGBdwCuQDPRUfvIswJvYwgeheR	1	2023-06-28 16:28:35.65337+00	\N
c24bc643-8ab3-448a-a233-85c579ab6ae1	455163b9-674b-4666-ad6c-80f70584a97e	VqhQGNEnlYwtcbJgphYmmUJVhOzoNEgZ	1	2023-06-28 16:31:03.804305+00	\N
0cd99dcc-edb0-445d-a054-8aedb919b3e4	455163b9-674b-4666-ad6c-80f70584a97e	LLqDntllKxjlaHgKyqNqTlCyXaNfYJCf	1	2023-06-28 16:43:51.421624+00	\N
0d4dc741-9b18-40bd-9698-8d85980b2de0	455163b9-674b-4666-ad6c-80f70584a97e	DMZEPfnMBgGperWOMZXbGRvjpfJKhdZj	1	2023-06-28 16:48:05.544506+00	\N
74748a5b-b737-4150-80c2-01275cb36347	455163b9-674b-4666-ad6c-80f70584a97e	YovgigotpPZNnwucPqJFXyTHyTunDnHy	1	2023-06-28 16:57:28.389349+00	\N
1182111a-7b8c-4f1f-b275-89253f483dba	455163b9-674b-4666-ad6c-80f70584a97e	rUChfJRQHJoTsspVXXgDPvITnHSYCHuv	1	2023-06-28 16:59:48.743359+00	\N
bdea7d2e-89ac-47e1-9746-fe21f5598de5	455163b9-674b-4666-ad6c-80f70584a97e	jeGliVuJFjDmdUPPyQMFnQIUtdbFPNvu	1	2023-06-28 17:04:45.159621+00	\N
3677496d-fcce-42a5-8b92-e1a90e005c4a	455163b9-674b-4666-ad6c-80f70584a97e	bPGQKXeJRhwfGyvsYzIHrPuSUQklkHtd	1	2023-06-28 17:24:54.734537+00	\N
c65a29d4-bede-47af-ad56-cdf05c539b61	455163b9-674b-4666-ad6c-80f70584a97e	iaBLrITIwjDFPnQrkLlTYYRHWaClugdI	1	2023-06-28 17:26:13.862607+00	\N
a618be2a-8ce7-40bd-b0a3-4f64934c4918	455163b9-674b-4666-ad6c-80f70584a97e	NhasxeRaPFstxNWsiXMVvMCKCkpSeZJW	1	2023-06-28 17:38:27.875121+00	\N
be2b2fc4-bbb3-48b8-ae60-b09238fd6f39	455163b9-674b-4666-ad6c-80f70584a97e	ApQbZLxNjlyWpdnxliYEJxJkrXpoMBkU	1	2023-06-28 17:39:43.415158+00	\N
39684e38-b4c9-4988-9605-00bf7c481eca	455163b9-674b-4666-ad6c-80f70584a97e	QqCiSmhlvPRdYKtyVlLNzZaFnpmMyhHT	1	2023-06-28 17:40:53.045595+00	\N
98618753-d94b-480a-bdcb-421a0bec34b2	455163b9-674b-4666-ad6c-80f70584a97e	okRLBtwPshopXNZFOouwSZVSBjytfBJt	1	2023-06-28 17:42:42.072361+00	\N
81a51d40-5e67-4e3f-ba63-7bacc48e6e6e	455163b9-674b-4666-ad6c-80f70584a97e	ZxKmNxFAiLUPinSLaJNEmHqGNcmkbyiF	1	2023-06-28 17:44:26.536252+00	\N
90070af4-250c-42f9-82ab-f9a2aee90ffa	455163b9-674b-4666-ad6c-80f70584a97e	slpqvfEZtwvQZvVDRZqlfHJBUHregRBm	1	2023-06-28 17:48:54.67488+00	\N
6479ccdf-a07e-4b39-9737-94f0dc66a2dd	455163b9-674b-4666-ad6c-80f70584a97e	VvONjQpCcbrXWbvrjGayLiSvKQXHldFD	1	2023-06-28 17:50:26.446719+00	\N
60679fb9-bef2-4f54-97ae-25ce5428ea3d	455163b9-674b-4666-ad6c-80f70584a97e	inkNLiaBqXQPtDONmkLFKaUpNDUkcitT	1	2023-06-28 17:53:07.927925+00	\N
5c0466b9-d955-4a76-b6e7-a105f39d5615	455163b9-674b-4666-ad6c-80f70584a97e	pMYZXWDvsxlTQWBuTqHOXMDqxPhsBtSZ	1	2023-06-28 17:57:23.820051+00	\N
7a0e3601-70af-4c51-b104-3cdb138aaee3	455163b9-674b-4666-ad6c-80f70584a97e	LgkSthTywvwQgSZQPCymBiUmHQQSLSYD	1	2023-06-28 17:59:21.173903+00	\N
b21b993b-3f20-4f3f-8146-9fa41c96fe39	455163b9-674b-4666-ad6c-80f70584a97e	nBwPBDlCaGKQLkITLGigmlNRkwHnDqaw	1	2023-06-28 19:04:36.113198+00	\N
7c974534-5de7-457d-8b2c-1d1e697ddefe	455163b9-674b-4666-ad6c-80f70584a97e	UOClmTdqMHNxxXYfqhCsiwFZFhwxwXvP	1	2023-06-28 19:05:49.401567+00	\N
3cde3609-072c-4a32-b9b5-6d91fc11d17b	455163b9-674b-4666-ad6c-80f70584a97e	nsJUemCsUwKCVKkULLfmBqRMrZQkWVTr	1	2023-06-28 19:09:31.843534+00	\N
3682070f-e3cb-40db-83a5-b3524409803b	455163b9-674b-4666-ad6c-80f70584a97e	RvYONvghfBrDnOpwpEMCaBIGJwFspQdX	1	2023-06-28 19:13:52.211064+00	\N
acfa9112-84f0-480d-a15c-e814d727372f	455163b9-674b-4666-ad6c-80f70584a97e	rbldYYBWaBBmoOVeBFweWRrNHMrpqdna	1	2023-06-28 19:20:55.342278+00	\N
b9e317b5-c75e-4a09-878c-1ea3a06e29f1	455163b9-674b-4666-ad6c-80f70584a97e	lodQiWmtmKvVRvNatWqxfVQEyXpdbUQd	1	2023-06-28 19:21:14.226784+00	\N
519b47ac-ffbc-4b85-ab94-8fafc6a5e197	455163b9-674b-4666-ad6c-80f70584a97e	MYfLqphPrPVsJdDXpXHHDMHSLTgyQxTa	1	2023-06-28 19:21:34.056874+00	\N
91b4a255-0e7c-4b73-a719-827bd09165fc	455163b9-674b-4666-ad6c-80f70584a97e	CgoHSWpriyWyIhkqnlenKBkiIEnvowfu	1	2023-06-28 19:21:54.3003+00	\N
a39b6e67-db3b-4dfa-ad94-2b52b2db6193	455163b9-674b-4666-ad6c-80f70584a97e	aXxCQSwPlpbkJBiYCqGmcTwKnrpjjnUr	1	2023-06-28 19:22:19.206+00	\N
93b5b7c1-98c1-4f88-a67b-b12781b941a2	455163b9-674b-4666-ad6c-80f70584a97e	HugfFWBzgGInkbunmBlznOCaVoVpaOSL	1	2023-06-28 19:22:57.242519+00	\N
55375c11-dbce-47da-9df9-ef70a757bb33	455163b9-674b-4666-ad6c-80f70584a97e	ldkAauCjkPcfbmVYtdlDZuSSYUAjAhqc	1	2023-06-28 19:23:20.534634+00	\N
ebbc83ea-782e-41e6-a9d1-201051dac23c	455163b9-674b-4666-ad6c-80f70584a97e	JVSrDZtiynhCYdoldXqnGtDXrlloegYB	1	2023-06-28 19:23:49.330771+00	\N
a3c1cd20-99a7-469a-83ea-2638c14d6280	455163b9-674b-4666-ad6c-80f70584a97e	ElNbXnFpQETFsShPuSUBRFprMrPaLbqd	1	2023-06-28 19:24:13.13391+00	\N
717bc64e-9b5e-4f49-a253-6c4f7d750e9b	455163b9-674b-4666-ad6c-80f70584a97e	ozjrRxfXIblXRXImUWPSXhvLDjqjLNTD	1	2023-06-28 19:24:40.795496+00	\N
f53a0a78-187c-4c0e-ab64-0b407c26fe2d	455163b9-674b-4666-ad6c-80f70584a97e	xxOdTfxWnuWjcXscVjtInmAXJqPluOdh	1	2023-06-28 19:25:04.718101+00	\N
1d0e5107-c40a-4130-8255-c7d5fb6ddfc5	455163b9-674b-4666-ad6c-80f70584a97e	vqkUrfPPCpPupcSYgNIFqmhucvaPMovk	1	2023-06-28 19:25:25.571076+00	\N
0c343498-3432-4668-abae-9822ced85699	455163b9-674b-4666-ad6c-80f70584a97e	ElcxFLrtCiJrYpMOChCCFIybKCRAeTjG	1	2023-06-28 19:28:01.127708+00	\N
e47b968d-2272-4783-b729-afaf64ead85b	455163b9-674b-4666-ad6c-80f70584a97e	RTXucQleQREqgxxOqrdJhFueaiKLqDHg	1	2023-06-28 19:28:17.925087+00	\N
09f5e2ba-264e-4a86-9918-6a7926a71f8b	455163b9-674b-4666-ad6c-80f70584a97e	xYqPtFMOMPvtqaXFGSCgsdfmEMFVBkSn	1	2023-06-28 19:28:39.249669+00	\N
fc252197-7232-41d2-aa76-792e283b1d8f	455163b9-674b-4666-ad6c-80f70584a97e	mCcsWmtBUMdLYCISwpXKkWajSczeDDPt	1	2023-06-28 19:30:58.98936+00	\N
da221e25-330a-43e4-9cfa-76deffaa286a	455163b9-674b-4666-ad6c-80f70584a97e	cFldGcHUNWUUFBFHpInxbtMEpXgkRgbr	1	2023-06-28 19:34:00.614287+00	\N
eb835fd4-20ed-4239-899f-0adba9836dfa	455163b9-674b-4666-ad6c-80f70584a97e	HNqeXaNlRigzbXhVshbXbVpMGxTGkXSZ	1	2023-06-28 19:42:11.341426+00	\N
2a2a2a4a-359f-4689-9e0c-d1448ec3c86e	455163b9-674b-4666-ad6c-80f70584a97e	gZjiRynrMdvKFYKciKhewksaucMUqMQC	1	2023-06-28 19:46:01.728716+00	\N
c269c8df-8ab2-42ce-a663-f0a4a4318060	455163b9-674b-4666-ad6c-80f70584a97e	aMZaOiObMfkFNTIOMdEDinLgtBleHQoi	1	2023-06-28 19:46:48.767648+00	\N
1e740631-29d0-4cdd-a10c-fa09bf04429a	455163b9-674b-4666-ad6c-80f70584a97e	ZQOdVxkHLlVvlxfWhxARNxvUgFncDHdE	1	2023-06-28 19:48:02.272799+00	\N
53dbaa25-802f-46cc-b4d0-5f4a0341e2ee	455163b9-674b-4666-ad6c-80f70584a97e	ISUIWZeDBKazghjsOiXUmIeKSTemSTRt	1	2023-06-28 19:49:40.863746+00	\N
893ba9ad-d70d-4974-acbb-a1d0aed6538f	455163b9-674b-4666-ad6c-80f70584a97e	GszSIiwruEoHtTRNjdeaRjMuilTBgaaE	1	2023-06-28 19:50:01.072715+00	\N
6b18c3b1-0359-4151-9000-149d901482e2	455163b9-674b-4666-ad6c-80f70584a97e	VzhoNJJawyDxsyhXXMvBzECeXzEmiTKX	1	2023-06-28 19:50:46.936179+00	\N
565f7743-3fdb-4e65-9def-743fc33784d4	455163b9-674b-4666-ad6c-80f70584a97e	kVHbHPfMGgDRGkbGsfXlGMohBUdjteST	1	2023-06-28 19:51:13.50011+00	\N
6253998a-c7ad-41a4-88e0-ec9dca9a4fab	455163b9-674b-4666-ad6c-80f70584a97e	QYwtTsCiVcUfavqOkFTiBjrKxKyYbLbu	1	2023-06-28 19:53:04.113713+00	\N
3efebf5c-6aa6-4e93-8fa8-a2fd34d6031e	455163b9-674b-4666-ad6c-80f70584a97e	isryYemcqzUTKxlQgNJioMVGpDJbvHtE	1	2023-06-28 19:53:49.463204+00	\N
32f736f9-9fdf-4576-a2ad-20a7d64c0871	455163b9-674b-4666-ad6c-80f70584a97e	OlkkTNYjOVqLcWqINhQXsJNquCXqLleF	1	2023-06-28 19:57:27.981081+00	\N
3914a5be-1c6f-4dfd-8fd0-262762f033ef	455163b9-674b-4666-ad6c-80f70584a97e	OMhkElahxGpOteNijjwbYjKXJzBNbqSM	1	2023-06-28 19:57:57.99991+00	\N
abc3442b-fcff-4a90-af92-4df514219080	455163b9-674b-4666-ad6c-80f70584a97e	vvBHpXrtatbMHOuoqJnvcUypUGXrXqfF	1	2023-06-28 19:58:18.700345+00	\N
60e6bd16-5371-4193-a6c1-cb22a7ca9bf8	455163b9-674b-4666-ad6c-80f70584a97e	CSYsnLLoroQNaSdufxTuGCkLhSRdSYAm	1	2023-06-28 20:03:15.116497+00	\N
a2fd2847-9639-4ba4-beab-b09f63ec5295	455163b9-674b-4666-ad6c-80f70584a97e	iIxQVzPakhrpxnMcptWSjtOwSvMmiGBV	1	2023-06-28 20:05:55.474968+00	\N
379d5e01-afe7-486d-97f8-6b6bd21a2f17	455163b9-674b-4666-ad6c-80f70584a97e	UVJcfyiWXPDNpXTNMzIfPdjGpyCGRByn	1	2023-06-28 20:10:54.523596+00	\N
9f87dcb3-5966-4038-b6ce-920433abdaf5	455163b9-674b-4666-ad6c-80f70584a97e	vsuLkwySfREpGtPoKJjgLiXJvFfgfqsi	1	2023-06-28 20:34:02.882546+00	\N
33ac4747-175d-44aa-9bbd-d25fd4446291	455163b9-674b-4666-ad6c-80f70584a97e	YDKHDOhSmYGPTeddcJSxEcGgObGfSRZv	1	2023-06-28 20:38:48.787132+00	\N
89ccf655-8f5e-430d-ace5-4f04aa2e11d9	455163b9-674b-4666-ad6c-80f70584a97e	tOjJwSmYdGlxcamRLLyKKCTOmzGqsBUL	1	2023-06-28 20:42:54.638967+00	\N
9fc7a39e-6a41-4451-8ff0-c3d20cc63c03	455163b9-674b-4666-ad6c-80f70584a97e	iuFtrMwRVphnIkiVvqtYCPlpjyYEFApp	1	2023-06-28 20:48:05.702939+00	\N
1a79c707-8f43-4aa3-8da8-bfaebae373ad	455163b9-674b-4666-ad6c-80f70584a97e	hIAXRWTvMjnuNMdPyvPwBxuRQtlBZXyy	1	2023-06-28 20:50:34.746945+00	\N
7f842090-22b0-4266-982c-2255982d6b14	455163b9-674b-4666-ad6c-80f70584a97e	FesmMaCEPmLUtMXgGyFZZIZuMHfrLNiX	1	2023-06-28 20:52:29.43085+00	\N
faa66190-7700-4c5f-afa7-10a283d6284e	455163b9-674b-4666-ad6c-80f70584a97e	lVcKSHjcMSKsPGIJUoSiepHFwOYyFSIa	1	2023-06-28 20:55:37.603571+00	\N
c12897d9-8528-44ea-89d2-18523a7f4232	455163b9-674b-4666-ad6c-80f70584a97e	bbbiXQBOidEBvbDgIadDDgWQugXuOhjt	1	2023-06-28 20:57:55.88896+00	\N
34936598-c568-4921-a29a-ec1f996a35df	455163b9-674b-4666-ad6c-80f70584a97e	RlxuwjklYbpyYlilGKTNrxsgjsFckFnC	1	2023-06-28 20:59:29.760768+00	\N
5d74a014-4565-43bc-9b37-e73cad3ef157	455163b9-674b-4666-ad6c-80f70584a97e	gULAjneaaTjZkwrQyPtvIbSsxAHILZek	1	2023-06-28 21:05:23.402481+00	\N
0399a814-f6c8-462e-9b8d-d522ceb2b086	455163b9-674b-4666-ad6c-80f70584a97e	cqmtXjVKJIJUWRFoCUxnfXXKAmOhSVXE	1	2023-06-28 21:08:12.629236+00	\N
d5fa970d-e287-4d4a-aeac-e3d838f8e1bd	455163b9-674b-4666-ad6c-80f70584a97e	JHebbpzttUVuEkhNrOJQVIUCDTZWPVWT	1	2023-06-28 21:12:18.131679+00	\N
3294dcd1-f858-46aa-bf2a-be360faab6c9	455163b9-674b-4666-ad6c-80f70584a97e	BYHVqnzytaCxNfnNRGabFlXtwTckdBMq	1	2023-06-28 21:45:37.446176+00	\N
9ac91f7a-5e67-416b-8861-ff0e1b0a2238	455163b9-674b-4666-ad6c-80f70584a97e	CLPIHLcxYiPPQysYnTvtCRxRbUwMQJUb	1	2023-06-28 22:29:22.11202+00	\N
db0e7603-c1d8-4390-b845-813d20fc8e14	455163b9-674b-4666-ad6c-80f70584a97e	SPpjtUNJOtlREXQtsirtalXwegvANXze	1	2023-06-28 22:43:31.313131+00	\N
3f5d2c0c-3815-4071-9a3d-3298501bdc13	455163b9-674b-4666-ad6c-80f70584a97e	JFhSHytciskxFTEaojHfzkpzELGJBXlM	1	2023-06-28 22:46:28.952068+00	\N
a90f6b52-2ec1-43e7-b409-235a6ca59e3f	455163b9-674b-4666-ad6c-80f70584a97e	lktKiZqUvYcrTKylkkSSRwRHTwmpKOoC	1	2023-06-28 22:55:08.021992+00	\N
cf9f4fa8-693b-48c4-b818-9037e30a16e2	455163b9-674b-4666-ad6c-80f70584a97e	GVQlEGtNqFUbTZMPbUeEJQxphRPHKSlV	1	2023-06-28 22:57:29.433005+00	\N
355a8d9f-c22d-44e6-8119-fb90e18853ca	455163b9-674b-4666-ad6c-80f70584a97e	mSjHghaSmRaiOckZqsbCvmDuduxljgRV	1	2023-06-28 22:58:49.067549+00	\N
a8d73afb-99f6-454c-80b4-971cc2271719	455163b9-674b-4666-ad6c-80f70584a97e	GtcFnHhenkZoUSevGotQrzbNCftZsZeV	1	2023-06-28 23:01:58.763835+00	\N
6c0c4560-d2ff-4c26-9ffc-dfcfe8a1885c	b0dfd33a-3d66-4133-b08f-9ce2366600ba	kcCmoxmqrlwsirVYmBfuRvpQZLwXQXiY	1	2023-06-29 08:14:32.650228+00	\N
d9f06876-48ce-4ec3-8448-fb5e67a71d91	e3848a2a-197f-4344-9d1e-12d78d0c45d7	QXqbgtVNmppBIJOEicLgrPOsbSDselLi	1	2023-06-29 09:42:44.418958+00	\N
009940a8-b001-40cf-80f9-ab0e8bfaaa20	e3848a2a-197f-4344-9d1e-12d78d0c45d7	BLaOvbVkwtUmepESZhkpFjMAJhAJPHLw	1	2023-06-29 09:44:41.218922+00	\N
36a0a82b-6791-4b75-9728-04add811eb60	e3848a2a-197f-4344-9d1e-12d78d0c45d7	vcsjsPOsRGjMljWSElCBeDeXkqfadWvT	1	2023-06-29 09:48:25.284358+00	\N
8d8b2c19-9e76-4dcc-92b2-a275a8dd79f7	e3848a2a-197f-4344-9d1e-12d78d0c45d7	FdXuYsofVAWInxBBiWFlyhZfFERJNDiu	1	2023-06-29 09:56:17.945355+00	\N
1e0beba6-d53d-48f2-aded-fabf69c68185	b0dfd33a-3d66-4133-b08f-9ce2366600ba	ZTnHAONxaYsnzSKxOfTtjoOpPLwCYjFC	1	2023-06-29 10:05:37.848079+00	\N
8a1b7321-291f-477f-a068-ce3245525ce1	b0dfd33a-3d66-4133-b08f-9ce2366600ba	ZhZTMwfqooNbeNTLXaJULfIQuPNwkPHP	1	2023-06-29 10:12:40.193448+00	\N
3aef5fe3-c210-4338-a464-672166ef396e	5896c3e5-4d44-492a-abff-80a016a7a0b1	OcsBbdYVneouCUWpzglkXKNTghaVGgZF	1	2023-06-29 10:29:38.865876+00	\N
866a6430-9d6e-41c1-9d75-0edf59151546	5896c3e5-4d44-492a-abff-80a016a7a0b1	ynpKpPpJCXxJdmfzmQjYefydxuHdMMOQ	1	2023-06-29 10:30:05.299122+00	\N
d1626b96-4236-4859-92f3-984c5255b5a6	5896c3e5-4d44-492a-abff-80a016a7a0b1	wituNcvuNphnmEQSbUUXoCjFrHhXPaLz	1	2023-06-29 10:30:49.194825+00	\N
4ef22b8c-ca6d-4780-8986-f287679ef917	5896c3e5-4d44-492a-abff-80a016a7a0b1	QKCOabuSdnNtlVKSTrBiGXPmNUPXbiyV	1	2023-06-29 10:31:07.015274+00	\N
44009fc9-06b7-4972-a06b-d1d5be7e2e87	e3848a2a-197f-4344-9d1e-12d78d0c45d7	HGcRVIPGSJtUkbtejRyrYsMxPcaPmWuu	1	2023-06-29 10:42:38.604741+00	\N
69dda5cc-87b5-47bf-b294-95d50af53d92	e3848a2a-197f-4344-9d1e-12d78d0c45d7	FHyGznICuuRtXebtsjoGyIWEavCDsSrb	1	2023-06-29 10:44:54.69927+00	\N
391752d7-4bc3-457b-aead-50a6e00b6b57	b0dfd33a-3d66-4133-b08f-9ce2366600ba	YsUTYQKxGtXTZiOgRPrdTpaPagdiIdjf	1	2023-06-29 10:45:27.8137+00	\N
87bb508e-fb1e-4dae-9cff-cd85362a4d58	e3848a2a-197f-4344-9d1e-12d78d0c45d7	smIXLIWaZlqVnCpLYBZYbDlHabuPRfvH	1	2023-06-29 10:46:33.774518+00	\N
f9773b23-2e41-4fe2-8075-335c4ec1c881	e3848a2a-197f-4344-9d1e-12d78d0c45d7	VONJEenbdDgxneqbrTbSmxabJpFwiONa	1	2023-06-29 10:47:25.172247+00	\N
ce7c8c9d-413e-4890-8c9a-5c21385d35c2	e3848a2a-197f-4344-9d1e-12d78d0c45d7	OkAApPWmPHVQRoCSREMPhYQQoymYwDdC	1	2023-06-29 10:48:30.552363+00	\N
a6297388-3ef6-4583-8551-acf011deb622	e3848a2a-197f-4344-9d1e-12d78d0c45d7	pVrILLTJhsfzDDdBwrnKBRjRSHTxMZuo	1	2023-06-29 10:49:53.998513+00	\N
620a18e3-cfba-4c87-bfb8-e32b845475e0	e3848a2a-197f-4344-9d1e-12d78d0c45d7	PsGkpieCbJFWoYvZgrAXWvtsXfQWSqmA	1	2023-06-29 10:53:57.132473+00	\N
ca642d6e-29ab-4cc7-8d53-7493819d361d	e3848a2a-197f-4344-9d1e-12d78d0c45d7	MUWOSszLrGvGkNwEOeiTAVZtrkdPnOXP	1	2023-06-29 10:59:14.143034+00	\N
34977671-a1c0-4ab1-abcf-af58603e73fc	e3848a2a-197f-4344-9d1e-12d78d0c45d7	MSNmkJdOXjIsKEHqUWuXETuMmOuakQvp	1	2023-06-29 11:47:45.244939+00	\N
ea049199-741e-4e6b-87be-ec2cc5e62b95	e3848a2a-197f-4344-9d1e-12d78d0c45d7	xMKmbPfORxEKjKNqIuJJoXkoJFHswWNt	1	2023-06-29 11:56:12.51204+00	\N
47d19896-48ba-4b53-9b07-1514da13cc54	b0dfd33a-3d66-4133-b08f-9ce2366600ba	JzKrXsclyEVYYQYvBLwAsTQrTvufostB	1	2023-06-29 12:04:55.336061+00	\N
44286670-ecca-41f9-bcc9-4465499ff582	e3848a2a-197f-4344-9d1e-12d78d0c45d7	FzLieKSmyJknZGVBOylpwCCLmmcoBEGQ	1	2023-06-29 12:07:03.179836+00	\N
64d36395-cd57-42ee-8f65-79e9aabf2984	e3848a2a-197f-4344-9d1e-12d78d0c45d7	QFkLLyaOlUvEOBuuyjpTEMyaRaEOWdGM	1	2023-06-29 12:08:19.786484+00	\N
4fa29f7d-1f67-4240-9471-474e6d4e1b73	e3848a2a-197f-4344-9d1e-12d78d0c45d7	GTNAKWIsKHkkgeFntOfzwQGNmUViyRTh	1	2023-06-29 12:10:20.740572+00	\N
a0ecb48a-570a-47b1-b7a8-9b33bc558b82	e3848a2a-197f-4344-9d1e-12d78d0c45d7	GnTmtkpeIMZCjsLMzdaTgeaSoaihGZDh	1	2023-06-29 12:17:57.996497+00	\N
b35d74bf-42ce-4c96-a717-575cb2143d2c	e3848a2a-197f-4344-9d1e-12d78d0c45d7	ZLqFvVzSqNxnLIwOfeiDhOJGjZEXjpVK	1	2023-06-29 12:19:07.337412+00	\N
353e1614-1bec-4dca-8eda-345f5c38b69e	e3848a2a-197f-4344-9d1e-12d78d0c45d7	POjJWqACVumLdujFnSwKQWKxnZfZuaEM	1	2023-06-29 12:21:05.378025+00	\N
0f38d1d4-70c6-443c-8811-60aa0545ca73	e3848a2a-197f-4344-9d1e-12d78d0c45d7	FZaraWsaLNZvUYUDOxyKuLxBcHXVhwRo	1	2023-06-29 12:22:05.668675+00	\N
1253a602-f212-466e-b31d-6e3a5fcc27fb	e3848a2a-197f-4344-9d1e-12d78d0c45d7	mQhDskPjvGtXnJBCnsMisSgaWTnvOzCU	1	2023-06-29 12:22:45.472358+00	\N
5af53b6a-1446-4360-a6df-0dd2eed2dc80	e3848a2a-197f-4344-9d1e-12d78d0c45d7	WTYsVjkxcGFfxlkwVzedRgEHVkxdudAG	1	2023-06-29 12:26:20.773349+00	\N
32227642-5ae2-4fa5-9af7-26887af312db	e3848a2a-197f-4344-9d1e-12d78d0c45d7	npIjPiLDqbHiLmgMkqrcipHLZaZXnbFX	1	2023-06-29 12:30:36.082758+00	\N
6d67acec-7dff-4071-815e-aa31af2676ca	e3848a2a-197f-4344-9d1e-12d78d0c45d7	MBsBGrUFQcuYbDHFKkuHolBJYavFArdV	1	2023-06-29 12:31:24.588517+00	\N
bfe84c82-e97c-4748-9a83-52f786adb1c8	e3848a2a-197f-4344-9d1e-12d78d0c45d7	GpUjoQLfXyfSEJdfVxCUfCcbVUYvuXPl	1	2023-06-29 12:34:03.14076+00	\N
1848e869-8c1b-4664-8328-2c1c37717887	e3848a2a-197f-4344-9d1e-12d78d0c45d7	EDnqOvmwjGAUhTipRupbUdFtYwaOiDOW	1	2023-06-29 12:35:04.931729+00	\N
8aae1e9c-87dd-48f8-8bdd-7f4027cc62c5	e3848a2a-197f-4344-9d1e-12d78d0c45d7	pskhoiBuCgmfXroLDUUyfzjGujnjIrcj	1	2023-06-29 12:41:25.0074+00	\N
9b733a2e-f67c-44e6-924e-867dac1b4541	e3848a2a-197f-4344-9d1e-12d78d0c45d7	reMoxMeiCrkNExNhblFhIbtSxOYAWwAd	1	2023-06-29 12:53:52.750094+00	\N
d37a23ca-caba-4cb3-aeb6-ddbdcdceca6a	e3848a2a-197f-4344-9d1e-12d78d0c45d7	xxwTogBQBKWcnYBrmmqKCLGKvBvsFHoR	1	2023-06-29 13:03:06.116186+00	\N
977536fb-85e4-47a6-a072-945b14c5861f	e3848a2a-197f-4344-9d1e-12d78d0c45d7	RqJGnPkGwkRCBXWhRGpZcZzStWAqJRxG	1	2023-06-29 13:30:20.764072+00	\N
9814cc2e-7d30-4ec4-b96f-324d53ac5379	e3848a2a-197f-4344-9d1e-12d78d0c45d7	hpxCqYhLXcImumFzausCpRRwnlobnxRC	1	2023-06-29 13:39:58.87917+00	\N
297ce0be-3747-4df8-8953-5e3488b04ec3	e3848a2a-197f-4344-9d1e-12d78d0c45d7	xhlmysxkrFdsadcEPCdLIcuKKZdVZTit	1	2023-06-29 13:40:24.422528+00	\N
7be4c3f4-e0ed-4d5f-9576-8430b5fc6927	e3848a2a-197f-4344-9d1e-12d78d0c45d7	bFoVvPHqooLrBAbhPzOnzrdaljjwwkjb	1	2023-06-29 13:46:26.805317+00	\N
7e0c95c6-92e7-4a0d-bc03-22c47af6af8a	e3848a2a-197f-4344-9d1e-12d78d0c45d7	IbskAZUccxsEJwebijIgAlOJAfCMGdqb	1	2023-06-29 13:51:37.232405+00	\N
92ecdb42-1958-4f10-af06-a7b64d4b269e	e3848a2a-197f-4344-9d1e-12d78d0c45d7	XmHMUebyXxqtrDFVUiwcxtezdIwgzpKX	1	2023-06-29 15:18:01.173704+00	\N
a476c3b9-2ba5-4587-906d-697c634509bf	455163b9-674b-4666-ad6c-80f70584a97e	dHKduNiQfGkgUyvmKnjwWWCRSyrPVrvC	1	2023-06-29 15:41:13.278901+00	\N
b8fdbeab-5d23-46e7-ad61-d21aa071b164	455163b9-674b-4666-ad6c-80f70584a97e	eZpCHdRJpjiUEZBvMAUWrWnYPnOKfLRw	1	2023-06-29 15:44:00.130583+00	\N
9ce21062-7454-4e49-9b8c-a362fbab20ca	455163b9-674b-4666-ad6c-80f70584a97e	QfCLcHwXQeKUCIwBoxOiEWrCrgHhLvfS	1	2023-06-29 15:44:45.333119+00	\N
bc1dca20-410b-4d20-80a6-0cc8cd179d9b	455163b9-674b-4666-ad6c-80f70584a97e	rFPOiRstJSdrrTGMLKFKkyCKJEdvZLVW	1	2023-06-29 15:54:16.603227+00	\N
d8ee328e-fddf-446d-8cf3-eca2704f41d4	e3848a2a-197f-4344-9d1e-12d78d0c45d7	DrYfoSVQQAUorxdtJIDNqNWkspKzUegd	1	2023-06-29 15:59:18.377621+00	\N
11e416d1-4a27-4dc1-823a-5d7ff655a96e	e3848a2a-197f-4344-9d1e-12d78d0c45d7	lLaZNNfgljiapUfaEmzrMOALdQVikfsy	1	2023-06-29 16:03:13.088417+00	\N
c1bea37f-2f70-4205-88e1-70a9c599f5f3	e3848a2a-197f-4344-9d1e-12d78d0c45d7	mIOyDFdbvxHaAacvvbJEnvjuYMlgbOhw	1	2023-06-29 16:03:59.535348+00	\N
b8926a7e-5006-4c6c-848b-ea38ce5b06f4	455163b9-674b-4666-ad6c-80f70584a97e	ycwnIaaeDwPzbqnyQEBfJGVUGZSEGafs	1	2023-06-29 16:08:20.102535+00	\N
604ddaa5-e3f1-4848-ac85-5a7f3896f9f8	455163b9-674b-4666-ad6c-80f70584a97e	BiAysoJGgzdxpLqtiyCPiYKrIaFSGkcj	1	2023-06-29 16:10:07.666129+00	\N
8c402cbe-f485-49e7-b406-15262f82224c	455163b9-674b-4666-ad6c-80f70584a97e	OYGgRMEsUXRWUqYKNoBBSTJgfuzuVJRG	1	2023-06-29 16:16:28.649258+00	\N
8d0958d0-4dcd-4b2b-bcc8-99271ccfb42a	455163b9-674b-4666-ad6c-80f70584a97e	TXGzhzGegJTlKDuLhgXNLPJqGPDBqMmx	1	2023-06-29 16:20:38.491322+00	\N
7bcdc8fe-e677-4916-8508-4c0dd3e1d264	455163b9-674b-4666-ad6c-80f70584a97e	uLqjZUPoxRKKtyvqDCGBVJKNjFaiatKL	1	2023-06-29 16:26:20.08785+00	\N
5fbedd97-f691-4844-823f-da420f91c4e0	455163b9-674b-4666-ad6c-80f70584a97e	BnLExqTDEDUDeejtTjyikmecotIhYbka	1	2023-06-29 16:30:22.348934+00	\N
4c734435-1870-42bf-bcc0-5c2d4e476a61	e3848a2a-197f-4344-9d1e-12d78d0c45d7	bagKlGzVQtNLEWPXhKoTqHCGrDvWRvKD	1	2023-06-29 16:34:01.04669+00	\N
150abc8c-9e97-4713-b2e8-ae753e3aa4c3	455163b9-674b-4666-ad6c-80f70584a97e	mJaxqJHHIhLudIvxfekGSQjkDjaJJOSf	1	2023-06-29 16:43:56.933477+00	\N
9870eedf-575c-4453-9e95-447c99f658dd	455163b9-674b-4666-ad6c-80f70584a97e	HuQfVykPbrHkiNIYUgqvZYzXxrLaTUWp	1	2023-06-29 16:49:59.17999+00	\N
70e4fed5-72ea-4186-9e67-da74024dbd17	455163b9-674b-4666-ad6c-80f70584a97e	mBAiUAHhFFeJCdLVbkWxGPSHbQhFxMnW	1	2023-06-29 16:51:14.309885+00	\N
e282d114-de92-41b5-9f38-38cc986ca29d	455163b9-674b-4666-ad6c-80f70584a97e	RPuJtuSuyVmlIyEsyLBNJyTHyudMcpOJ	1	2023-06-29 16:51:38.774023+00	\N
c16afec9-c434-4583-95b9-8b3996802aa5	455163b9-674b-4666-ad6c-80f70584a97e	BeZboKJhhUZFEwrFaqueQQDOEnhHsblQ	1	2023-06-29 17:01:19.803549+00	\N
faa391c9-470a-456f-992d-6fc901933bc1	455163b9-674b-4666-ad6c-80f70584a97e	jZeIUDahwnhNphCkfZNcjwSdVafPLmrd	1	2023-06-29 17:06:35.877617+00	\N
efd5ef89-961c-4046-b0a9-bbe45d6f5975	b0dfd33a-3d66-4133-b08f-9ce2366600ba	MMauCZcWMmYkVOpWPcvCTXcWqdYIhXpI	1	2023-06-29 17:07:45.08595+00	\N
77473ca5-df95-45cb-854e-305bf8fb459e	455163b9-674b-4666-ad6c-80f70584a97e	ZXGqQpdchQVvSOTCCwpwnwKumaIHBHZO	1	2023-06-29 17:10:03.590772+00	\N
77566ab3-1882-44f2-a5b7-ec47b6dac3df	455163b9-674b-4666-ad6c-80f70584a97e	CQSOuTOoHZGlwRgIlFAtCrOVNPhItQMq	1	2023-06-29 17:15:18.978656+00	\N
9b80dfbb-34f8-4ab4-8b9e-ebafba76b32d	455163b9-674b-4666-ad6c-80f70584a97e	EOXcJfuvKDHuQiqCSNoqpDolJtVkWysX	1	2023-06-29 17:31:41.309926+00	\N
8e3ba5ff-141e-4a9c-9285-db93fb20b907	455163b9-674b-4666-ad6c-80f70584a97e	fVwsXaTLDFtUPPYbrgoPyiHmxiinZLhL	1	2023-06-29 17:35:06.768848+00	\N
03089034-d445-4b87-a350-5d9f02bf7fef	455163b9-674b-4666-ad6c-80f70584a97e	ZfxdlfQKeNuGmglYZUxpeHbisaKKVhYO	1	2023-06-29 17:35:31.831356+00	\N
86901115-3594-4f1b-a527-402ff9d39fa2	455163b9-674b-4666-ad6c-80f70584a97e	RJKzErZFkIBZFUhSrbEObCwUGUTnELAX	1	2023-06-29 17:40:27.835439+00	\N
53475234-a692-41ad-982d-9e436bc2c31a	455163b9-674b-4666-ad6c-80f70584a97e	jPtMrZITFerpgYdjxyhAURbRxJnTlKOa	1	2023-06-29 17:43:39.913413+00	\N
8b19df94-66ba-4cf4-83ae-44bbc503f240	455163b9-674b-4666-ad6c-80f70584a97e	OXMPNvRGRcDwRcamSTCOiNHewgVBifbA	1	2023-06-29 17:46:49.842094+00	\N
fa104282-2933-4423-94c8-89d263199bca	455163b9-674b-4666-ad6c-80f70584a97e	bWbTvcFtCUQoQzeAyQYeOUiNZCgkBzlI	1	2023-06-29 17:48:15.381169+00	\N
e0425639-7a08-40d1-9b1a-e43a8cc84541	455163b9-674b-4666-ad6c-80f70584a97e	YpRxLEkMQxOehvaSFkDVkMpqMiGqGknq	1	2023-06-29 17:50:53.356971+00	\N
5c2bb7a8-916a-4b0c-85c0-ab1efd29ac7d	455163b9-674b-4666-ad6c-80f70584a97e	aHOZNsykanrtvdxTlGPDpaiLjIgkwZPM	1	2023-06-29 17:54:45.213442+00	\N
e34d02a5-d0d0-4148-a882-a17b17c3511b	455163b9-674b-4666-ad6c-80f70584a97e	vHNsMNhDOqhLvFWmVmleSedrTMhpXQSk	1	2023-06-29 18:02:13.219949+00	\N
0d56a7a4-ea08-4131-bc18-1358b8e947ca	455163b9-674b-4666-ad6c-80f70584a97e	QIdVwjhYKBYNhqvcLSlnptNZutfhqOmp	1	2023-06-29 18:04:54.581631+00	\N
1ee98fd6-73d2-46f9-991d-767bb2e8d4f2	455163b9-674b-4666-ad6c-80f70584a97e	CVAobkpEkyudXdVafRqpxugvRLlxBmdb	1	2023-06-29 18:12:08.42899+00	\N
dbc33f1e-fe9d-40ae-ac30-f6d6a69bd181	455163b9-674b-4666-ad6c-80f70584a97e	IBCmwYuUzUfUxaxcfJCEfPYYbbjtPkca	1	2023-06-29 18:13:18.988756+00	\N
0b710abb-b5bb-42df-bcf9-808ff0a2de49	455163b9-674b-4666-ad6c-80f70584a97e	dZkQijnjCFAHNTGqGsstPUeddPymsoRY	1	2023-06-29 18:13:44.976477+00	\N
fb75dfa1-dc0a-464a-a6c4-a88c6ad479d8	455163b9-674b-4666-ad6c-80f70584a97e	WErjMYsJiwMvJppPxwSBvJjvqeEutOrh	1	2023-06-29 18:15:12.715654+00	\N
33a011fb-4b65-42c0-9e01-a68eda134c1d	455163b9-674b-4666-ad6c-80f70584a97e	YPiBsomVmpkNxxrSFxMnxjmIeqBneecN	1	2023-06-29 18:19:09.30917+00	\N
00f75918-67a5-47d6-8fea-736cde1f795f	455163b9-674b-4666-ad6c-80f70584a97e	AzgYnGhVaRkgCPiitdJQLCHFfdwKHxph	1	2023-06-29 18:26:43.723828+00	\N
6b6a9eb2-7fb9-4baa-bd91-61621de89fe3	455163b9-674b-4666-ad6c-80f70584a97e	mDZRWtynXLcjxEVDTfCJWZifqfCHufUQ	1	2023-06-29 18:27:20.51576+00	\N
6468c269-25cd-4a39-9848-cf0586f70223	455163b9-674b-4666-ad6c-80f70584a97e	pHamGJHQDSONuwBYNbgGYhGeThEFLNHO	1	2023-06-29 18:27:43.1637+00	\N
e0184e95-7190-4b73-aec8-10167ec194d2	455163b9-674b-4666-ad6c-80f70584a97e	mSLyyFrxnIwtDXChzeHqljQojEPELLwr	1	2023-06-29 18:28:07.629394+00	\N
7f59116d-4b43-4b3d-a71b-71f97f1388d9	455163b9-674b-4666-ad6c-80f70584a97e	mjOuckjVlMRDNwSErNUlyubrmavrsftO	1	2023-06-29 18:28:36.57472+00	\N
a7732af0-1f32-4457-8d71-eaf1f3c3c4b4	455163b9-674b-4666-ad6c-80f70584a97e	eDudXGVChVhyXDrFRCAIeuVUKrDdDwlR	1	2023-06-29 18:31:01.253434+00	\N
4a683a08-1d9b-43b2-ab74-29b474f535c8	455163b9-674b-4666-ad6c-80f70584a97e	PNCWfbpIXBuNLNWBluPwjkHeJyABVHST	1	2023-06-29 18:38:40.225459+00	\N
bafc8a46-c670-46c2-b9db-01fed7e581d2	455163b9-674b-4666-ad6c-80f70584a97e	uPUPsJbiYiwhGqXAyjgMxmpGtIahfTqk	1	2023-06-29 18:43:22.215199+00	\N
be117d2c-a899-41b0-8196-8159f424272b	455163b9-674b-4666-ad6c-80f70584a97e	yinPHgFnJMVlJqDFKkTOteDZRoecsqdW	1	2023-06-29 18:45:04.530939+00	\N
217445aa-0995-4e26-aba2-0ae5344998a4	455163b9-674b-4666-ad6c-80f70584a97e	AvLKmEmhPXmhgUdPnhhDusvwpSosMiQQ	1	2023-06-29 18:50:57.465815+00	\N
d43b5e15-b67b-42d7-a62b-842358bab873	455163b9-674b-4666-ad6c-80f70584a97e	oURHvyKDxPmGNeeKFwJvpbUUbfkaJrwm	1	2023-06-29 18:53:06.31639+00	\N
e3e44805-904b-4dda-9428-98225014c1be	455163b9-674b-4666-ad6c-80f70584a97e	gCvhQZtGGHoioZgpkhzIYyBJLsijzMOi	1	2023-06-29 18:54:06.098484+00	\N
4102b66a-c968-4928-8564-2f4a9e9c040a	455163b9-674b-4666-ad6c-80f70584a97e	RXogwolfTFTSundSUhmiRmsUgINiSLwm	1	2023-06-29 18:55:12.900722+00	\N
deb0b8d2-355f-4ca5-90df-a29864443484	455163b9-674b-4666-ad6c-80f70584a97e	JXRfQbINEYcKaywJOEwPfVTHfSvRNIKo	1	2023-06-29 19:06:22.223923+00	\N
06e9ef6d-e6e6-4e5b-8e32-4ad745dcc6ed	455163b9-674b-4666-ad6c-80f70584a97e	dByhWaFpBlJabHgXYHMZGisGBVyrcBKT	1	2023-06-29 19:07:17.688365+00	\N
161781b7-437d-4e32-870d-1c37abf38990	455163b9-674b-4666-ad6c-80f70584a97e	DrMsHPBGxCANZyhnkrHnPmGEOfWHskVL	1	2023-06-29 19:07:58.539587+00	\N
cbf09b03-3fdd-4d58-bb62-abdf829bc4fc	455163b9-674b-4666-ad6c-80f70584a97e	gcVdRNhdzJupzLvydyCurNRtoIXDzVDt	1	2023-06-29 19:08:43.137053+00	\N
5890ce5f-90cf-4c6c-b5ce-e09bdc04a8aa	455163b9-674b-4666-ad6c-80f7